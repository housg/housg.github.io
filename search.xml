<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[hexo+Github,搭建属于自己的博客]]></title>
      <url>/hexo-Github-%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h1 id="HEXO-Github-搭建属于自己的博客"><a href="#HEXO-Github-搭建属于自己的博客" class="headerlink" title="HEXO+Github,搭建属于自己的博客"></a>HEXO+Github,搭建属于自己的博客</h1><p>过各种找资料，踩过各种坑，终于搭建好了hexo，域名是在万维网上买的，我的hexo是3.1.1版本，hexo不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。</p>
<h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>hexo是一款基于Node.js的静态博客框架, hexo github链接 ,这篇教程是针对与Mac的，参考链接，由于原文讲到的hexo是以前的老版本，所以现在的版本配置的时候会有些改动。</p>
<p>之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我，不是太喜欢，简书还算好点得。最近看到一些大神们的博客,貌似都是用hexo写得,我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。</p>
<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><h4 id="安装Node（必须）"><a href="#安装Node（必须）" class="headerlink" title="安装Node（必须）"></a>安装Node（必须）</h4><p>作用：用来生成静态页面的</p>
<p>到Node.js官网下载相应平台的最新版本，一路安装即可。</p>
<h4 id="安装Git（必须）"><a href="#安装Git（必须）" class="headerlink" title="安装Git（必须）"></a>安装Git（必须）</h4><p>作用：把本地的hexo内容提交到github上去.</p>
<p>安装Xcode就自带有Git，我就不多说了。</p>
<h4 id="申请GitHub（必须）"><a href="#申请GitHub（必须）" class="headerlink" title="申请GitHub（必须）"></a>申请GitHub（必须）</h4><p>作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。</p>
<p>github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。</p>
<h3 id="正式安装Hexo"><a href="#正式安装Hexo" class="headerlink" title="正式安装Hexo"></a>正式安装Hexo</h3><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p>
<p>执行如下命令安装Hexo：</p>
<p>sudo npm install -g hexo</p>
<p>初始化然后，执行init命令初始化hexo,命令：</p>
<p>hexo init</p>
<p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。</p>
<p><strong>生成静态页面</strong></p>
<p>hexo generate（hexo g也可以）</p>
<p><strong>本地启动</strong></p>
<p>启动本地服务，进行文章预览调试，命令：</p>
<p>hexo server</p>
<p>浏览器输入<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p>
<p>我不知道你们能不能，反正我不能，因为我还有环境没配置好</p>
<h3 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h3><p>建立Repository</p>
<p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法</p>
<p>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p>
<pre><code>_config.yml    node_modules    public      source

db.json        package.json    scaffolds  themes
</code></pre><p>现在我们需要_config.yml文件，来建立关联，命令：</p>
<p>vim _config.yml</p>
<p>翻到最下面，改成我这样子的</p>
<p>deploy:</p>
<pre><code>type: git

repo: https://github.com/leopardpan/leopardpan.github.io.git

branch: master
</code></pre><p>然后执行命令：</p>
<p>npm install hexo-deployer-git –save</p>
<p>网上会有很多说法，有的type是github, 还有repository最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。</p>
<p>忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。</p>
<p>然后，执行配置命令：</p>
<p>hexo deploy</p>
<p>然后再浏览器中输入<a href="http://leopardpan.github.io/就行了，我的github的账户叫leopardpan,把这个改成你github的账户名就行了" target="_blank" rel="external">http://leopardpan.github.io/就行了，我的github的账户叫leopardpan,把这个改成你github的账户名就行了</a></p>
<p>部署步骤</p>
<p>每次部署的步骤，可按以下三步来进行。</p>
<pre><code>hexo clean

hexo generate

hexo deploy
</code></pre><p>一些常用命令：</p>
<p>hexo new”postName” #新建文章</p>
<p>hexo new page”pageName” #新建页面</p>
<p>hexo generate #生成静态页面至public目录</p>
<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>
<p>hexo deploy #将.deploy目录部署到GitHub</p>
<p>hexo help # 查看帮助</p>
<p>hexo version #查看Hexo的版本</p>
<p>报错总结</p>
<p>ERROR Deployer not found: git 或者 ERROR Deployer not found: github</p>
<p>解决方法： npm install hexo-deployer-git –save</p>
<p>如发生报错： ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令：</p>
<p>rm-rf.DS_Store</p>
<p>ERROR Plugin load failed: hexo-server</p>
<p>原因：</p>
<p>Besides,utilities are separated into a standalone module.hexo.util is not reachable anymore.</p>
<p>解决方法，执行命令：</p>
<p>sudo npm install hexo-server</p>
<p>执行命令hexo server，提示：Usage: hexo ….</p>
<p>原因：</p>
<p>我认为是没有生成本地服务</p>
<p>解决方法，执行命令：</p>
<p>npm install hexo-server –save</p>
<p>提示：hexo-server@0.1.2 node_modules/hexo-server</p>
<p>….</p>
<p>表示成功了参考</p>
<p>这个时候再执行：</p>
<p>hexo-server</p>
<p>得到:</p>
<p>INFOHexois running at <a href="http://0.0.0.0:4000/.PressCtrl+C" target="_blank" rel="external">http://0.0.0.0:4000/.PressCtrl+C</a> to stop.</p>
<p>这个时候再点击<a href="http://0.0.0.0:4000，正常情况下应该是最原始的画面，但是我看到的是：" target="_blank" rel="external">http://0.0.0.0:4000，正常情况下应该是最原始的画面，但是我看到的是：</a></p>
<p>白板和Cannot GET / 几个字</p>
<p>原因：</p>
<p>由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：</p>
<p>npm install hexo-renderer-ejs –save</p>
<p>npm install hexo-renderer-stylus –save</p>
<p>npm install hexo-renderer-marked –save</p>
<p>这个时候再重新生成静态文件，命令：</p>
<p>hexo generate（或hexo g）</p>
<p>启动本地服务器：</p>
<p>hexo server（或hexo s）</p>
<p>再，点击网址<a href="http://0.0.0.0:4000OK终于可以看到属于你自己的blog啦，😄，虽然很简陋，但好歹有了一个属于自己的小窝了。参考链接，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。" target="_blank" rel="external">http://0.0.0.0:4000OK终于可以看到属于你自己的blog啦，😄，虽然很简陋，但好歹有了一个属于自己的小窝了。参考链接，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。</a></p>
<p>主题推荐</p>
<p>这里有大量的主题列表使用方法里面</p>
<p>都有详细的介绍，我就不多说了。</p>
<p>我这里有几款个人认为不错的主题，免去你们，一个一个的选了，欢迎吐槽我的审美，😄</p>
<p>Cover- A chic theme with facebook-like cover photo</p>
<p>Oishi- A white theme based on Landscape plus and Writing.</p>
<p>Sidebar- Another theme based on Light with a simple sidebar</p>
<p>TKL- A responsive design theme for Hexo. 一个设计优雅的响应式主题</p>
<p>Tinnypp- A clean, simple theme based on Tinny</p>
<p>Writing- A small and simple hexo theme based on Light</p>
<p>Yilia- Responsive and simple style 优雅简洁响应式主题，我用得就是这个。</p>
<p>Pacman voidy- A theme with dynamic tagcloud and dynamic snow</p>
<p>一些基本路径</p>
<p>文章在source/_posts, 文章支持Markdown语法，可以使用一些MarkDown渲染工具。如果想修改头像可以直接在主题的_config.yml文件里面修改，友情链接，之类的都在这里。开始打理你的博客吧，有什么问题或者建议，都可以提出来，我会继续完善的。</p>
<p>修改头像</p>
<p>我当前的路径/Users/leopard/blog/themes/yilia，ls 你可以看到</p>
<p>Gruntfile.js    _config.yml package.json</p>
<p>README.md  layout      source</p>
<p>vim _config.yml 进去，找到 #你的头像url avatar: 后接一个URL就行了，头像就修改成功了</p>
<p>修改主题和作者名字</p>
<p>我当前的路径/Users/leopard/blog，ls 你可以看到</p>
<p>_config.yml  node_modules    public      source      themes</p>
<p>db.json        package.json     scaffolds   ssh-keygen</p>
<p>vim _config.yml 进去，找到 author: 潘柏信，修改成你自己的名字就行了</p>
<p>修改主题，然后继续往下找到</p>
<p>Extensions</p>
<p>Plugins: <a href="http://hexo.io/plugins/" target="_blank" rel="external">http://hexo.io/plugins/</a></p>
<p>Themes: <a href="http://hexo.io/themes/" target="_blank" rel="external">http://hexo.io/themes/</a></p>
<p>theme:yilia</p>
<p>改成theme: yilia，theme:后面接你自己的主题名字就行了,然后分别执行</p>
<p>部署 hexo g</p>
<p>提交 hexo d</p>
<p>你的主题，和名字就修改成功了</p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> GitHub </tag>
            
            <tag> Blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见框架面试题]]></title>
      <url>/%E5%B8%B8%E8%A7%81%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="流行的框架与新技术"><a href="#流行的框架与新技术" class="headerlink" title="流行的框架与新技术"></a>流行的框架与新技术</h1><h2 id="1、谈谈你对Struts的理解。"><a href="#1、谈谈你对Struts的理解。" class="headerlink" title="1、谈谈你对Struts的理解。"></a>1、谈谈你对Struts的理解。</h2><pre><code>答: 1. struts是一个按MVC模式设计的Web层框架，其实它就是一个大大的servlet，这个Servlet名为ActionServlet，或是ActionServlet的子类。我们可以在web.xml文件中将符合某种特征的所有请求交给这个Servlet处理，这个Servlet再参照一个配置文件（通常为/WEB-INF/struts-config.xml）将各个请求分别分配给不同的action去处理。

一个扩展知识点：struts的配置文件可以有多个，可以按模块配置各自的配置文件，这样可以防止配置文件的过度膨胀；

2. ActionServlet把请求交给action去处理之前，会将请求参数封装成一个formbean对象（就是一个java类，这个类中的每个属性对应一个请求参数），封装成一个什么样的formbean对象呢？看配置文件。

3.要说明的是， ActionServlet把formbean对象传递给action的execute方法之前，可能会调用formbean的validate方法进行校验，只有校验通过后才将这个formbean对象传递给action的execute方法，否则，它将返回一个错误页面，这个错误页面由input属性指定，（看配置文件）作者为什么将这里命名为input属性，而不是error属性，我们后面结合实际的运行效果进行分析。

4.action执行完后要返回显示的结果视图，这个结果视图是用一个ActionForward对象来表示的，actionforward对象通过struts-config.xml配置文件中的配置关联到某个jsp页面，因为程序中使用的是在struts-config.xml配置文件为jsp页面设置的逻辑名，这样可以实现action程序代码与返回的jsp页面名称的解耦。

你对struts可能还有自己的应用方面的经验，那也要一并说出来。
</code></pre><h2 id="2、谈谈你对Hibernate的理解。"><a href="#2、谈谈你对Hibernate的理解。" class="headerlink" title="2、谈谈你对Hibernate的理解。"></a>2、谈谈你对Hibernate的理解。</h2><pre><code>答:1. 面向对象设计的软件内部运行过程可以理解成就是在不断创建各种新对象、建立对象之间的关系，调用对象的方法来改变各个对象的状态和对象消亡的过程，不管程序运行的过程和操作怎么样，本质上都是要得到一个结果，程序上一个时刻和下一个时刻的运行结果的差异就表现在内存中的对象状态发生了变化。

2.为了在关机和内存空间不够的状况下，保持程序的运行状态，需要将内存中的对象状态保存到持久化设备和从持久化设备中恢复出对象的状态，通常都是保存到关系数据库来保存大量对象信息。从Java程序的运行功能上来讲，保存对象状态的功能相比系统运行的其他功能来说，应该是一个很不起眼的附属功能，java采用jdbc来实现这个功能，这个不起眼的功能却要编写大量的代码，而做的事情仅仅是保存对象和恢复对象，并且那些大量的jdbc代码并没有什么技术含量，基本上是采用一套例行公事的标准代码模板来编写，是一种苦活和重复性的工作。

3.通过数据库保存java程序运行时产生的对象和恢复对象，其实就是实现了java对象与关系数据库记录的映射关系，称为ORM（即Object Relation Mapping），人们可以通过封装JDBC代码来实现了这种功能，封装出来的产品称之为ORM框架，Hibernate就是其中的一种流行ORM框架。使用Hibernate框架，不用写JDBC代码，仅仅是调用一个save方法，就可以将对象保存到关系数据库中，仅仅是调用一个get方法，就可以从数据库中加载出一个对象。

4.使用Hibernate的基本流程是：配置Configuration对象、产生SessionFactory、创建session对象，启动事务，完成CRUD操作，提交事务，关闭session。

5.使用Hibernate时，先要配置hibernate.cfg.xml文件，其中配置数据库连接信息和方言等，还要为每个实体配置相应的hbm.xml文件，hibernate.cfg.xml文件中需要登记每个hbm.xml文件。

6.在应用Hibernate时，重点要了解Session的缓存原理，级联，延迟加载和hql查询。
</code></pre><p>3、AOP的作用。</p>
<h2 id="4、你对Spring的理解。"><a href="#4、你对Spring的理解。" class="headerlink" title="4、你对Spring的理解。"></a>4、你对Spring的理解。</h2><pre><code>1.Spring实现了工厂模式的工厂类（在这里有必要解释清楚什么是工厂模式），这个类名为BeanFactory（实际上是一个接口），在程序中通常BeanFactory的子类ApplicationContext。Spring相当于一个大的工厂类，在其配置文件中通过&lt;bean&gt;元素配置用于创建实例对象的类名和实例对象的属性。

2. Spring提供了对IOC良好支持，IOC是一种编程思想，是一种架构艺术，利用这种思想可以很好地实现模块之间的解耦。IOC也称为DI（Depency Injection），什么叫依赖注入呢？
</code></pre><p>譬如，Class Programmer</p>
<p>{</p>
<p>Computer computer = null;</p>
<p>public void code()</p>
<p>{</p>
<p>//Computer computer = new IBMComputer();</p>
<p>//Computer computer = beanfacotry.getComputer();</p>
<p>computer.write();</p>
<p>}</p>
<p>public void setComputer(Computer computer)</p>
<p>{</p>
<p>this.computer = computer;</p>
<p>}</p>
<p>}<br> 另外两种方式都由依赖，第一个直接依赖于目标类，第二个把依赖转移到工厂上，第三个彻底与目标和工厂解耦了。在spring的配置文件中配置片段如下：</p>
<bean id="”computer”" class="”cn.itcast.interview.Computer”"><br><br></bean>

<bean id="”programmer”" class="”cn.itcast.interview.Programmer”"><br><br><property name="”computer”" ref="”computer”"></property><br><br></bean>

<pre><code>3. Spring提供了对AOP技术的良好封装， AOP称为面向切面编程，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码，例如，加入日志，加入权限判断，加入异常处理，这种应用称为AOP。实现AOP功能采用的是代理技术，客户端程序不再调用目标，而调用代理类，代理类与目标类对外具有相同的方法声明，有两种方式可以实现相同的方法声明，一是实现相同的接口，二是作为目标的子类在，JDK中采用Proxy类产生动态代理的方式为某个接口生成实现类，如果要为某个类生成子类，则可以用CGLI B。在生成的代理类的方法中加入系统功能和调用目标类的相应方法，系统功能的代理以Advice对象进行提供，显然要创建出代理对象，至少需要目标类和Advice类。spring提供了这种支持，只需要在spring配置文件中配置这两个元素即可实现代理和aop功能，例如，
</code></pre><bean id="”proxy”" type="”org.spring.framework.aop.ProxyBeanFactory”"><br><br><property name="”target”" ref="””"></property><br><br><property name="”advisor”" ref="””"></property><br><br></bean>

<h2 id="5、谈谈Struts中的Action-servlet。"><a href="#5、谈谈Struts中的Action-servlet。" class="headerlink" title="5、谈谈Struts中的Action servlet。"></a>5、谈谈Struts中的Action servlet。</h2><h2 id="6、Struts优缺点"><a href="#6、Struts优缺点" class="headerlink" title="6、Struts优缺点"></a>6、Struts优缺点</h2><p>优点： </p>
<pre><code> 1. 实现MVC模式，结构清晰,使开发者只关注业务逻辑的实现.

2．有丰富的tag可以用 ,Struts的标记库(Taglib)，如能灵活动用，则能大大提高开发效率

3. 页面导航
</code></pre><p>使系统的脉络更加清晰。通过一个配置文件，即可把握整个系统各部分之间的联系，这对于后期的维护有着莫大的好处。尤其是当另一批开发者接手这个项目时，这种优势体现得更加明显。</p>
<pre><code>4. 提供Exception处理机制 .

5. 数据库链接池管理

6. 支持I18N
</code></pre><p>缺点</p>
<p>一、 转到展示层时，需要配置forward，如果有十个展示层的jsp，需要配置十次struts，而且还不包括有时候目录、文件变更，需要重新修改forward，注意，每次修改配置之后，要求重新部署整个项目，而tomcate这样的服务器，还必须重新启动服务器</p>
<p>二、 Struts 的Action必需是thread－safe方式，它仅仅允许一个实例去处理所有的请求。所以action用到的所有的资源都必需统一同步，这个就引起了线程安全的问题。</p>
<p>三、  测试不方便. Struts的每个Action都同Web层耦合在一起，这样它的测试依赖于Web容器，单元测试也很难实现。不过有一个Junit的扩展工具Struts TestCase可以实现它的单元测试。</p>
<p>四、  类型的转换. Struts的FormBean把所有的数据都作为String类型，它可以使用工具Commons-Beanutils进行类型转化。但它的转化都是在Class级别，而且转化的类型是不可配置的。类型转化时的错误信息返回给用户也是非常困难的。</p>
<p>五、 对Servlet的依赖性过强. Struts处理Action时必需要依赖ServletRequest 和ServletResponse，所有它摆脱不了Servlet容器。</p>
<p>六、  前端表达式语言方面.Struts集成了JSTL，所以它主要使用JSTL的表达式语言来获取数据。可是JSTL的表达式语言在Collection和索引属性方面处理显得很弱。</p>
<p>七、  对Action执行的控制困难. Struts创建一个Action，如果想控制它的执行顺序将会非常困难。甚至你要重新去写Servlet来实现你的这个功能需求。</p>
<p>八、  对Action 执行前和后的处理. Struts处理Action的时候是基于class的hierarchies，很难在action处理前和后进行操作。</p>
<p>九、  对事件支持不够. 在struts中，实际是一个表单Form对应一个Action类(或DispatchAction)，换一句话说：在Struts中实际是一个表单只能 对应一个事件，struts这种事件方式称为application event，application event和component event相比是一种粗粒度的事件</p>
<h2 id="7、STRUTS的应用-如STRUTS架构"><a href="#7、STRUTS的应用-如STRUTS架构" class="headerlink" title="7、STRUTS的应用(如STRUTS架构)"></a>7、STRUTS的应用(如STRUTS架构)</h2><pre><code>Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。 采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架。 Struts有如下的主要功能： 一.包含一个controller servlet，能将用户的请求发送到相应的Action对象。 二.JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。 三.提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。
</code></pre><h2 id="8、说说struts1与struts2的区别。"><a href="#8、说说struts1与struts2的区别。" class="headerlink" title="8、说说struts1与struts2的区别。"></a>8、说说struts1与struts2的区别。</h2><pre><code>1.都是MVC的WEB框架,

2 struts1的老牌框架，应用很广泛，有很好的群众基础，使用它开发风险很小，成本更低！struts2虽然基于这个框架，但是应用群众并多，相对不成熟，未知的风险和变化很多，开发人员相对不好招，使用它开发项目的风险系数更大，用人成本更高！

3.struts2毕竟是站在前辈的基础设计出来，它会改善和完善struts1中的一些缺陷，struts1中一些悬而未决问题在struts2得到了解决。

4.struts1的前端控制器是一个Servlet，名称为ActionServlet，struts2的前端控制器是一个filter，在struts2.0中叫FilterDispatcher，在struts2.1中叫StrutsPrepareAndExecuteFilter。

5.struts1的action需要继承Action类，struts2的action可以不继承任何类；struts1对同一个路径的所有请求共享一个Action实例，struts2对同一个路径的每个请求分别使用一个独立Action实例对象，所有对于struts2的Action不用考虑线程安全问题。

6.在struts1中使用formbean封装请求参数，在struts2中直接使用action的属性来封装请求参数。

7.struts1中的多个业务方法放在一个Action中时（即继承DispatchAction时），要么都校验，要么都不校验；对于struts2，可以指定只对某个方法进行校验，当一个Action继承了ActionSupport且在这个类中只编写了validateXxx()方法，那么则只对Xxx()方法进行校验。
</code></pre><p>（一个请求来了的执行流程进行分析，struts2是自动支持分模块开发，并可以不同模块设置不同的url前缀，这是通过package的namespace来实现的；struts2是支持多种类型的视图；struts2的视图地址可以是动态的，即视图的名称是支持变量方式的，举例，论坛发帖失败后回来还要传递boardid。视图内容显示方面：它的标签用ognl，要el强大很多，在国际化方面支持分模块管理，两个模块用到同样的key，对应不同的消息；）</p>
<p>与Struts1不同，Struts2对用户的每一次请求都会创建一个Action，所以Struts2中的Action是线程安全的。</p>
<p>给我印象最深刻的是：struts配置文件中的redirect视图的url不能接受参数，而struts2配置文件中的redirect视图可以接受参数。</p>
<h2 id="9、hibernate中的update-和saveOrUpdate-的区别，session的load-和get-的区别。"><a href="#9、hibernate中的update-和saveOrUpdate-的区别，session的load-和get-的区别。" class="headerlink" title="9、hibernate中的update()和saveOrUpdate()的区别，session的load()和get()的区别。"></a>9、hibernate中的update()和saveOrUpdate()的区别，session的load()和get()的区别。</h2><h2 id="10、简述-Hibernate-和-JDBC-的优缺点-如何书写一个-one-to-many-配置文件"><a href="#10、简述-Hibernate-和-JDBC-的优缺点-如何书写一个-one-to-many-配置文件" class="headerlink" title="10、简述 Hibernate 和 JDBC 的优缺点? 如何书写一个 one to many 配置文件."></a>10、简述 Hibernate 和 JDBC 的优缺点? 如何书写一个 one to many 配置文件.</h2><h2 id="11、iBatis与Hibernate有什么不同"><a href="#11、iBatis与Hibernate有什么不同" class="headerlink" title="11、iBatis与Hibernate有什么不同?"></a>11、iBatis与Hibernate有什么不同?</h2><p>相同点：屏蔽jdbc api的底层访问细节，使用我们不用与jdbc api打交道，就可以访问数据。</p>
<p>jdbc api编程流程固定，还将sql语句与java代码混杂在了一起，经常需要拼凑sql语句，细节很繁琐。</p>
<p>ibatis的好处：屏蔽jdbc api的底层访问细节；将sql语句与java代码进行分离;提供了将结果集自动封装称为实体对象和对象的集合的功能，queryForList返回对象集合，用queryForObject返回单个对象；提供了自动将实体对象的属性传递给sql语句的参数。</p>
<p>Hibernate是一个全自动的orm映射工具，它可以自动生成sql语句,ibatis需要我们自己在xml配置文件中写sql语句，hibernate要比ibatis功能负责和强大很多。因为hibernate自动生成sql语句，我们无法控制该语句，我们就无法去写特定的高效率的sql。对于一些不太复杂的sql查询，hibernate可以很好帮我们完成，但是，对于特别复杂的查询，hibernate就很难适应了，这时候用ibatis就是不错的选择，因为ibatis还是由我们自己写sql语句。</p>
<h2 id="12、写Hibernate的一对多和多对一双向关联的orm配置"><a href="#12、写Hibernate的一对多和多对一双向关联的orm配置" class="headerlink" title="12、写Hibernate的一对多和多对一双向关联的orm配置?"></a>12、写Hibernate的一对多和多对一双向关联的orm配置?</h2><h2 id="13、hibernate的inverse属性的作用"><a href="#13、hibernate的inverse属性的作用" class="headerlink" title="13、hibernate的inverse属性的作用?"></a>13、hibernate的inverse属性的作用?</h2><p>解决方案一，按照Object[]数据取出数据，然后自己组bean</p>
<p>解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2</p>
<p>field2) ，然后在hql里面就可以直接生成这个bean了。</p>
<h2 id="14、在DAO中如何体现DAO设计模式"><a href="#14、在DAO中如何体现DAO设计模式" class="headerlink" title="14、在DAO中如何体现DAO设计模式?"></a>14、在DAO中如何体现DAO设计模式?</h2><p>解决方案一，按照Object[]数据取出数据，然后自己组bean</p>
<p>解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2</p>
<p>field2) ，然后在hql里面就可以直接生成这个bean了。</p>
<h2 id="15、spring-Hibernate中委托方案怎么配置"><a href="#15、spring-Hibernate中委托方案怎么配置" class="headerlink" title="15、spring+Hibernate中委托方案怎么配置?"></a>15、spring+Hibernate中委托方案怎么配置?</h2><p>解决方案一，按照Object[]数据取出数据，然后自己组bean</p>
<p>解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2</p>
<p>field2) ，然后在hql里面就可以直接生成这个bean了。</p>
<h2 id="16、spring-Hibernate中委托方案怎么配置"><a href="#16、spring-Hibernate中委托方案怎么配置" class="headerlink" title="16、spring+Hibernate中委托方案怎么配置?"></a>16、spring+Hibernate中委托方案怎么配置?</h2><p>解决方案一，按照Object[]数据取出数据，然后自己组bean</p>
<p>解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2</p>
<p>field2) ，然后在hql里面就可以直接生成这个bean了。</p>
<h2 id="17-hibernate进行多表查询每个表中各取几个字段，也就是说查询出来的结果集没有一个实体类与之对应如何解决；"><a href="#17-hibernate进行多表查询每个表中各取几个字段，也就是说查询出来的结果集没有一个实体类与之对应如何解决；" class="headerlink" title="17. hibernate进行多表查询每个表中各取几个字段，也就是说查询出来的结果集没有一个实体类与之对应如何解决；"></a>17. hibernate进行多表查询每个表中各取几个字段，也就是说查询出来的结果集没有一个实体类与之对应如何解决；</h2><p>解决方案一，按照Object[]数据取出数据，然后自己组bean</p>
<p>解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2</p>
<p>field2) ，然后在hql里面就可以直接生成这个bean了。</p>
<h2 id="18-介绍一下Hibernate的二级缓存"><a href="#18-介绍一下Hibernate的二级缓存" class="headerlink" title="18.介绍一下Hibernate的二级缓存"></a>18.介绍一下Hibernate的二级缓存</h2><p>按照以下思路来回答：（1）首先说清楚什么是缓存，（2）再说有了hibernate的Session就是一级缓存，即有了一级缓存，为什么还要有二级缓存，（3）最后再说如何配置Hibernate的二级缓存。 </p>
<p>（1）缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中（一个数据结构中），这个数据结构通常是或类似Hashmap，当以后要使用某个对象时，先查询缓存中是否有这个对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在缓存中，以便下次使用。下面是缓存的伪代码：</p>
<p>引出hibernate的第二级缓存，用下面的伪代码分析了Cache的实现原理</p>
<p>Dao</p>
<p>{</p>
<p>hashmap map = new map();</p>
<p>User getUser(integer id)</p>
<p>{</p>
<p>User user = map.get(id)</p>
<p>if(user == null)</p>
<p>{</p>
<p>user = session.get(id);</p>
<p>map.put(id,user);</p>
<p>}</p>
<p>return user;</p>
<p>}</p>
<p>}</p>
<p>Dao</p>
<p>{</p>
<p>Cache cache = null</p>
<p>setCache(Cache cache)</p>
<p>{</p>
<p>this.cache = cache</p>
<p>}</p>
<p>User getUser(int id)</p>
<p>{</p>
<p>if(cache!=null)</p>
<p>{</p>
<p>User user = cache.get(id);</p>
<p>if(user ==null)</p>
<p>{</p>
<p>user = session.get(id);</p>
<p>cache.put(id,user);</p>
<p>}</p>
<p>return user;</p>
<p>}</p>
<p>return session.get(id);</p>
<p>}</p>
<p>}</p>
<p>（2）Hibernate的Session就是一种缓存，我们通常将之称为Hibernate的一级缓存，当想使用session从数据库中查询出一个对象时，Session也是先从自己内部查看是否存在这个对象，存在则直接返回，不存在才去访问数据库，并将查询的结果保存在自己内部。由于Session代表一次会话过程，一个Session与一个数据库连接相关连，所以Session最好不要长时间保持打开，通常仅用于一个事务当中，在事务结束时就应关闭。并且Session是线程不安全的，被多个线程共享时容易出现问题。通常只有那种全局意义上的缓存才是真正的缓存应用，才有较大的缓存价值，因此，Hibernate的Session这一级缓存的缓存作用并不明显，应用价值不大。Hibernate的二级缓存就是要为Hibernate配置一种全局缓存，让多个线程和多个事务都可以共享这个缓存。我们希望的是一个人使用过，其他人也可以使用，session没有这种效果。</p>
<p>（3）二级缓存是独立于Hibernate的软件部件，属于第三方的产品，多个厂商和组织都提供有缓存产品，例如，EHCache和OSCache等等。在Hibernate中使用二级缓存，首先就要在hibernate.cfg.xml配置文件中配置使用哪个厂家的缓存产品，接着需要配置该缓存产品自己的配置文件，最后要配置Hibernate中的哪些实体对象要纳入到二级缓存的管理中。明白了二级缓存原理和有了这个思路后，很容易配置起Hibernate的二级缓存。扩展知识：一个SessionFactory可以关联一个二级缓存，也即一个二级缓存只能负责缓存一个数据库中的数据，当使用Hibernate 的二级缓存后，注意不要有其他的应用或SessionFactory来更改当前数据库中的数据，这样缓存的数据就会与数据库中的实际数据不一致。</p>
<h2 id="19、Spring-的依赖注入是什么意思-给一个-Bean-的-message-属性-字符串类型-注入值为-“Hello”-的-XML-配置文件该怎么写"><a href="#19、Spring-的依赖注入是什么意思-给一个-Bean-的-message-属性-字符串类型-注入值为-“Hello”-的-XML-配置文件该怎么写" class="headerlink" title="19、Spring 的依赖注入是什么意思? 给一个 Bean 的 message 属性, 字符串类型, 注入值为 “Hello” 的 XML 配置文件该怎么写?"></a>19、Spring 的依赖注入是什么意思? 给一个 Bean 的 message 属性, 字符串类型, 注入值为 “Hello” 的 XML 配置文件该怎么写?</h2><h2 id="20、Jdo是什么"><a href="#20、Jdo是什么" class="headerlink" title="20、Jdo是什么?"></a>20、Jdo是什么?</h2><p>JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。</p>
<h2 id="21-什么是spring的IOC-AOP"><a href="#21-什么是spring的IOC-AOP" class="headerlink" title="21.什么是spring的IOC  AOP"></a>21.什么是spring的IOC  AOP</h2><h2 id="22-STRUTS的工作流程！"><a href="#22-STRUTS的工作流程！" class="headerlink" title="22.STRUTS的工作流程！"></a>22.STRUTS的工作流程！</h2><h2 id="23-spring-与EJB的区别！！"><a href="#23-spring-与EJB的区别！！" class="headerlink" title="23.spring 与EJB的区别！！"></a>23.spring 与EJB的区别！！</h2>]]></content>
      
        
        <tags>
            
            <tag> Struts </tag>
            
            <tag> Hibernate </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
