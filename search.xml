<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <url>/Quartz%E4%B8%8Espring%E6%95%B4%E5%90%88%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="Quartz与spring整合实现方式"><a href="#Quartz与spring整合实现方式" class="headerlink" title="Quartz与spring整合实现方式"></a>Quartz与spring整合实现方式</h1><hr>
<p>title: Quartz与spring整合实现方式<br>date: 2016-09-01 11:23:55</p>
<h2 id="tags-Quartz"><a href="#tags-Quartz" class="headerlink" title="tags: [Quartz]"></a>tags: [Quartz]</h2><h2 id="Maven的pom-xml的配置："><a href="#Maven的pom-xml的配置：" class="headerlink" title="Maven的pom.xml的配置："></a>Maven的pom.xml的配置：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;  </span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  </span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;groupId&gt;QtzTest&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;QtzTest&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;properties&gt;  </span><br><span class="line">        &lt;springframework.version&gt;3.0.5.RELEASE&lt;/springframework.version&gt;  </span><br><span class="line">    &lt;/properties&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;dependencies&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;quartz&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.8.5&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">    &lt;/dependencies&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;build&gt;  </span><br><span class="line">        &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt;  </span><br><span class="line">        &lt;plugins&gt;  </span><br><span class="line">            &lt;plugin&gt;  </span><br><span class="line">                &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;  </span><br><span class="line">                &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;  </span><br><span class="line">                &lt;version&gt;7.5.4.v20111024&lt;/version&gt;  </span><br><span class="line">                &lt;configuration&gt;  </span><br><span class="line">                    &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;  </span><br><span class="line">                    &lt;webApp&gt;  </span><br><span class="line">                        &lt;contextPath&gt;/$&#123;project.artifactId&#125;&lt;/contextPath&gt;  </span><br><span class="line">                    &lt;/webApp&gt;  </span><br><span class="line">                &lt;/configuration&gt;  </span><br><span class="line">            &lt;/plugin&gt;  </span><br><span class="line">        &lt;/plugins&gt;  </span><br><span class="line">    &lt;/build&gt;  </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p><strong>特别注意一点，与Spring3.1以下版本整合必须使用Quartz1，最初我拿2.1.3的，怎么搞都报错：</strong><br>Caused by: org.springframework.beans.factory.CannotLoadBeanClassException: Error loading class [org.springframework.scheduling.quartz.CronTriggerBean] for bean with name ‘mytrigger’ defined in class path resource [applicationContext.xml]: problem with class file or dependent class; nested exception is java.lang.IncompatibleClassChangeError: class org.springframework.scheduling.quartz.CronTriggerBean has interface org.quartz.CronTrigger as super class </p>
<p>在Spring中使用Quartz有两种方式实现：<strong>第一种是任务类继承QuartzJobBean</strong>，<strong>第二种则是在配置文件里定义任务类和要执行的方法，类和方法仍然是普通类。很显然，第二种方式远比第一种方式来的灵活。</strong> </p>
<h2 id="第一种方式的JAVA代码-继承QuartzJobBean"><a href="#第一种方式的JAVA代码-继承QuartzJobBean" class="headerlink" title="第一种方式的JAVA代码(继承QuartzJobBean)"></a>第一种方式的JAVA代码(继承QuartzJobBean)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.ncs.hj;  </span><br><span class="line">  </span><br><span class="line">import org.quartz.JobExecutionContext;  </span><br><span class="line">import org.quartz.JobExecutionException;  </span><br><span class="line">import org.springframework.scheduling.quartz.QuartzJobBean;  </span><br><span class="line">  </span><br><span class="line">public class SpringQtz extends QuartzJobBean&#123;  </span><br><span class="line">    private static int counter = 0;  </span><br><span class="line">    protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123;  </span><br><span class="line">        System.out.println();  </span><br><span class="line">        long ms = System.currentTimeMillis();  </span><br><span class="line">        System.out.println(&quot;\t\t&quot; + new Date(ms));  </span><br><span class="line">        System.out.println(ms);  </span><br><span class="line">        System.out.println(&quot;(&quot; + counter++ + &quot;)&quot;);  </span><br><span class="line">        String s = (String) context.getMergedJobDataMap().get(&quot;service&quot;);  </span><br><span class="line">        System.out.println(s);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二种方式的JAVA代码-普通类更加灵活"><a href="#第二种方式的JAVA代码-普通类更加灵活" class="headerlink" title="第二种方式的JAVA代码(普通类更加灵活)"></a>第二种方式的JAVA代码(普通类更加灵活)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.ncs.hj;  </span><br><span class="line">  </span><br><span class="line">import org.quartz.JobExecutionContext;  </span><br><span class="line">import org.quartz.JobExecutionException;  </span><br><span class="line">import org.springframework.scheduling.quartz.QuartzJobBean;  </span><br><span class="line">  </span><br><span class="line">import java.util.Date;  </span><br><span class="line">  </span><br><span class="line">public class SpringQtz &#123;  </span><br><span class="line">    private static int counter = 0;  </span><br><span class="line">    protected void execute()  &#123;  </span><br><span class="line">        long ms = System.currentTimeMillis();  </span><br><span class="line">        System.out.println(&quot;\t\t&quot; + new Date(ms));  </span><br><span class="line">        System.out.println(&quot;(&quot; + counter++ + &quot;)&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring的配置文件："><a href="#Spring的配置文件：" class="headerlink" title="Spring的配置文件："></a>Spring的配置文件：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!------------ 配置调度程序quartz ，其中配置JobDetail有两种方式--------------&gt;    </span><br><span class="line">    &lt;!--方式一：使用JobDetailBean，任务类必须实现Job接口 --&gt;     </span><br><span class="line">    &lt;bean id=&quot;myjob&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailBean&quot;&gt;    </span><br><span class="line">     &lt;property name=&quot;name&quot; value=&quot;exampleJob&quot;&gt;&lt;/property&gt;    </span><br><span class="line">     &lt;property name=&quot;jobClass&quot; value=&quot;com.ncs.hj.SpringQtz&quot;&gt;&lt;/property&gt;   </span><br><span class="line">     &lt;property name=&quot;jobDataAsMap&quot;&gt;  </span><br><span class="line">&lt;map&gt;  </span><br><span class="line">    &lt;entry key=&quot;service&quot;&gt;&lt;value&gt;simple is the beat&lt;/value&gt;&lt;/entry&gt;  </span><br><span class="line">&lt;/map&gt;  </span><br><span class="line">;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;   </span><br><span class="line">    &lt;!--运行时请将方式一注释掉！ --&gt;    </span><br><span class="line">    &lt;!-- 方式二：使用MethodInvokingJobDetailFactoryBean，任务类可以不实现Job接口，通过targetMethod指定调用方法--&gt;    </span><br><span class="line">    &lt;!-- 定义目标bean和bean中的方法 --&gt;  </span><br><span class="line">    &lt;bean id=&quot;SpringQtzJob&quot; class=&quot;com.ncs.hj.SpringQtz&quot;/&gt;  </span><br><span class="line">    &lt;bean id=&quot;SpringQtzJobMethod&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;  </span><br><span class="line">    &lt;property name=&quot;targetObject&quot;&gt;  </span><br><span class="line">        &lt;ref bean=&quot;SpringQtzJob&quot;/&gt;  </span><br><span class="line">    &lt;/property&gt;  </span><br><span class="line">    &lt;property name=&quot;targetMethod&quot;&gt;  &lt;!-- 要执行的方法名称 --&gt;  </span><br><span class="line">        &lt;value&gt;execute&lt;/value&gt;  </span><br><span class="line">    &lt;/property&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- ======================== 调度触发器 ======================== --&gt;  </span><br><span class="line">&lt;bean id=&quot;CronTriggerBean&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt;  </span><br><span class="line">    &lt;property name=&quot;jobDetail&quot; ref=&quot;SpringQtzJobMethod&quot;&gt;&lt;/property&gt;  </span><br><span class="line">    &lt;property name=&quot;cronExpression&quot; value=&quot;0/5 * * * * ?&quot;&gt;&lt;/property&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- ======================== 调度工厂 ======================== --&gt;  </span><br><span class="line">&lt;bean id=&quot;SpringJobSchedulerFactoryBean&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;  </span><br><span class="line">    &lt;property name=&quot;triggers&quot;&gt;  </span><br><span class="line">        &lt;list&gt;  </span><br><span class="line">            &lt;ref bean=&quot;CronTriggerBean&quot;/&gt;  </span><br><span class="line">        &lt;/list&gt;  </span><br><span class="line">    &lt;/property&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JSP技术]]></title>
      <url>/JSP%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#javaweb入门笔记6-jsp技术">javaweb入门笔记(6)-JSP技术</a><ul>
<li><a href="#调用和运行原理">调用和运行原理</a></li>
<li><a href="#jsp语法">JSP语法</a></li>
<li><a href="#九大隐式对象">九大隐式对象</a><ul>
<li><a href="#out隐式对象">out隐式对象</a></li>
<li><a href="#pagecontext对象">pageContext对象</a></li>
</ul>
</li>
<li><a href="#jsp映射和查错">jsp映射和查错</a></li>
<li><a href="#jsp与javabean">jsp与JavaBean</a></li>
</ul>
</li>
</ul>
<hr>
<p>JSP：Java Server Pages，一种动态web资源的开发技术</p>
<p>API文档</p>
<blockquote>
<p><a href="https://tomcat.apache.org/tomcat-8.0-doc/jspapi/index.html" target="_blank" rel="external">JSP 2.3 API - Apache Tomcat 8.0.30</a></p>
</blockquote>
<h2 id="调用和运行原理"><a href="#调用和运行原理" class="headerlink" title="调用和运行原理"></a>调用和运行原理</h2><p>JSP本质是一个servlet.</p>
<p>每个JSP页面在第一次被访问时，WEB容器会把请求交给JSP引擎(即一个JAVA程序)处理。JSP引擎先将JSP翻译成一个<code>_jspServlet</code>(实质也是一个servlet)，然后按照servlet的调用方式进行调用。</p>
<ul>
<li>服务器会将jsp先翻译成servlet，这个servlet位于tomcat服务器<code>work</code>目录，这jsp类的父类是<code>org.apache.jasper.runtime.HttpJspBase</code>,这个<code>HttpJspBase</code>类继承自<code>HttpServlet</code></li>
<li>向服务器发请求会调用servlet的service方法;同样地，访问jsp会调用这个JSP类的<code>_jspService</code>方法。</li>
<li>JSP中的标签语言会在<code>_jspService</code>方法中通过<code>out.write()</code>写出来；JSP中的Java代码会原封不动的搬到<code>_jspService</code>方法中。</li>
<li>在<code>_jspService</code>方法中提前准备好了一些对象供JSP调用，如：<code>out,page,application,request,response</code>等等。</li>
<li>由于第一次访问时会翻译成servlet，所以第一次访问较慢。</li>
</ul>
<p>下面以<code>demo1.jsp</code>为例，展示对应的类<code>%CATALINA_HOME%\work\Catalina\localhost\hello\org\apache\jsp\demo1_jsp.java</code>中的部分代码</p>
<p>示例1:<code>demo1.jsp</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Date"</span> %&gt;&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Administrator</span><br><span class="line">  Date: <span class="number">2016</span>/<span class="number">1</span>/<span class="number">27</span></span><br><span class="line">  Time: <span class="number">16</span>:<span class="number">45</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;demo1&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">当前时间时：</span><br><span class="line">&lt;%</span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    out.write(date.toGMTString());</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>示例2：<code>_jspService</code>方法中代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;html&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;head&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"    &lt;title&gt;demo1&lt;/title&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;/head&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;body&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"当前时间时：\r\n"</span>);</span><br><span class="line"></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">out.write(date.toGMTString());</span><br><span class="line"></span><br><span class="line">out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;/body&gt;\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;/html&gt;\r\n"</span>);</span><br></pre></td></tr></table></figure>
<p>示例3:<code>_jspService</code>方法中一些定义的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;</span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletContext application;</span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletConfig config;</span><br><span class="line">javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">final</span> java.lang.Object page = <span class="keyword">this</span>;</span><br><span class="line">javax.servlet.jsp.JspWriter _jspx_out = <span class="keyword">null</span>;</span><br><span class="line">javax.servlet.jsp.PageContext _jspx_page_context = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a>JSP语法</h2><ul>
<li><strong>JSP模板元素</strong>:JSP页面中的HTML内容。定义了网页的基本骨架，即结构和外观。</li>
<li><strong>JSP表达式</strong>:用于将程序数据输出到客户端。如，<code>&lt;%=变量或表达式 %&gt;</code>脚本表达式(无分号)，用于输出数据。</li>
<li><strong>JSP脚本片段</strong>:用于在JSP页面中编写多行java代码,严格遵循java语法。一个JSP页面可有多个脚本片段，它们可以相互访问(和放在一对<code>&lt;% %&gt;</code>中一样),单个片段可不完整。</li>
<li><strong>JSP声明</strong>:JSP中代码默认翻译到servlet的service方法中，而JSP声明中的代码被翻译到<code>_jspService</code>方法外。语法：<code>&lt;%! java代码 %&gt;</code>。</li>
<li><strong>JSP注释</strong>:格式<code>&lt;%-- 注释  --%&gt;</code>，注释的内容不会发给浏览器。</li>
<li><strong>JSP指令</strong>:是为JSP引擎设计的，定义了三个指令:page指令，include指令，taglib指令。语法:<code>&lt;%@ 指令 属性名=&quot;值&quot; %&gt;</code>。<ul>
<li>page指令:定义各种属性，作用于整个JSP页面。</li>
<li>include指令:用于包含JSP文件(页头、页脚)。属于静态包含(编译时包含)，它包含的所有JSP会编译成一个servlet。</li>
<li>taglib指令:用于在JSP页面导入标签库。</li>
</ul>
</li>
<li><strong>JSP标签</strong>:也称为jsp Action元素，用于在jsp页面中提供业务逻辑功能，避免在jsp页面中直接写java代码而难以维护</li>
<li><strong>JSP内置对象</strong>:九大隐式对象，<code>request,response,session,application,config,page,exception,out,pageContext</code></li>
</ul>
<hr>
<p>关于上述语法的一些说明</p>
<p>page指令语法：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page</span><br><span class="line">[ language=<span class="string">"java"</span> ]</span><br><span class="line">[ extends=<span class="string">"package.class"</span> ]</span><br><span class="line">[ <span class="keyword">import</span>=<span class="string">"&#123;package.class | package.*&#125;, ..."</span> ]</span><br><span class="line">[ session=<span class="string">"true | false"</span> ]</span><br><span class="line">[ buffer=<span class="string">"none | 8kb | sizekb"</span> ]</span><br><span class="line">[ autoFlush=<span class="string">"true | false"</span> ]</span><br><span class="line">[ isThreadSafe=<span class="string">"true | false"</span> ]</span><br><span class="line">[ info=<span class="string">"text"</span> ]</span><br><span class="line">[ errorPage=<span class="string">"relativeURL"</span> ]</span><br><span class="line">[ contentType=<span class="string">"mimeType [ ;charset=characterSet ]"</span> | <span class="string">"text/html ; charset=ISO-8859-1"</span> ]</span><br><span class="line">[ isErrorPage=<span class="string">"true | false"</span> ]</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>errorPage</code>:错误提示页面。也可在<code>web.xml</code>的<code>&lt;error-page&gt;</code>标签配置，异常处理页面。在page指令设置的优先级高于在<code>web.xml</code>配置。</li>
<li><code>pageEncoding</code>:JSP引擎以何种码表翻译JSP,该值需和JSP文件的保存编码一致，且若要在浏览器正确显示，还要和<code>contentType</code>一致。</li>
</ul>
<p>动态包含(运行时包含):<code>request.getRequestDispatcher(&quot;/public/head.jsp&quot;).include(request,response)</code>,涉及到的jsp会生成单独的servlet，即有多个servlet，在浏览器访问时包含。静态包含性能优于动态包含</p>
<p>JSP常用标签</p>
<ul>
<li><code>&lt;jsp:include&gt;</code>:pageContext.include(),动态包含</li>
<li><code>&lt;jsp:forward&gt;</code></li>
<li><code>&lt;jsp:param&gt;</code></li>
</ul>
<hr>
<h2 id="九大隐式对象"><a href="#九大隐式对象" class="headerlink" title="九大隐式对象"></a>九大隐式对象</h2><p>JSP引擎在调用JSP对应的<code>_jspServlet</code>时，会传递和创建9个web开发相关的对象供使用。后两者(<code>out</code>和<code>pageContext</code>)为JSP独有</p>
<ul>
<li>request</li>
<li>response</li>
<li>session</li>
<li>application</li>
<li>config</li>
<li>page</li>
<li>exception</li>
<li>out</li>
<li>pageContext</li>
</ul>
<h3 id="out隐式对象"><a href="#out隐式对象" class="headerlink" title="out隐式对象"></a>out隐式对象</h3><p><strong>out隐式对象</strong>:用于向客户端发送文本数据。通过调用<code>pageContext</code>对象的<code>getOut</code>方法返回，类型为<code>JspWriter</code>，作用和<code>ServletResponse.getWriter</code>返回的<code>PrintWriter</code>对象相似。</p>
<p><code>JspWriter</code>相当于自带缓存功能的<code>PrintWriter</code>,设置page指令的buffer属性课调整缓存大小。满足如下条件之一，out对象才调用<code>ServletResponse.getWriter</code>方法，并通过返回的<code>PrintWriter</code>对象将out对象的缓冲区的内容真正写入到servlet引擎提供的缓冲区中：</p>
<ul>
<li>设置page指令的buffer属性关闭的out对象的缓存功能</li>
<li>out对象的缓冲区已满</li>
<li>整个JSP页面结束</li>
</ul>
<p>例子：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    out.write(<span class="string">"out.write&lt;br/&gt;"</span>);</span><br><span class="line">	response.getWriter().write(<span class="string">"response.getWriter.write&lt;br/&gt;"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.getWriter.write</span><br><span class="line">out.write</span><br></pre></td></tr></table></figure>
<p>可见，由于out有缓冲，所以后显示。</p>
<h3 id="pageContext对象"><a href="#pageContext对象" class="headerlink" title="pageContext对象"></a>pageContext对象</h3><p><strong>pageContext对象</strong>:是JSP技术中最重要的一个对象，它代表JSP页面的运行环境</p>
<ul>
<li>封装了对其他8大隐式对象的引用(主要用于自定义标签开发)</li>
<li>自身是一个域对象，可用来保存数据(page域存的东西只能在页面范围内拿得出来)</li>
<li>封装了web开发中的一些常用操作(提供管理所有域的入口)，如：引入和跳转其他资源、检索其他域对象中的属性等</li>
</ul>
<p>Class PageContext的API文档</p>
<blockquote>
<p><a href="https://tomcat.apache.org/tomcat-8.0-doc/jspapi/index.html?javax/servlet/jsp/PageContext.html" target="_blank" rel="external">javax.servlet.jsp:Class PageContext</a></p>
</blockquote>
<p>javaweb中的四个域:</p>
<ul>
<li>application域:应用程序范围,servletContext,对应的常量<code>PageContext.APPLICATION_SCOPE</code></li>
<li>session域:会话范围,session,对应的常量<code>PageContext.SESSION_SCOPE</code></li>
<li>resquet域:请求范围,request,对应的常量<code>PageContext.REQUEST_SCOPE</code></li>
<li>page域:页面范围,pageContext,对应的常量<code>PageContext.PAGE_SCOPE</code></li>
</ul>
<p><strong><code>findAttribute(java.lang.String name)</code></strong>查找各个域中的属性，是<code>PageContext</code>从父类<code>javax.servlet.jsp.JspContext</code>继承的，实现了父类的抽象方法。会<strong>依次</strong>从<code>page,request,session,application</code>域中寻找相应的属性，找到为止。</p>
<h2 id="jsp映射和查错"><a href="#jsp映射和查错" class="headerlink" title="jsp映射和查错"></a>jsp映射和查错</h2><p>jsp映射</p>
<p>在<code>webxml</code>的<code>&lt;servlet&gt;</code>标签中加<code>&lt;jsp-file&gt;</code>标签，其他的和servlet映射一样</p>
<p>查找jsp页面中的错误</p>
<ul>
<li>JSP页面中的语法格式有问题，导致不能翻译成servlet源文件，JSP引擎将提示这类错误在JSP页面中的位置以及相关信息</li>
<li>JSP页面中的语法格式没有问题，但翻译承德servlet源文件出现java语法问题导致源文件编译不通过，JSP引擎将提示这类错误在JSP页面中的位置以及相关信息</li>
<li>JSP页面翻译成的servlet程序运行时出现异常，这和普通java程序运行时错误完全一样，java虚拟机将提示错误在servlet源文件中的位置以及相关信息</li>
</ul>
<h2 id="jsp与JavaBean"><a href="#jsp与JavaBean" class="headerlink" title="jsp与JavaBean"></a>jsp与JavaBean</h2><p>JavaBean是一个遵循特定写法的java类，JavaBean常用于封装数据，具有如下热点：</p>
<ul>
<li>该java类必须有一个无参的构造函数</li>
<li>属性必须私有化</li>
<li>私有化的属性必须通过public类型的方法暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。</li>
</ul>
<p>JSP中提供了三个关于JavaBean的标签：</p>
<ul>
<li><code>&lt;jsp:useBean&gt;</code>:用于在JSP页面中查找或实例化一个JavaBean组件</li>
<li><code>&lt;jsp:setProperty&gt;</code>:用于在JSP页面中设置一个JavaBean组件的属性</li>
<li><code>&lt;jsp:getProperty&gt;</code>:用于在JSP页面中获取一个JavaBean组件的属性</li>
</ul>
<p>一些细节</p>
<ul>
<li><code>&lt;jsp:useBean&gt;</code>标签的标签体只在实例化bean时才执行</li>
<li><code>&lt;jsp:setProperty&gt;</code>可用请求参数给bean属性赋值，支持8种基本数据类型的转换(把客户机提交的字符串转成相应的8种基本类型赋到bean的属性上)</li>
<li>在标签中将<code>property=&quot;*&quot;</code>，用所有请求参数为bean赋值，请求参数名称和bean属性名称必须要一致</li>
<li>如果JavaBean实例对象的某个属性值为null,那么使用<code>&lt;jsp:getProperty&gt;</code>标签输出结果为<strong>“null”字符串</strong></li>
</ul>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> web </tag>
            
            <tag> cookie </tag>
            
            <tag> JSP技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cookie和session]]></title>
      <url>/cookie%E5%92%8Csession/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#javaweb入门笔记5-cookie和session">javaweb入门笔记(5)-cookie和session</a><ul>
<li><a href="#cookie">cookie</a></li>
<li><a href="#session">session</a><ul>
<li><a href="#实现原理">实现原理</a></li>
<li><a href="#应用案例">应用案例</a></li>
</ul>
</li>
<li><a href="#三个域对象">三个域对象</a></li>
</ul>
</li>
</ul>
<hr>
<p>Cookie是客户端技术；Session是服务器端技术。</p>
<p>API:</p>
<blockquote>
<ul>
<li><a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html?javax/servlet/http/Cookie.html" target="_blank" rel="external">javax.servlet.http:Class Cookie</a></li>
<li><a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html?javax/servlet/http/HttpSession.html" target="_blank" rel="external">javax.servlet.http:Interface HttpSession</a></li>
</ul>
</blockquote>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>一些细节：</p>
<ul>
<li>一个cookie只能标识一种信息，至少含有标识该信息的名称和值</li>
<li>浏览器一般只允许存放300个cookie，每个站点最多存放20个，每个cookie大小限制为4KB</li>
<li>默认是会话级别cookie(存储于浏览器内存)，浏览器进程关闭则删除。有效期通过<code>maxAge</code>设置，存于硬盘，0表示删除</li>
<li>删除cookie时，path必须一致，否则不会删除</li>
</ul>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session对象由服务器创建,一个浏览器(会话)独占一个session对象</p>
<p>session对象由服务器创建生命周期</p>
<ul>
<li>创建：调用<code>request</code>对象的<code>getSession</code>方法后才会创建session对象;<code>getSession(false)</code>只获取， 不创建</li>
<li>销毁：默认30分钟没人使用则自动销毁。失效时间可在<code>web.xml</code>的<code>&lt;session-config&gt;</code>标签中使用<code>&lt;session-timeout&gt;</code>，单位分钟；也可调用<code>session</code>对象的<code>invalidate</code>方法销毁</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>session基于cookie实现，将<code>JSESSIONID</code>写回浏览器，这个cookie(<code>JSESSIONID</code>)默认没设置有效期,关浏览器即销毁。可以自行回写<code>JSESSIONID</code>覆盖原cookie值</p>
<p>示例代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    HttpSession session = req.getSession();</span><br><span class="line">    String sessionid = session.getId();</span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>,sessionid);</span><br><span class="line">    cookie.setPath(<span class="string">"/s1"</span>);</span><br><span class="line">    cookie.setMaxAge(<span class="number">30</span>*<span class="number">60</span>);</span><br><span class="line">    resp.addCookie(cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><ul>
<li>用户登录</li>
<li>防止表单重复提交</li>
<li>一次性验证码的校验</li>
</ul>
<p><strong>小Tips</strong></p>
<ul>
<li>一般大型网站不用session,使用cookie,减小服务器压力</li>
<li>若浏览器禁用cookie,需使用url自带sessionid，相关方法:<code>encodeURL</code>和<code>encodeRedirectURL</code></li>
<li>禁止表单重复提交：在javascript或者服务器实现。javascript防不死，用户可通过修改js、自建表单提交，刷新页面，后退等方法重复提交；服务器实现是给每个表单一个随机表单号</li>
<li>生成表单号使用“令牌发生器”，为保证唯一性(减小重复概率)，使用单例。</li>
<li>base64编码，三字节变四字节，每6位变8位(一字节)，高位补零，每字节最大值为63，故得名。</li>
<li>md5，常用于保存密码(可能为防止破解会加随机数)，校验数据完整性</li>
</ul>
<p>防止表单重复提交之令牌例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.iot.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Encoder;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/1/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenProcessor</span> </span>&#123;<span class="comment">//令牌</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.构造方法私有</span></span><br><span class="line"><span class="comment">     * 2.自己创建一个</span></span><br><span class="line"><span class="comment">     * 3.对外暴露一个方法，允许获取上面创建的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TokenProcessor</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> TokenProcessor instance = <span class="keyword">new</span> TokenProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TokenProcessor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">genetateToken</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String token = System.currentTimeMillis()+<span class="keyword">new</span> Random().nextInt()+<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest md =  MessageDigest.getInstance(<span class="string">"md5"</span>);</span><br><span class="line">            <span class="keyword">byte</span> [] md5 =  md.digest(token.getBytes());</span><br><span class="line">            <span class="comment">//base64编码</span></span><br><span class="line">            BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">            <span class="keyword">return</span> encoder.encode(md5);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三个域对象"><a href="#三个域对象" class="headerlink" title="三个域对象"></a>三个域对象</h2><ul>
<li>Session</li>
<li>Request</li>
<li>ServletContext</li>
</ul>
<p>容器选用经验：</p>
<ul>
<li>数据显示完了就没用了，则选用Request</li>
<li>数据除了显示外，稍后还会用，则选用Session</li>
<li>数据除了显示外，不仅稍后会用，还会给别人用，则选用<code>ServletContext</code></li>
</ul>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> web </tag>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[request和response]]></title>
      <url>/request%E5%92%8Cresponse/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#javaweb入门笔记4-request和response">javaweb入门笔记(4)-request和response</a><ul>
<li><a href="#response">response</a><ul>
<li><a href="#输出数据">输出数据</a></li>
<li><a href="#文件下载">文件下载</a></li>
<li><a href="#随机图片">随机图片</a></li>
<li><a href="#刷新和缓存">刷新和缓存</a></li>
<li><a href="#请求重定向">请求重定向</a></li>
</ul>
</li>
<li><a href="#request">request</a><ul>
<li><a href="#中文乱码">中文乱码</a></li>
<li><a href="#请求转发">请求转发</a></li>
<li><a href="#地址的写法">地址的写法</a></li>
<li><a href="#防盗链">防盗链</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>API:</p>
<blockquote>
<ul>
<li><a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html?javax/servlet/http/HttpServletResponse.html" target="_blank" rel="external">Interface HttpServletResponse</a></li>
<li><a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html?javax/servlet/http/HttpServletRequest.html" target="_blank" rel="external">Interface HttpServletRequest</a></li>
</ul>
</blockquote>
<h2 id="response"><a href="#response" class="headerlink" title="response"></a>response</h2><h3 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h3><p>程序以什么码表输出，就一定要控制浏览器以什么码表打开。可有如下两种写法：</p>
<ul>
<li><code>response.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=UTF-8&quot;)</code></li>
<li><code>response.setContentType(&quot;text/html;charset=UTF-8&quot;)</code>(默认调用<code>setHeader</code>和<code>setCharacterEncoding</code>)</li>
</ul>
<p>把分号<code>;</code>错写成逗号<code>,</code>，浏览器会提示下载</p>
<p>用html技术的<code>&lt;meta&gt;</code>标签可以模拟一个http响应头，<code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;</code></p>
<p>response可用<code>setCharacterEncoding</code>方法设置码表。字符流输出：<code>PrintWritet-&gt;response-&gt;浏览器</code>,<code>response-&gt;浏览器</code>默认使用<code>iso-8859</code>编码</p>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>使用<code>ServerContext</code>的<code>getRealPath</code>方法,再<code>InputStream</code>和<code>OutputStream</code></p>
<p>如果下载文件是中文名为中文，则文件名需要经过url编码<code>URLEncoder.encode</code></p>
<h3 id="随机图片"><a href="#随机图片" class="headerlink" title="随机图片"></a>随机图片</h3><p>使用<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/awt/image/BufferedImage.html" target="_blank" rel="external"><code>BufferedImage</code></a>在内存生成图片，再使用<a href="https://docs.oracle.com/javase/8/docs/api/index.html?javax/imageio/ImageIO.html" target="_blank" rel="external"><code>ImageIO</code></a>输出。</p>
<p>画图使用<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/awt/Graphics.html" target="_blank" rel="external"><code>Graphics</code></a>,旋转使用<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/awt/Graphics2D.html" target="_blank" rel="external"><code>Graphics2D</code></a></p>
<p>汉字的区间：<code>\u4e00</code>-<code>\u9fa5</code></p>
<h3 id="刷新和缓存"><a href="#刷新和缓存" class="headerlink" title="刷新和缓存"></a>刷新和缓存</h3><ul>
<li>刷新：一般不在servlet里加<code>refresh</code>头，而是在jsp加入<code>&lt;meta&gt;</code>头模拟。</li>
<li>缓存：加入<code>expires</code>头,当前时间+要缓存的时长</li>
</ul>
<h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p><strong>重定向</strong>：设置状态码和<code>location</code>头即可，或者直接使用<code>response</code>的<code>sendRedirect</code>方法。向服务器两次请求。浏览器会改变地址栏，一般适用于登录、购物等场景。</p>
<p><strong>转发</strong>:则是调用<code>ServletContex</code>对象的<code>getRequestDispatcher</code>方法，再调用<code>forward</code>方法。向服务器一次请求，浏览器地址栏不变。</p>
<p>一些细节：</p>
<ul>
<li><code>getOutputStream</code>和<code>getWriter</code>方法跟别用于输出二进制数据、输出文本数据的<code>ServletOutputStream</code>、<code>Printwriter</code>对象，这两个方法相互排斥，只能调用其中一个，否则抛<code>IllegalStateException</code>异常。</li>
<li>response的输出流会自己关闭。<code>Servlet</code>的<code>service</code>方法结束后，Servlet引擎会检查并调用<code>close</code>方法关闭该输出流对象。</li>
</ul>
<h2 id="request"><a href="#request" class="headerlink" title="request"></a>request</h2><ul>
<li>URI:标识某个资源</li>
<li>URL:标识互联网上某个资源</li>
</ul>
<p>一些方法</p>
<ul>
<li><code>getRequestURI</code>用于权限拦截，访问统计</li>
<li><code>getRemoteAddr</code>用于得到客户机IP地址</li>
<li><code>getMethod</code>得到客户机请求方式</li>
</ul>
<p>requst对象获取数据的四种方式</p>
<ul>
<li><code>getParameter</code></li>
<li><code>getParameterNames</code></li>
<li><code>getParameterValues</code></li>
<li><code>getParameterMap</code>(可结合JavaBean使用)</li>
</ul>
<p>(<code>getInputStream</code>用于文件上传)</p>
<h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p>url后面如果有中文数据，需要编码后再提交</p>
<p>表单提交的数据使用的码表和该页面的码表一致，而<code>getParameter</code>方法默认使用<code>ISO-8859</code>码表。</p>
<p>解决：</p>
<ul>
<li>对于post提交的数据，在获取数据前要使用<code>request</code>对象的<code>setCharacterEncoding</code>设置码表。</li>
<li>对于get提交的数据，只能手工解决。先对数据调用<code>getBytes(&quot;ISO-8859-1&quot;)</code>获取二进制字节，再用特定码表构建字符串。</li>
<li>超链提交的中文，解决办法同get提交的数据。</li>
</ul>
<p><em>也可以通过改服务器配置来解决乱码问题，但一般<strong>不建议</strong>使用。</em></p>
<ul>
<li><code>URIEncoding</code>:改tomcat的配置文件<code>conf/server.xml</code>的连接器<code>&lt;Connector&gt;</code>中的<code>URIEncoding</code>属性</li>
<li><code>useBodyEncodingForURI</code>:将<code>conf/server.xml</code>的连接器<code>&lt;Connector&gt;</code>中的<code>useBodyEncodingForURI</code>置为<code>true</code></li>
</ul>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p>应用场景：MVC设计模式</p>
<ul>
<li>model : javabean;</li>
<li>view : jsp;</li>
<li>controller : servlet</li>
</ul>
<p>使用request域对象把数据带给转发资源。调用<code>request</code>对象的<code>getRequestDispatcher</code>方法，再调用<code>forward</code>方法。一次请求，浏览器地址栏不变。</p>
<p><code>forward</code>一些细节</p>
<ul>
<li>不能在关闭输出流后再调用转发，也不能调用两次，否则会抛出异常。</li>
<li>跳转之前会清空response中的数据。即数据只是写入到缓冲区而没真正输出到客户端，则可调用<code>forward</code>方法，原来写入到缓冲区的内容被清空，但响应头字段信息保持。</li>
</ul>
<p><code>include</code>方法可以用于包含一些公共页面(一般不在servlet中包含)</p>
<h3 id="地址的写法"><a href="#地址的写法" class="headerlink" title="地址的写法"></a>地址的写法</h3><p>以斜杠<code>/</code>开头。如果是给服务器用，则<code>/</code>代表当前web应用；如果给浏览器用，则<code>/</code>代表网站。 </p>
<p>例子:目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mail---------------------------Web应用所在目录</span><br><span class="line">           |----form1.html</span><br><span class="line">           |----WEB-INF目录</span><br><span class="line">                    |---------classes目录</span><br><span class="line">                    |---------lib目录</span><br><span class="line">                    |---------web.xml</span><br></pre></td></tr></table></figure>
<ol>
<li><code>request.getRequestDispatcher(&quot;/form1.html&quot;)</code></li>
<li><code>response.sendRedirect(&quot;mail/form1.html&quot;)</code></li>
<li><code>this.getServletContext().getRealPath(&quot;/form1.html&quot;)</code></li>
<li><code>this.getServletContext().getResourceAsStream(&quot;/form1.html&quot;)</code></li>
<li><code>&lt;a href=&quot;/mail/form1.html&quot;&gt;</code></li>
<li><code>&lt;form action=&quot;/mail/form1.html&quot;&gt;</code></li>
</ol>
<p>其中，1,3,4是给服务器用;2,5,6是浏览器用 </p>
<h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>读取<code>referer</code>请求头，不合要求则重定向。</p>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> web </tag>
            
            <tag> response </tag>
            
            <tag> request </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Servlet]]></title>
      <url>/Servlet/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#javaweb入门笔记3-servlet">javaweb入门笔记(3)-Servlet</a><ul>
<li><a href="#servlet入门">servlet入门</a></li>
<li><a href="#手动编写第一个servlet">手动编写第一个servlet</a></li>
<li><a href="#servlet的调用过程和生命周期">servlet的调用过程和生命周期</a></li>
<li><a href="#servlet开发的一些细节">servlet开发的一些细节</a></li>
<li><a href="#servletcontext">ServletContext</a></li>
<li><a href="#参考链接">参考链接</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="servlet入门"><a href="#servlet入门" class="headerlink" title="servlet入门"></a>servlet入门</h2><p>开发步骤：</p>
<ul>
<li>编写一个java类，实现servlet接口</li>
<li>把开发好的java类部署到web服务器</li>
</ul>
<p>API文档</p>
<blockquote>
<p><a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html" target="_blank" rel="external">Servlet API Documentation</a></p>
</blockquote>
<p>生命周期相关方法(life-cycle methods)</p>
<p>Servlet的生命周期通过<code>java.servlet.Servlet</code>接口中的<code>init()</code>、<code>service()</code>、和<code>destroy()</code>方法表示。Servlet的生命周期有四个阶段：加载并实例化、初始化、请求处理、销毁。（见文末【参考链接】）</p>
<h2 id="手动编写第一个servlet"><a href="#手动编写第一个servlet" class="headerlink" title="手动编写第一个servlet"></a>手动编写第一个servlet</h2><p>1.在tomcat中新建一个web应用<code>hello</code>，在web应用中新建一个<code>WEB-INF/classes</code>目录</p>
<p>2.在<code>classes</code>目录新建一个<code>FirstServlet</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.iot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req,ServletResponse res)</span><span class="keyword">throws</span> ServletException,java.io.IOException</span>&#123;</span><br><span class="line">		OutputStream out = res.getOutputStream();</span><br><span class="line">		out.write(<span class="string">"hello servlet!!!"</span>.getBytes());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.编译，<code>javac -cp %CATALINA_HOME%/lib/servlet-api.jar  -d . FirstServlet.java</code>,命令行手动编译参考<a href="http://www.iitshare.com/under-the-cmd-compile-the-java.html" target="_blank" rel="external">这里</a></p>
<p>4.在<code>WEB-INF</code>目录中新建一个<code>web.xml</code>文件，配置servlet的对外访问路径</p>
<p>5.启动tomcat访问</p>
<h2 id="servlet的调用过程和生命周期"><a href="#servlet的调用过程和生命周期" class="headerlink" title="servlet的调用过程和生命周期"></a>servlet的调用过程和生命周期</h2><p>时序图</p>
<p><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaweb_servlet-lifecycle.png" alt="servlet的调用过程和生命周期"></p>
<h2 id="servlet开发的一些细节"><a href="#servlet开发的一些细节" class="headerlink" title="servlet开发的一些细节"></a>servlet开发的一些细节</h2><ul>
<li><strong>标签</strong>:<code>&lt;servlet&gt;</code>包含<code>&lt;servlet-name&gt;</code>和<code>&lt;servlet-class&gt;</code>；<code>&lt;servlet-mapping&gt;</code>包含<code>&lt;servlet-name&gt;</code>和<code>&lt;url-pattern&gt;</code></li>
<li><strong>映射</strong>:<code>web.xml</code>中一个<code>&lt;servlet&gt;</code>可对应多个<code>&lt;servlet-mapping&gt;</code></li>
<li><strong>通配符</strong>:<code>&lt;servlet-mapping&gt;</code>的<code>&lt;url-pattern&gt;</code>可以使用通配符，两种固定格式：<code>*.扩展名</code>；以<code>/</code>开头，以<code>/*</code>结尾</li>
</ul>
<p><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaweb_servlet-url%E5%8C%B9%E9%85%8D.png" alt="javaweb_servlet-url匹配.png"></p>
<ul>
<li><strong>对象</strong>:servlet由servlet引擎调用，不能独立运行。客户端多次请求，服务器只创建一个servlet实例，之后驻留内存中继续服务直至web容器退出才销毁它。</li>
<li><strong>请求</strong>:服务器针对客户端的每一次请求都会创建新的<code>request</code>和<code>response</code>对象(它们的生命周期很短)，传给<code>service</code>方法。</li>
<li><strong>加载</strong>:servlet实例的创建和<code>init</code>方法的调用是在第一次请求时，而非服务器启动时，除非在<code>&lt;servlet&gt;</code>标签配置<code>&lt;load-on-start-up&gt;</code>,数字越小优先级越高</li>
<li><strong>缺省</strong>:映射路径为正斜杠<code>/</code>，则为当前web应用的缺省servlet,不匹配的都交给缺省</li>
<li><strong>线程安全</strong>:访问同一资源会引发线程安全问题; <code>SingleThreadModel</code>标记接口(已弃用)</li>
<li><strong>ServletConfig</strong>:在<code>&lt;servlet&gt;</code>标签配置<code>&lt;init-param&gt;</code>，通过<code>getServletConfig</code>方法获得配置。可配置输出字符集，读哪个配置文件等等。</li>
<li><strong>ServletContext</strong>:代表当前web应用，含有一些web应用全局性方法，实现web资源共享、servlet转发等。通过<code>ServletConfig.getServletContext</code>方法获得，在<code>&lt;context-param&gt;</code>标签配置。</li>
</ul>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>API:<a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html?javax/servlet/ServletContext.html" target="_blank" rel="external">Interface ServletContext</a></p>
<p>概念</p>
<p>一个web应用所有servlet共享同一个ServletContext对象，可实现数据共享。ServletContext被称为context<strong>域</strong>对象。</p>
<p>域：作用范围；context域：整个应用程序范围。</p>
<p>ServletContext域：</p>
<ol>
<li>这是一个容器</li>
<li>说明了这个容器的作用范围，也就是应用程序范围</li>
</ol>
<p>转发:客户机一次请求；重定向：客户机两次请求</p>
<p>作用</p>
<ul>
<li>获取web应用的初始化参数</li>
<li>实现servlet转发</li>
<li>利用ServletContext对象读取资源文件<ul>
<li>获得文件路径</li>
<li>读取资源文件的三种方式</li>
<li>.properties文件（属性文件）</li>
</ul>
</li>
</ul>
<p>配置文件：properties文件和xml文件；数据有关系使用xml文件，没有关系则使用properties文件。</p>
<p>1.通过<code>ServletContext</code>的<code>getResourceAsStream</code>方法，读取properties文件</p>
<p>模板代码(注意文件位置不同写路径会不同)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">"/WEB-INF/classes/org/iot/servlet/db.properties"</span>);</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();<span class="comment">//map</span></span><br><span class="line">properties.load(in);</span><br></pre></td></tr></table></figure>
<p>2.通过<code>servletContext</code>的<code>getRealPath</code>方法得到资源的绝对路径，再通过传统方式(<code>FileInputStream</code>)读取</p>
<p>3.通过类装载器去读，<code>ClassLoader</code>的<code>getResourceAsStream</code>(如果读取资源文件的程序不是servlet)，文件不能太大。<strong>只装载一次</strong>，所以如要读到更新后的数据，通过类装载的方式得到资源文件的位置，再通过传统方式读取资源文件的数据（用<code>getResource</code>得到path，再用<code>FileInputStream</code>）</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a href="http://blog.csdn.net/evankaka/article/details/46673051" target="_blank" rel="external">servlet和Jsp生命周期解读</a></p>
</blockquote>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> web </tag>
            
            <tag> Servlet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http协议]]></title>
      <url>/http%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#javaweb入门笔记2-http入门">javaweb入门笔记(2)-http入门</a><ul>
<li><a href="#请求request">请求(Request)</a><ul>
<li><a href="#请求头字段">请求头字段</a></li>
</ul>
</li>
<li><a href="#响应response">响应(Response)</a><ul>
<li><a href="#响应状态行">响应状态行</a></li>
<li><a href="#响应头字段">响应头字段</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>对HTTP协议早有了解，最近在看javaweb，视频中讲到了这部分，就把视频的内容整理归纳下</p>
<h2 id="请求-Request"><a href="#请求-Request" class="headerlink" title="请求(Request)"></a>请求(Request)</h2><p>一个完整的HTTP请求包括：一个请求行、若干请求头、以及实体内容</p>
<h3 id="请求头字段"><a href="#请求头字段" class="headerlink" title="请求头字段"></a>请求头字段</h3><ul>
<li>Accept:用于告诉服务器，客户机支持的数据类型</li>
<li>Accept-Charset:用于告诉服务器，客户机采用的编码</li>
<li>Accept-Encoding:用于告诉服务器，客户机支持数据压缩格式</li>
<li>Accept-Language:客户机的语言环境</li>
<li>Host:客户机通过这个头告诉服务器，想访问的主机名</li>
<li>If-Modified-Since:客户机通过这个头告诉服务器，资源的缓存时间</li>
<li>Refer:客户机通过这个头告诉服务器，它是从哪个资源访问服务器的(防盗链)</li>
<li>User-Agent:客户机通过这个头告诉服务器，客户机的软件环境</li>
<li>Cookie:客户机通过这个头向服务器带数据</li>
<li>Connection:这个请求完了，是保持连接还是关闭</li>
<li>Range:断点下载<ul>
<li><code>bytes=n1-n2</code>,传输范围n1到n2字节</li>
<li><code>bytes=n-</code>，传输web资源中第n个字节以后的所有内容</li>
<li><code>bytes=n</code>,传输最后n个字节</li>
</ul>
</li>
</ul>
<h2 id="响应-Response"><a href="#响应-Response" class="headerlink" title="响应(Response)"></a>响应(Response)</h2><p>一个HTTP响应代表服务器向客户端回送的数据，包括：一个状态行、若干消息头、以及实体内容</p>
<h3 id="响应状态行"><a href="#响应状态行" class="headerlink" title="响应状态行"></a>响应状态行</h3><p><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaweb_HttpResponseStatus.png" alt="HTTP响应状态码简表"></p>
<p>详情可参考</p>
<blockquote>
<p><a href="http://www.w3school.com.cn/tags/html_ref_httpmessages.asp" target="_blank" rel="external">HTTP 状态消息</a></p>
</blockquote>
<h3 id="响应头字段"><a href="#响应头字段" class="headerlink" title="响应头字段"></a>响应头字段</h3><ul>
<li>Location:这个头配合302状态码使用，用于告诉客户机找谁(location和302实现请求重定向)</li>
<li>Server:服务器通过这个头，告诉浏览器服务器的类型</li>
<li>Content-Encoding:服务器通过这个头，数据的压缩格式<br>(相关java知识:<code>GZIPOutputStream</code>,包装流/底层流)</li>
<li>Content-Length:服务器通过这个头，告诉浏览器回送数据的长度</li>
<li>Content-Type:服务器通过这个头，告诉浏览器回送数据的类型</li>
<li>Last-Modified:服务器通过这个头，告诉浏览器当前资源的缓存时间</li>
<li>Refresh:服务器通过这个头，告诉浏览器隔多长时间刷新一次</li>
<li>Content-Disposition:服务器通过这个头，告诉浏览器以下载方式打开</li>
<li>Transfer-Encoding:服务器通过这个头，告诉浏览器数据的传送格式</li>
<li>Etag:缓存相关的头部，用于实时性要求高的系统</li>
<li>Expires:服务器通过这个头，告诉浏览器把回送的资源缓存多长时间，-1或0则不缓存</li>
<li>Cache-Control和Pragma:no-cache,服务器通过这两个头，也是控制浏览器不要缓存数据</li>
<li>Connection:断开连接/保持连接</li>
<li>Date:当前时间</li>
<li>Accept-Ranges:用来说明web服务器是否支持range。支持返回bytes;不支持返回none</li>
<li>Content-Range:制定了返回web资源的字节范围，格式：<code>n1-n2/n_total</code></li>
</ul>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> web </tag>
            
            <tag> http </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat]]></title>
      <url>/Tomcat/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#javaweb入门笔记1-tomcat">javaweb入门笔记(1)-Tomcat</a><ul>
<li><a href="#tomcat目录层次结构">Tomcat目录层次结构</a></li>
<li><a href="#启动tomcat">启动Tomcat</a></li>
<li><a href="#官当配置文档">官当配置文档</a></li>
<li><a href="#web应用">web应用</a></li>
<li><a href="#tomcat体系结构">Tomcat体系结构</a></li>
<li><a href="#相关小知识">相关小知识</a></li>
<li><a href="#参考链接">参考链接</a></li>
</ul>
</li>
</ul>
<hr>
<p>下载链接</p>
<blockquote>
<ul>
<li><a href="http://jakarta.apache.org" target="_blank" rel="external">Apache Jakarta Project</a></li>
<li><a href="http://tomcat.apache.org/" target="_blank" rel="external">Tomcat官网</a></li>
</ul>
</blockquote>
<h2 id="Tomcat目录层次结构"><a href="#Tomcat目录层次结构" class="headerlink" title="Tomcat目录层次结构"></a>Tomcat目录层次结构</h2><ul>
<li>bin:存放启动和关闭Tomcat的脚本文件</li>
<li>conf:存放Tomcat服务器的配置文件</li>
<li>lib:存放Tomcat服务器的支撑jar包</li>
<li>logs:存放Tomcat的日志文件</li>
<li>temp:存放Tomcat运行时产生的临时文件</li>
<li>webapps:web应用所在的目录，即供外接访问的web资源的存放目录</li>
<li>work:Tomcat的工作目录</li>
</ul>
<p>上面的内容直接可在<a href="http://tomcat.apache.org/tomcat-8.0-doc/introduction.html#Terminology" target="_blank" rel="external">Tomcat Doc-Directories and Files</a>找到答案</p>
<h2 id="启动Tomcat"><a href="#启动Tomcat" class="headerlink" title="启动Tomcat"></a>启动Tomcat</h2><p><code>%CATALINA_HOME%/RUNNING.txt</code>有详细步骤，简单来说，已经配置好JDK环境的话，windows下直接双击<code>bin/startyp.bat</code>就行了</p>
<p>默认端口是8080，改端口：tomcat的<code>conf/server.xml</code>的<code>Connector</code>标签</p>
<p>常见启动问题</p>
<ul>
<li>JAVA_HOME环境变量</li>
<li>端口占用问题</li>
<li>Catalina_home环境变量的设置问题</li>
</ul>
<h2 id="官当配置文档"><a href="#官当配置文档" class="headerlink" title="官当配置文档"></a>官当配置文档</h2><p>多种配置方式</p>
<ul>
<li><code>/META-INF/context.xml</code></li>
<li><code>$CATALINA_BASE/conf/[enginename]/[hostname]/</code></li>
<li><code>conf/server.xml</code></li>
</ul>
<blockquote>
<p>具体参考<a href="http://tomcat.apache.org/tomcat-8.0-doc/config/context.html#Defining_a_context" target="_blank" rel="external">Context配置</a></p>
</blockquote>
<h2 id="web应用"><a href="#web应用" class="headerlink" title="web应用"></a>web应用</h2><p>1.web应用与web应用所在的目录<br>一个<strong>web应用</strong>由多个静态web资源和动态web资源组成；组成web应用的这些文件会由一个目录组织起来，这个目录称为<strong>web应用所在目录</strong></p>
<p>2.虚拟目录的映射<br>把主机上的资源映射到服务器对外提供的访问路径上</p>
<p>3.例子</p>
<p>tomcat的<code>conf/server.xml</code>:<code>&lt;Host&gt;</code>元素-&gt;<code>&lt;Context&gt;</code>,一个<code>&lt;Context&gt;</code>对应一个web应用。</p>
<p><code>&lt;Context path=&quot;/virtual-path&quot; docBase=&quot;webapps-path&quot; /&gt;</code>,重启web服务器</p>
<p>4.web应用的组成结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mail---------------------------Web应用所在目录</span><br><span class="line">           |----html、jsp、css、js等文件，根目录下的文件外界可以直接访问</span><br><span class="line">           |----WEB-INF目录</span><br><span class="line">                    |---------classes目录(java类)</span><br><span class="line">                    |---------lib目录(java类运行所需的jar包)</span><br><span class="line">                    |---------web.xml(web应用的配置文件)</span><br><span class="line">             WEB-INF 这个目录下的文件外界无法直接访问，由web服务器负责调用</span><br></pre></td></tr></table></figure>
<h2 id="Tomcat体系结构"><a href="#Tomcat体系结构" class="headerlink" title="Tomcat体系结构"></a>Tomcat体系结构</h2><p><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaweb_tomcat%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="Tomcat体系结构"></p>
<ul>
<li>tomcat的https连接器</li>
</ul>
<p><code>keytool -genkey alias tomcat -keyalg RSA</code>得到<code>.keystore</code>文件</p>
<ul>
<li>Tomcat管理平台<br>主页-&gt;Tomcat Manager</li>
</ul>
<p>相关权限和用户配置在<code>conf/tomcat-users.xml</code></p>
<h2 id="相关小知识"><a href="#相关小知识" class="headerlink" title="相关小知识"></a>相关小知识</h2><p>1.域名和主机名的区别</p>
<table>
<thead>
<tr>
<th style="text-align:right">域名</th>
<th style="text-align:center">sina.com</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">主机名</td>
<td style="text-align:center">www.sina.com</td>
</tr>
</tbody>
</table>
<p>2.url中主机名的作用：</p>
<ul>
<li>用于访问DNS服务器获取IP</li>
<li>用于告诉代理服务器要访问哪个主机名</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a href="http://www.cnblogs.com/rocomp/p/4802396.html" target="_blank" rel="external">Tomcat安装、配置、优化及负载均衡详解
</a></p>
</blockquote>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> web </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Quartz入门详解]]></title>
      <url>/Quartz%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>##入门简介：</p>
<p>基本上任何公司都会用到调度这个功能， 比如我们公司需要<code>定期执行调度生成报表</code>， 或者比如博客什么的<code>定时更新</code>之类的，都可以靠Quartz来完成。正如官网所说，小到独立应用大到大型电子商务网站， Quartz都能胜任。</p>
<h2 id="Quartz体系结构："><a href="#Quartz体系结构：" class="headerlink" title="Quartz体系结构："></a>Quartz体系结构：</h2><p>明白Quartz怎么用，首先要了解<code>Scheduler</code>(调度器)、<code>Job</code>(任务)和<code>Trigger</code>(触发器)这3个核心的概念。</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>是<code>一个接口</code>，只定义一个方法<code>execute(JobExecutionContext context)</code>，在实现接口的execute方法中编写所需要定时执行的<code>Job(任务)</code>， JobExecutionContext类提供了调度应用的一些信息。Job运行时的信息保存在<code>JobDataMap</code>实例中；</p>
<h3 id="JobDetail"><a href="#JobDetail" class="headerlink" title="JobDetail"></a>JobDetail</h3><p>Quartz每次调度Job时， 都重新创建一个Job实例， 所以它不直接接受一个Job的实例，相反它接收一个Job实现类(<code>JobDetail</code>:描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息)，以便运行时通过newInstance()的反射机制实例化Job。</p>
<h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><p>是<code>一个类</code>，描述触发Job执行的时间触发规则。主要有<code>SimpleTrigger</code>和<code>CronTrigger</code>这两个子类。当且仅当需调度一次或者以固定时间间隔周期执行调度，SimpleTrigger是最适合的选择；而CronTrigger则可以通过<code>Cron表达式</code>定义出各种复杂时间规则的调度方案：如工作日周一到周五的15：00~16：00执行调度等；</p>
<p><strong>Cron表达式的格式</strong>：秒 分 时 日 月 周 年(可选)。<br>字段名                 允许的值                        允许的特殊字符<br>秒                         0-59                               ,  <code>– * /</code><br>分                         0-59                               , <code>– * /</code><br>小时                   0-23                                 , <code>– * /</code><br>日                         1-31                               ,<code>– * ? / L W C</code><br>月                         1-12 or JAN-DEC           , <code>– * /</code><br>周几                     1-7 or SUN-SAT             , <code>– * ? / L C #      MON  FRI</code><br>年 (可选字段)     empty, 1970-2099            ,<code>– * /</code></p>
<p>“?”字符：表示不确定的值<br>“,”字符：指定数个值<br>“-”字符：指定一个值的范围<br>“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m<br>“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X<br>“W”字符：指定离给定日期最近的工作日(周一到周五)<br>“#”字符：表示该月第几个周X。6#3表示该月第3个周五</p>
<p><strong>Cron表达式范例</strong>：<br>每隔5秒执行一次：<em>/5 </em> <em> </em> <em> ?<br>每隔1分钟执行一次：0 </em>/1 <em> </em> <em> ?<br>每天23点执行一次：0 0 23 </em> <em> ?<br>每天凌晨1点执行一次：0 0 1 </em> <em> ?<br>每月1号凌晨1点执行一次：0 0 1 1 </em> ?<br>每月最后一天23点执行一次：0 0 23 L <em> ?<br>每周星期天凌晨1点实行一次：0 0 1 ? </em> L<br>在26分、29分、33分执行一次：0 26,29,33 <em> </em> <em> ?<br>每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 </em> * ?</p>
<p> <strong>Calendar：org.quartz.Calendar</strong>和java.util.Calendar不同， 它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。 一个Trigger可以和多个Calendar关联， 以便排除或包含某些时间点。</p>
<p>假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。针对不同时间段类型，Quartz在org.quartz.impl.calendar包下提供了若干个Calendar的实现类，如AnnualCalendar、MonthlyCalendar、WeeklyCalendar分别针对每年、每月和每周进行定义；</p>
<p><strong>Scheduler：</strong> 代表一个Quartz的独立运行容器， Trigger和JobDetail可以注册到Scheduler中， 两者在Scheduler中拥有各自的组及名称， 组及名称是Scheduler查找定位容器中某一对象的依据， Trigger的组及名称必须唯一， JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法， 允许外部通过组及名称访问和控制容器中Trigger和JobDetail。</p>
<p>Scheduler可以将Trigger绑定到某一JobDetail中， 这样当Trigger触发时， 对应的Job就被执行。一个Job可以对应多个Trigger， 但一个Trigger只能对应一个Job。可以通过SchedulerFactory创建一个Scheduler实例。Scheduler拥有一个SchedulerContext，它类似于ServletContext，保存着Scheduler上下文信息，Job和Trigger都可以访问SchedulerContext内的信息。SchedulerContext内部通过一个Map，以键值对的方式维护这些上下文数据，SchedulerContext为保存和获取数据提供了多个put()和getXxx()的方法。可以通过Scheduler# getContext()获取对应的SchedulerContext实例；</p>
<p><strong>ThreadPool：</strong> Scheduler使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程提高运行效率。<br>Job有一个StatefulJob子接口，代表有状态的任务，该接口是一个没有方法的标签接口，其目的是让Quartz知道任务的类型，以便采用不同的执行方案。无状态任务在执行时拥有自己的JobDataMap拷贝，对JobDataMap的更改不会影响下次的执行。而有状态任务共享共享同一个JobDataMap实例，每次任务执行对JobDataMap所做的更改会保存下来，后面的执行可以看到这个更改，也即每次执行任务后都会对后面的执行发生影响。<br>正因为这个原因，无状态的Job可以并发执行，而有状态的StatefulJob不能并发执行，这意味着如果前次的StatefulJob还没有执行完毕，下一次的任务将阻塞等待，直到前次任务执行完毕。有状态任务比无状态任务需要考虑更多的因素，程序往往拥有更高的复杂度，因此除非必要，应该尽量使用无状态的Job。<br>如果Quartz使用了数据库持久化任务调度信息，无状态的JobDataMap仅会在Scheduler注册任务时保持一次，而有状态任务对应的JobDataMap在每次执行任务后都会进行保存。<br>Trigger自身也可以拥有一个JobDataMap，其关联的Job可以通过JobExecutionContext#getTrigger().getJobDataMap()获取Trigger中的JobDataMap。不管是有状态还是无状态的任务，在任务执行期间对Trigger的JobDataMap所做的更改都不会进行持久，也即不会对下次的执行产生影响。</p>
<p>Quartz拥有完善的事件和监听体系，大部分组件都拥有事件，如任务执行前事件、任务执行后事件、触发器触发前事件、触发后事件、调度器开始事件、关闭事件等等，可以注册相应的监听器处理感兴趣的事件。</p>
<p>下图描述了Scheduler的内部组件结构，SchedulerContext提供Scheduler全局可见的上下文信息，每一个任务都对应一个JobDataMap，虚线表达的JobDataMap表示对应有状态的任务：</p>
<p>废话不多说， 上代码：</p>
<ol>
<li><p>最简单的Job代码(就打印Hello Quartz ！)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.wenniuwuren.quartz;  </span><br><span class="line"> </span><br><span class="line">import org.quartz.Job;  </span><br><span class="line">import org.quartz.JobExecutionContext;  </span><br><span class="line">import org.quartz.JobExecutionException;  </span><br><span class="line"> </span><br><span class="line">public class HelloQuartz  implements Job &#123;  </span><br><span class="line"> </span><br><span class="line">    public void execute(JobExecutionContext arg0) throws JobExecutionException &#123;  </span><br><span class="line">        System.out.println(&quot;Hello Quartz !&quot;);                 </span><br><span class="line">    &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置触发器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.wenniuwuren.quartz;  </span><br><span class="line"> </span><br><span class="line">import org.quartz.CronScheduleBuilder;    </span><br><span class="line">import org.quartz.JobBuilder;    </span><br><span class="line">import org.quartz.JobDetail;    </span><br><span class="line">import org.quartz.Scheduler;    </span><br><span class="line">import org.quartz.SchedulerException;  </span><br><span class="line">import org.quartz.SchedulerFactory;    </span><br><span class="line">import org.quartz.SimpleScheduleBuilder;  </span><br><span class="line">import org.quartz.Trigger;    </span><br><span class="line">import org.quartz.TriggerBuilder;    </span><br><span class="line">import org.quartz.impl.StdSchedulerFactory;    </span><br><span class="line"> </span><br><span class="line">public class SchedulerTest &#123;    </span><br><span class="line">   public static void main(String[] args) throws InterruptedException &#123;    </span><br><span class="line"> </span><br><span class="line">       //通过schedulerFactory获取一个调度器    </span><br><span class="line">       SchedulerFactory schedulerfactory = new StdSchedulerFactory();    </span><br><span class="line">       Scheduler scheduler=null;    </span><br><span class="line">       try&#123;    </span><br><span class="line">           // 通过schedulerFactory获取一个调度器    </span><br><span class="line">           scheduler = schedulerfactory.getScheduler();    </span><br><span class="line"> </span><br><span class="line">            // 创建jobDetail实例，绑定Job实现类    </span><br><span class="line">            // 指明job的名称，所在组的名称，以及绑定job类    </span><br><span class="line">           JobDetail job = JobBuilder.newJob(HelloQuartz.class).withIdentity(&quot;JobName&quot;, &quot;JobGroupName&quot;).build();    </span><br><span class="line"> </span><br><span class="line">            // 定义调度触发规则    </span><br><span class="line"> </span><br><span class="line">            // SimpleTrigger   </span><br><span class="line">//      Trigger trigger=TriggerBuilder.newTrigger().withIdentity(&quot;SimpleTrigger&quot;, &quot;SimpleTriggerGroup&quot;)    </span><br><span class="line">//                    .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(3).withRepeatCount(6))    </span><br><span class="line">//                    .startNow().build();    </span><br><span class="line"> </span><br><span class="line">            //  corn表达式  每五秒执行一次  </span><br><span class="line">              Trigger trigger=TriggerBuilder.newTrigger().withIdentity(&quot;CronTrigger1&quot;, &quot;CronTriggerGroup&quot;)    </span><br><span class="line">              .withSchedule(CronScheduleBuilder.cronSchedule(&quot;*/5 * * * * ?&quot;))    </span><br><span class="line">              .startNow().build();     </span><br><span class="line"> </span><br><span class="line">            // 把作业和触发器注册到任务调度中    </span><br><span class="line">           scheduler.scheduleJob(job, trigger);    </span><br><span class="line"> </span><br><span class="line">           // 启动调度    </span><br><span class="line">           scheduler.start();    </span><br><span class="line"> </span><br><span class="line">           Thread.sleep(10000);  </span><br><span class="line"> </span><br><span class="line">           // 停止调度  </span><br><span class="line">           scheduler.shutdown();  </span><br><span class="line"> </span><br><span class="line">       &#125;catch(SchedulerException e)&#123;    </span><br><span class="line">           e.printStackTrace();    </span><br><span class="line">       &#125;    </span><br><span class="line"> </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出(设置了sleep10秒， 故在0秒调度一次， 5秒一次， 10秒最后一次)：</p>
]]></content>
      
        
        <tags>
            
            <tag> Quartz </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shiro授权]]></title>
      <url>/shiro%E6%8E%88%E6%9D%83/</url>
      <content type="html"><![CDATA[<p>授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。</p>
<p><strong>主体</strong></p>
<p>主体，即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。</p>
<p><strong>资源</strong></p>
<p>在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。</p>
<p><strong>权限</strong></p>
<p>安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如：</p>
<p>访问用户列表页面</p>
<p>查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）</p>
<p>打印文档等等。。。</p>
<p>如上可以看出，权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允许，不反映谁去执行这个操作。所以后续还需要把权限赋予给用户，即定义哪个用户允许在某个资源上做什么操作（权限），Shiro不会去做这件事情，而是由实现人员提供。</p>
<p>Shiro支持粗粒度权限（如用户模块的所有权限）和细粒度权限（操作某个用户的权限，即实例级别的），后续部分介绍。</p>
<p><strong>角色</strong></p>
<p>角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。</p>
<p><strong>隐式角色</strong>：即直接通过角色来验证用户有没有操作权限，如在应用中CTO、技术总监、开发工程师可以使用打印机，假设某天不允许开发工程师使用打印机，此时需要从应用中删除相应代码；再如在应用中CTO、技术总监可以查看用户、查看权限；突然有一天不允许技术总监查看用户、查看权限了，需要在相关代码中把技术总监角色从判断逻辑中删除掉；即粒度是以角色为单位进行访问控制的，粒度较粗；如果进行修改可能造成多处代码修改。</p>
<p><strong>显示角色</strong>：在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合；这样假设哪个角色不能访问某个资源，只需要从角色代表的权限集合中移除即可；无须修改多处代码；即粒度是以资源/实例为单位的；粒度较细。</p>
<p>请google搜索“RBAC”和“RBAC新解”分别了解“基于角色的访问控制”“基于资源的访问控制(Resource-Based Access Control)”。</p>
<h2 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h2><p>Shiro支持三种方式的授权：</p>
<p><strong>编程式(代码入侵，不推荐)：通过写if/else授权代码块完成：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject();  </span><br><span class="line">if(subject.hasRole(“admin”)) &#123;  </span><br><span class="line">    //有权限  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">    //无权限  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注解式：通过在执行的Java方法上放置相应的注解完成：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequiresRoles(&quot;admin&quot;)  </span><br><span class="line">public void hello() &#123;  </span><br><span class="line">    //有权限  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没有权限将抛出相应的异常；<br><strong>JSP/GSP标签：在JSP/GSP页面通过相应的标签完成：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;  </span><br><span class="line">&lt;!— 有权限 —&gt;  </span><br><span class="line">&lt;/shiro:hasRole&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p><strong>基于角色的访问控制（隐式角色）</strong><br>1、在ini配置文件配置用户拥有的角色（shiro-role.ini）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[users]  </span><br><span class="line">zhang=123,role1,role2  </span><br><span class="line">wang=123,role1</span><br></pre></td></tr></table></figure></p>
<p>规则即：“用户名=密码,角色1，角色2”，如果需要在应用中判断用户是否有相应角色，就需要在相应的Realm中返回角色信息，也就是说Shiro不负责维护用户-角色信息，需要应用提供，Shiro只是提供相应的接口方便验证，后续会介绍如何动态的获取用户角色。</p>
<p>2、测试用例（com.github.zhangkaitao.shiro.chapter3.RoleTest）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test  </span><br><span class="line">public void testHasRole() &#123;  </span><br><span class="line">    login(&quot;classpath:shiro-role.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);  </span><br><span class="line">    //判断拥有角色：role1  </span><br><span class="line">    Assert.assertTrue(subject().hasRole(&quot;role1&quot;));  </span><br><span class="line">    //判断拥有角色：role1 and role2  </span><br><span class="line">    Assert.assertTrue(subject().hasAllRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;)));  </span><br><span class="line">    //判断拥有角色：role1 and role2 and !role3  </span><br><span class="line">    boolean[] result = subject().hasRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;));  </span><br><span class="line">    Assert.assertEquals(true, result[0]);  </span><br><span class="line">    Assert.assertEquals(true, result[1]);  </span><br><span class="line">    Assert.assertEquals(false, result[2]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Shiro提供了hasRole/hasRole用于判断用户是否拥有某个角色/某些权限；但是没有提供如hashAnyRole用于判断是否有某些权限中的某一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected = UnauthorizedException.class)  </span><br><span class="line">public void testCheckRole() &#123;  </span><br><span class="line">    login(&quot;classpath:shiro-role.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);  </span><br><span class="line">    //断言拥有角色：role1  </span><br><span class="line">    subject().checkRole(&quot;role1&quot;);  </span><br><span class="line">    //断言拥有角色：role1 and role3 失败抛出异常  </span><br><span class="line">    subject().checkRoles(&quot;role1&quot;, &quot;role3&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Shiro提供的checkRole/checkRoles和hasRole/hasAllRoles不同的地方是它在判断为假的情况下会抛出UnauthorizedException异常。</p>
<p>到此基于角色的访问控制（即隐式角色）就完成了，这种方式的缺点就是如果很多地方进行了角色判断，但是有一天不需要了那么就需要修改相应代码把所有相关的地方进行删除；这就是粗粒度造成的问题。<br><strong>基于资源的访问控制（显示角色）</strong></p>
<p>1、在ini配置文件配置用户拥有的角色及角色-权限关系（shiro-permission.ini）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[users]  </span><br><span class="line">zhang=123,role1,role2  </span><br><span class="line">wang=123,role1  </span><br><span class="line">[roles]  </span><br><span class="line">role1=user:create,user:update  </span><br><span class="line">role2=user:create,user:delete</span><br></pre></td></tr></table></figure></p>
<p>规则：“用户名=密码，角色1，角色2”“角色=权限1，权限2”，即首先根据用户名找到角色，然后根据角色再找到权限；即角色是权限集合；Shiro同样不进行权限的维护，需要我们通过Realm返回相应的权限信息。只需要维护“用户——角色”之间的关系即可。</p>
<p>2、测试用例（com.github.zhangkaitao.shiro.chapter3.PermissionTest）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test  </span><br><span class="line">public void testIsPermitted() &#123;  </span><br><span class="line">    login(&quot;classpath:shiro-permission.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);  </span><br><span class="line">    //判断拥有权限：user:create  </span><br><span class="line">    Assert.assertTrue(subject().isPermitted(&quot;user:create&quot;));  </span><br><span class="line">    //判断拥有权限：user:update and user:delete  </span><br><span class="line">    Assert.assertTrue(subject().isPermittedAll(&quot;user:update&quot;, &quot;user:delete&quot;));  </span><br><span class="line">    //判断没有权限：user:view  </span><br><span class="line">    Assert.assertFalse(subject().isPermitted(&quot;user:view&quot;));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Shiro提供了isPermitted和isPermittedAll用于判断用户是否拥有某个权限或所有权限，也没有提供如isPermittedAny用于判断拥有某一个权限的接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected = UnauthorizedException.class)  </span><br><span class="line">public void testCheckPermission () &#123;  </span><br><span class="line">    login(&quot;classpath:shiro-permission.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);  </span><br><span class="line">    //断言拥有权限：user:create  </span><br><span class="line">    subject().checkPermission(&quot;user:create&quot;);  </span><br><span class="line">    //断言拥有权限：user:delete and user:update  </span><br><span class="line">    subject().checkPermissions(&quot;user:delete&quot;, &quot;user:update&quot;);  </span><br><span class="line">    //断言拥有权限：user:view 失败抛出异常  </span><br><span class="line">    subject().checkPermissions(&quot;user:view&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是失败的情况下会抛出UnauthorizedException异常。</p>
<p>到此基于资源的访问控制（显示角色）就完成了，也可以叫基于权限的访问控制，这种方式的一般规则是“资源标识符：操作”，即是资源级别的粒度；这种方式的好处就是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但是实现起来可能稍微复杂点，需要维护“用户——角色，角色——权限（资源：操作）”之间的关系。  </p>
<h2 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h2><p><strong>字符串通配符权限</strong><br>规则：“资源标识符：操作：对象实例ID”  即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，“:”表示资源/操作/实例的分割；“,”表示操作的分割；“<em>”表示任意资源/操作/实例。<br><em>*1、单个资源单个权限</em></em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subject().checkPermissions(&quot;system:user:update&quot;);</span><br></pre></td></tr></table></figure></p>
<p>用户拥有资源“system:user”的“update”权限。<br><strong>2、单个资源多个权限</strong><br>ini配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">role41=system:user:update,system:user:delete</span><br></pre></td></tr></table></figure></p>
<p>然后通过如下代码判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;);</span><br></pre></td></tr></table></figure></p>
<p>用户拥有资源“system:user”的“update”和“delete”权限。如上可以简写成：<br>ini配置（表示角色4拥有system:user资源的update和delete权限）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">role42=&quot;system:user:update,delete&quot;</span><br></pre></td></tr></table></figure></p>
<p>接着可以通过如下代码判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subject().checkPermissions(&quot;system:user:update,delete&quot;);</span><br></pre></td></tr></table></figure></p>
<p>通过“system:user:update,delete”验证”system:user:update, system:user:delete”是没问题的，但是反过来是规则不成立。<br><strong>3、单个资源全部权限</strong><br>ini配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">role51=&quot;system:user:create,update,delete,view&quot;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subject().checkPermissions(&quot;system:user:create,delete,update:view&quot;);</span><br></pre></td></tr></table></figure>
<p>用户拥有资源“system:user”的“create”、“update”、“delete”和“view”所有权限。如上可以简写成：<br>ini配置文件（表示角色5拥有system:user的所有权限）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">role52=system:user:*</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subject().checkPermissions(&quot;system:user:*&quot;);  </span><br><span class="line">subject().checkPermissions(&quot;system:user&quot;);</span><br></pre></td></tr></table></figure>
<p>通过“system:user:*”验证“system:user:create,delete,update:view”可以，但是反过来是不成立的。</p>
<h2 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h2><p><img src="/shiro授权/01.png" alt="授权流程"><br>流程如下：</p>
<p>1、首先调用Subject.isPermitted<em>/hasRole</em>接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer；</p>
<p>2、Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission实例；</p>
<p>3、在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限；</p>
<p>4、Authorizer会判断Realm的角色/权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted<em>/hasRole</em>会返回true，否则返回false表示授权失败。</p>
<p>ModularRealmAuthorizer进行多Realm匹配流程：</p>
<p>1、首先检查相应的Realm是否实现了实现了Authorizer；</p>
<p>2、如果实现了Authorizer，那么接着调用其相应的isPermitted<em>/hasRole</em>接口进行匹配；</p>
<p>3、如果有一个Realm匹配那么将返回true，否则返回false。</p>
<p>如果Realm进行授权的话，应该继承AuthorizingRealm，其流程是：</p>
<p>1.1、如果调用hasRole*，则直接获取AuthorizationInfo.getRoles()与传入的角色比较即可；</p>
<p>1.2、首先如果调用如isPermitted(“user:view”)，首先通过PermissionResolver将权限字符串转换成相应的Permission实例，默认使用WildcardPermissionResolver，即转换为通配符的WildcardPermission；</p>
<p>2、通过AuthorizationInfo.getObjectPermissions()得到Permission实例集合；通过AuthorizationInfo. getStringPermissions()得到字符串集合并通过PermissionResolver解析为Permission实例；然后获取用户的角色，并通过RolePermissionResolver解析角色对应的权限集合（默认没有实现，可以自己提供）；</p>
<p>3、接着调用Permission. implies(Permission p)逐个与传入的权限比较，如果有匹配的则返回true，否则false。 </p>
<h2 id="Authorizer、PermissionResolver及RolePermissionResolver"><a href="#Authorizer、PermissionResolver及RolePermissionResolver" class="headerlink" title="Authorizer、PermissionResolver及RolePermissionResolver"></a>Authorizer、PermissionResolver及RolePermissionResolver</h2><p>Authorizer的职责是进行授权（访问控制），是Shiro API中授权核心的入口点，其提供了相应的角色/权限判断接口，具体请参考其Javadoc。SecurityManager继承了Authorizer接口，且提供了ModularRealmAuthorizer用于多Realm时的授权匹配。PermissionResolver用于解析权限字符串到Permission实例，而RolePermissionResolver用于根据角色解析相应的权限集合。</p>
<p>我们可以通过如下ini配置更改Authorizer实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer  </span><br><span class="line">securityManager.authorizer=$authorizer</span><br></pre></td></tr></table></figure></p>
<p>对于ModularRealmAuthorizer，相应的AuthorizingSecurityManager会在初始化完成后自动将相应的realm设置进去，我们也可以通过调用其setRealms()方法进行设置。对于实现自己的authorizer可以参考ModularRealmAuthorizer实现即可，在此就不提供示例了。</p>
<p>设置ModularRealmAuthorizer的permissionResolver，其会自动设置到相应的Realm上（其实现了PermissionResolverAware接口），如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver  </span><br><span class="line">authorizer.permissionResolver=$permissionResolver</span><br></pre></td></tr></table></figure></p>
<p>设置ModularRealmAuthorizer的rolePermissionResolver，其会自动设置到相应的Realm上（其实现了RolePermissionResolverAware接口），如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rolePermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.MyRolePermissionResolver  </span><br><span class="line">authorizer.rolePermissionResolver=$rolePermissionResolver</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong></p>
<p><strong>1、ini配置（shiro-authorizer.ini）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[main]  </span><br><span class="line">#自定义authorizer  </span><br><span class="line">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer  </span><br><span class="line">#自定义permissionResolver  </span><br><span class="line">#permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver  </span><br><span class="line">permissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.BitAndWildPermissionResolver  </span><br><span class="line">authorizer.permissionResolver=$permissionResolver  </span><br><span class="line">#自定义rolePermissionResolver  </span><br><span class="line">rolePermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.MyRolePermissionResolver  </span><br><span class="line">authorizer.rolePermissionResolver=$rolePermissionResolver  </span><br><span class="line">  </span><br><span class="line">securityManager.authorizer=$authorizer</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#自定义realm 一定要放在securityManager.authorizer赋值之后（因为调用setRealms会将realms设置给authorizer，并给各个Realm设置permissionResolver和rolePermissionResolver）  </span><br><span class="line">realm=com.github.zhangkaitao.shiro.chapter3.realm.MyRealm  </span><br><span class="line">securityManager.realms=$realm</span><br></pre></td></tr></table></figure>
<p>设置securityManager 的realms一定要放到最后，因为在调用SecurityManager.setRealms时会将realms设置给authorizer，并为各个Realm设置permissionResolver和rolePermissionResolver。另外，不能使用IniSecurityManagerFactory创建的IniRealm，因为其初始化顺序的问题可能造成后续的初始化Permission造成影响。</p>
<p><strong>2、定义BitAndWildPermissionResolver及BitPermission</strong></p>
<p>BitPermission用于实现位移方式的权限，如规则是：</p>
<p>权限字符串格式：+资源字符串+权限位+实例ID；以+开头中间通过+分割；权限：0 表示所有权限；1 新增（二进制：0001）、2 修改（二进制：0010）、4 删除（二进制：0100）、8 查看（二进制：1000）；如 +user+10 表示对资源user拥有修改/查看权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class BitPermission implements Permission &#123;  </span><br><span class="line">    private String resourceIdentify;  </span><br><span class="line">    private int permissionBit;  </span><br><span class="line">    private String instanceId;  </span><br><span class="line">    public BitPermission(String permissionString) &#123;  </span><br><span class="line">        String[] array = permissionString.split(&quot;\\+&quot;);  </span><br><span class="line">        if(array.length &gt; 1) &#123;  </span><br><span class="line">            resourceIdentify = array[1];  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(StringUtils.isEmpty(resourceIdentify)) &#123;  </span><br><span class="line">            resourceIdentify = &quot;*&quot;;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(array.length &gt; 2) &#123;  </span><br><span class="line">            permissionBit = Integer.valueOf(array[2]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(array.length &gt; 3) &#123;  </span><br><span class="line">            instanceId = array[3];  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(StringUtils.isEmpty(instanceId)) &#123;  </span><br><span class="line">            instanceId = &quot;*&quot;;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean implies(Permission p) &#123;  </span><br><span class="line">        if(!(p instanceof BitPermission)) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">        BitPermission other = (BitPermission) p;  </span><br><span class="line">        if(!(&quot;*&quot;.equals(this.resourceIdentify) || this.resourceIdentify.equals(other.resourceIdentify))) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(!(this.permissionBit ==0 || (this.permissionBit &amp; other.permissionBit) != 0)) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(!(&quot;*&quot;.equals(this.instanceId) || this.instanceId.equals(other.instanceId))) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Permission接口提供了boolean implies(Permission p)方法用于判断权限匹配的；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BitAndWildPermissionResolver implements PermissionResolver &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public Permission resolvePermission(String permissionString) &#123;  </span><br><span class="line">        if(permissionString.startsWith(&quot;+&quot;)) &#123;  </span><br><span class="line">            return new BitPermission(permissionString);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return new WildcardPermission(permissionString);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BitAndWildPermissionResolver实现了PermissionResolver接口，并根据权限字符串是否以“+”开头来解析权限字符串为BitPermission或WildcardPermission。</p>
<p><strong>3、定义MyRolePermissionResolver</strong></p>
<p>RolePermissionResolver用于根据角色字符串来解析得到权限集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyRolePermissionResolver implements RolePermissionResolver &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public Collection&lt;Permission&gt; resolvePermissionsInRole(String roleString) &#123;  </span><br><span class="line">        if(&quot;role1&quot;.equals(roleString)) &#123;  </span><br><span class="line">            return Arrays.asList((Permission)new WildcardPermission(&quot;menu:*&quot;));  </span><br><span class="line">        &#125;  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处的实现很简单，如果用户拥有role1，那么就返回一个“menu:*”的权限。</p>
<p><strong>4、自定义Realm</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyRealm extends AuthorizingRealm &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;  </span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();  </span><br><span class="line">        authorizationInfo.addRole(&quot;role1&quot;);  </span><br><span class="line">        authorizationInfo.addRole(&quot;role2&quot;);  </span><br><span class="line">        authorizationInfo.addObjectPermission(new BitPermission(&quot;+user1+10&quot;));  </span><br><span class="line">        authorizationInfo.addObjectPermission(new WildcardPermission(&quot;user1:*&quot;));  </span><br><span class="line">        authorizationInfo.addStringPermission(&quot;+user2+10&quot;);  </span><br><span class="line">        authorizationInfo.addStringPermission(&quot;user2:*&quot;);  </span><br><span class="line">        return authorizationInfo;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;  </span><br><span class="line">        //和com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1. getAuthenticationInfo代码一样，省略  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时我们继承AuthorizingRealm而不是实现Realm接口；推荐使用AuthorizingRealm，因为：</p>
<p>AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)：表示获取身份验证信息；</p>
<p>AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)：表示根据用户身份获取授权信息。</p>
<p>这种方式的好处是当只需要身份验证时只需要获取身份验证信息而不需要获取授权信息。对于AuthenticationInfo和AuthorizationInfo请参考其Javadoc获取相关接口信息。</p>
<p>另外我们可以使用JdbcRealm，需要做的操作如下：</p>
<p>1、执行sql/ shiro-init-data.sql 插入相关的权限数据；</p>
<p>2、使用shiro-jdbc-authorizer.ini配置文件，需要设置jdbcRealm.permissionsLookupEnabled</p>
<p>为true来开启权限查询。</p>
<p>此次还要注意就是不能把我们自定义的如“+user1+10”配置到INI配置文件，即使有IniRealm完成，因为IniRealm在new完成后就会解析这些权限字符串，默认使用了WildcardPermissionResolver完成，即此处是一个设计权限，如果采用生命周期（如使用初始化方法）的方式进行加载就可以解决我们自定义permissionResolver的问题。</p>
<p><strong>5、测试用例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AuthorizerTest extends BaseTest &#123;  </span><br><span class="line">  </span><br><span class="line">    @Test  </span><br><span class="line">    public void testIsPermitted() &#123;  </span><br><span class="line">        login(&quot;classpath:shiro-authorizer.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);  </span><br><span class="line">        //判断拥有权限：user:create  </span><br><span class="line">        Assert.assertTrue(subject().isPermitted(&quot;user1:update&quot;));  </span><br><span class="line">        Assert.assertTrue(subject().isPermitted(&quot;user2:update&quot;));  </span><br><span class="line">        //通过二进制位的方式表示权限  </span><br><span class="line">        Assert.assertTrue(subject().isPermitted(&quot;+user1+2&quot;));//新增权限  </span><br><span class="line">        Assert.assertTrue(subject().isPermitted(&quot;+user1+8&quot;));//查看权限  </span><br><span class="line">        Assert.assertTrue(subject().isPermitted(&quot;+user2+10&quot;));//新增及查看  </span><br><span class="line">  </span><br><span class="line">        Assert.assertFalse(subject().isPermitted(&quot;+user1+4&quot;));//没有删除权限  </span><br><span class="line">  </span><br><span class="line">        Assert.assertTrue(subject().isPermitted(&quot;menu:view&quot;));//通过MyRolePermissionResolver解析得到的权限  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过如上步骤可以实现自定义权限验证了。另外因为不支持hasAnyRole/isPermittedAny这种方式的授权，可以参考我的一篇《简单shiro扩展实现NOT、AND、OR权限验证 》进行简单的扩展完成这个需求，在这篇文章中通过重写AuthorizingRealm里的验证逻辑实现的。    </p>
]]></content>
      
        
        <tags>
            
            <tag> shiro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shiro身份认证]]></title>
      <url>/shiro%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</url>
      <content type="html"><![CDATA[<p><strong>身份验证</strong>，即在应用中谁能证明他就是他本人。一般提供如他们的身份ID一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。</p>
<p>在shiro中，用户需要提供principals （身份）和credentials（证明）给shiro，从而应用能验证用户身份：</p>
<p><strong>principals</strong>：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个Primary principals，一般是用户名/密码/手机号。</p>
<p><strong>credentials</strong>：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。</p>
<p>最常见的principals和credentials组合就是<em>用户名/密码</em>了。接下来先进行一个基本的身份认证。</p>
<p>另外两个相关的概念是之前提到的<strong>Subject</strong>及<strong>Realm</strong>,分别是主体及验证主体的数据源</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>本文使用Maven构建，因此需要一点Maven知识。首先准备环境依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;  </span><br><span class="line">    &lt;dependency&gt;  </span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;  </span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;  </span><br><span class="line">        &lt;version&gt;4.9&lt;/version&gt;  </span><br><span class="line">    &lt;/dependency&gt;  </span><br><span class="line">    &lt;dependency&gt;  </span><br><span class="line">        &lt;groupId&gt;commons-logging&lt;/groupId&gt;  </span><br><span class="line">        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;  </span><br><span class="line">        &lt;version&gt;1.1.3&lt;/version&gt;  </span><br><span class="line">    &lt;/dependency&gt;  </span><br><span class="line">    &lt;dependency&gt;  </span><br><span class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;  </span><br><span class="line">        &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;  </span><br><span class="line">        &lt;version&gt;1.2.2&lt;/version&gt;  </span><br><span class="line">    &lt;/dependency&gt;  </span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p>
<p>添加junit、common-logging及shiro-core依赖即可。</p>
<h2 id="登录-退出"><a href="#登录-退出" class="headerlink" title="登录/退出"></a>登录/退出</h2><h3 id="首先准备一些用户身份-凭据（shiro-ini）"><a href="#首先准备一些用户身份-凭据（shiro-ini）" class="headerlink" title="首先准备一些用户身份/凭据（shiro.ini）"></a>首先准备一些用户身份/凭据（shiro.ini）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[users]  </span><br><span class="line">zhang=123  </span><br><span class="line">wang=123</span><br></pre></td></tr></table></figure>
<p>此处使用ini配置文件，通过[users]指定了两个主体：zhang/123、wang/123。</p>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Test  </span><br><span class="line">public void testHelloworld() &#123;  </span><br><span class="line">    //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager  </span><br><span class="line">    Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory =  </span><br><span class="line">            new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);  </span><br><span class="line">    //2、得到SecurityManager实例 并绑定给SecurityUtils  </span><br><span class="line">    org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();  </span><br><span class="line">    SecurityUtils.setSecurityManager(securityManager);  </span><br><span class="line">    //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）  </span><br><span class="line">    Subject subject = SecurityUtils.getSubject();  </span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;, &quot;123&quot;);  </span><br><span class="line">  </span><br><span class="line">    try &#123;  </span><br><span class="line">        //4、登录，即身份验证  </span><br><span class="line">        subject.login(token);  </span><br><span class="line">    &#125; catch (AuthenticationException e) &#123;  </span><br><span class="line">        //5、身份验证失败  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Assert.assertEquals(true, subject.isAuthenticated()); //断言用户已经登录  </span><br><span class="line">  </span><br><span class="line">    //6、退出  </span><br><span class="line">    subject.logout();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.1、首先通过new IniSecurityManagerFactory并指定一个ini配置文件来创建一个SecurityManager工厂；</p>
<p>2.2、接着获取SecurityManager并绑定到SecurityUtils，这是一个全局设置，设置一次即可；</p>
<p>2.3、通过SecurityUtils得到Subject，其会自动绑定到当前线程；如果在web环境在请求结束时需要解除绑定；然后获取身份验证的Token，如用户名/密码；</p>
<p>2.4、调用subject.login方法进行登录，其会自动委托给SecurityManager.login方法进行登录；</p>
<p>2.5、如果身份验证失败请捕获AuthenticationException或其子类，常见的如： DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等，具体请查看其继承关系；对于页面的错误消息展示，最好使用如“用户名/密码错误”而不是“用户名错误”/“密码错误”，防止一些恶意用户非法扫描帐号库；</p>
<p>2.6、最后可以调用subject.logout退出，其会自动委托给SecurityManager.logout方法退出。</p>
<p><strong>从如上代码可总结出身份验证的步骤</strong>：</p>
<p>1、收集用户身份/凭证，即如用户名/密码；</p>
<p>2、调用Subject.login进行登录，如果失败将得到相应的AuthenticationException异常，根据异常提示用户错误信息；否则登录成功；</p>
<p>3、最后调用Subject.logout进行退出操作<br>如上测试的几个问题：</p>
<p>1、用户名/密码硬编码在ini配置文件，以后需要改成如数据库存储，且密码需要加密存储；</p>
<p>2、用户身份Token可能不仅仅是用户名/密码，也可能还有其他的，如登录时允许用户名/邮箱/手机号同时登陆</p>
<h2 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h2><p><img src="/shiro身份认证/01.png" alt="身份认证"><br>流程如下：</p>
<p>1、首先调用Subject.login(token)进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置；</p>
<p>2、SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证；</p>
<p>3、Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现；</p>
<p>4、Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证；</p>
<p>5、Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。</p>
<h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h2><p>Realm：域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。如我们之前的ini配置方式将使用org.apache.shiro.realm.text.IniRealm。</p>
<p>org.apache.shiro.realm.Realm接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String getName(); //返回一个唯一的Realm名字  </span><br><span class="line">boolean supports(AuthenticationToken token); //判断此Realm是否支持此Token  </span><br><span class="line">AuthenticationInfo getAuthenticationInfo(AuthenticationToken token)  </span><br><span class="line"> throws AuthenticationException;  //根据Token获取认证信息</span><br></pre></td></tr></table></figure></p>
<h3 id="单Realm配置"><a href="#单Realm配置" class="headerlink" title="单Realm配置"></a>单Realm配置</h3><p>1、自定义Realm实现（com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyRealm1 implements Realm &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public String getName() &#123;  </span><br><span class="line">        return &quot;myrealm1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean supports(AuthenticationToken token) &#123;  </span><br><span class="line">        //仅支持UsernamePasswordToken类型的Token  </span><br><span class="line">        return token instanceof UsernamePasswordToken;   </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;  </span><br><span class="line">        String username = (String)token.getPrincipal();  //得到用户名  </span><br><span class="line">        String password = new String((char[])token.getCredentials()); //得到密码  </span><br><span class="line">        if(!&quot;zhang&quot;.equals(username)) &#123;  </span><br><span class="line">            throw new UnknownAccountException(); //如果用户名错误  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(!&quot;123&quot;.equals(password)) &#123;  </span><br><span class="line">            throw new IncorrectCredentialsException(); //如果密码错误  </span><br><span class="line">        &#125;  </span><br><span class="line">        //如果身份认证验证成功，返回一个AuthenticationInfo实现；  </span><br><span class="line">        return new SimpleAuthenticationInfo(username, password, getName());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、ini配置文件指定自定义Realm实现(shiro-realm.ini)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#声明一个realm  </span><br><span class="line">myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm</span><br><span class="line">#指定securityManager的realms实现  </span><br><span class="line">securityManager.realms=$myRealm1</span><br></pre></td></tr></table></figure></p>
<p>通过$name来引入之前的realm定义</p>
<p>3、测试用例请参考com.github.zhangkaitao.shiro.chapter2.LoginLogoutTest的testCustomRealm测试方法，只需要把之前的shiro.ini配置文件改成shiro-realm.ini即可。</p>
<h3 id="多Realm配置"><a href="#多Realm配置" class="headerlink" title="多Realm配置"></a>多Realm配置</h3><p>1、ini配置文件（shiro-multi-realm.ini）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#声明一个realm  </span><br><span class="line">myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1  </span><br><span class="line">myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2  </span><br><span class="line">#指定securityManager的realms实现  </span><br><span class="line">securityManager.realms=$myRealm1,$myRealm2</span><br></pre></td></tr></table></figure></p>
<p>securityManager会按照realms指定的顺序进行身份认证。此处我们使用显示指定顺序的方式指定了Realm的顺序，如果删除“securityManager.realms=$myRealm1,$myRealm2”，那么securityManager会按照realm声明的顺序进行使用（即无需设置realms属性，其会自动发现），当我们显示指定realm后，其他没有指定realm将被忽略，如“securityManager.realms=$myRealm1”，那么myRealm2不会被自动设置进去。<br>2、测试用例请参考com.github.zhangkaitao.shiro.chapter2.LoginLogoutTest的testCustomMultiRealm测试方法。<br><strong>Shiro默认提供的Realm</strong><br><img src="/shiro身份认证/02.png" alt="默认ream"><br>以后一般继承AuthorizingRealm（授权）即可；其继承了AuthenticatingRealm（即身份验证），而且也间接继承了CachingRealm（带有缓存实现）。其中主要默认实现如下：</p>
<p><strong>org.apache.shiro.realm.text.IniRealm</strong>：[users]部分指定用户名/密码及其角色；[roles]部分指定角色即权限信息；</p>
<p><strong>org.apache.shiro.realm.text.PropertiesRealm</strong>： user.username=password,role1,role2指定用户名/密码及其角色；role.role1=permission1,permission2指定角色及权限信息；</p>
<p><strong>org.apache.shiro.realm.jdbc.JdbcRealm</strong>：通过sql查询相应的信息，如“select password from users where username = ?”获取用户密码，“select password, password_salt from users where username = ?”获取用户密码及盐；“select role_name from user_roles where username = ?”获取用户角色；“select permission from roles_permissions where role_name = ?”获取角色对应的权限信息；也可以调用相应的api进行自定义sql；</p>
<h2 id="Authenticator及AuthenticationStrategy"><a href="#Authenticator及AuthenticationStrategy" class="headerlink" title="Authenticator及AuthenticationStrategy"></a>Authenticator及AuthenticationStrategy</h2><p>Authenticator的职责是验证用户帐号，是Shiro API中身份验证核心的入口点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)  </span><br><span class="line">            throws AuthenticationException;</span><br></pre></td></tr></table></figure></p>
<p>如果验证成功，将返回AuthenticationInfo验证信息；此信息中包含了身份及凭证；如果验证失败将抛出相应的AuthenticationException实现。</p>
<p>SecurityManager接口继承了Authenticator，另外还有一个ModularRealmAuthenticator实现，其委托给多个Realm进行验证，验证规则通过AuthenticationStrategy接口指定，默认提供的实现：</p>
<p><strong>FirstSuccessfulStrategy</strong>：只要有一个Realm验证成功即可，只返回第一个Realm身份验证成功的认证信息，其他的忽略；</p>
<p><strong>AtLeastOneSuccessfulStrategy</strong>：只要有一个Realm验证成功即可，和FirstSuccessfulStrategy不同，返回所有Realm身份验证成功的认证信息；</p>
<p><strong>AllSuccessfulStrategy</strong>：所有Realm验证成功才算成功，且返回所有Realm身份验证成功的认证信息，如果有一个失败就失败了。</p>
<p>ModularRealmAuthenticator默认使用AtLeastOneSuccessfulStrategy策略。</p>
<p>假设我们有三个realm：</p>
<p>myRealm1： 用户名/密码为zhang/123时成功，且返回身份/凭据为zhang/123；</p>
<p>myRealm2： 用户名/密码为wang/123时成功，且返回身份/凭据为wang/123；</p>
<p>myRealm3： 用户名/密码为zhang/123时成功，且返回身份/凭据为zhang@163.com/123，和myRealm1不同的是返回时的身份变了；</p>
<p>1、ini配置文件(shiro-authenticator-all-success.ini)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#指定securityManager的authenticator实现  </span><br><span class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator  </span><br><span class="line">securityManager.authenticator=$authenticator  </span><br><span class="line">  </span><br><span class="line">#指定securityManager.authenticator的authenticationStrategy  </span><br><span class="line">allSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategy  </span><br><span class="line">securityManager.authenticator.authenticationStrategy=$allSuccessfulStrategy</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1  </span><br><span class="line">myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2  </span><br><span class="line">myRealm3=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm3  </span><br><span class="line">securityManager.realms=$myRealm1,$myRealm3</span><br></pre></td></tr></table></figure>
<p>2、测试代码（com.github.zhangkaitao.shiro.chapter2.AuthenticatorTest）</p>
<p>2.1、首先通用化登录逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void login(String configFile) &#123;  </span><br><span class="line">    //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager  </span><br><span class="line">    Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory =  </span><br><span class="line">            new IniSecurityManagerFactory(configFile);  </span><br><span class="line">  </span><br><span class="line">    //2、得到SecurityManager实例 并绑定给SecurityUtils  </span><br><span class="line">    org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();  </span><br><span class="line">    SecurityUtils.setSecurityManager(securityManager);  </span><br><span class="line">  </span><br><span class="line">    //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）  </span><br><span class="line">    Subject subject = SecurityUtils.getSubject();  </span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;, &quot;123&quot;);  </span><br><span class="line">  </span><br><span class="line">    subject.login(token);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.2、测试AllSuccessfulStrategy成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test  </span><br><span class="line">public void testAllSuccessfulStrategyWithSuccess() &#123;  </span><br><span class="line">    login(&quot;classpath:shiro-authenticator-all-success.ini&quot;);  </span><br><span class="line">    Subject subject = SecurityUtils.getSubject();  </span><br><span class="line">  </span><br><span class="line">    //得到一个身份集合，其包含了Realm验证成功的身份信息  </span><br><span class="line">    PrincipalCollection principalCollection = subject.getPrincipals();  </span><br><span class="line">    Assert.assertEquals(2, principalCollection.asList().size());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即PrincipalCollection包含了zhang和zhang@163.com身份信息。<br>2.3、测试AllSuccessfulStrategy失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  @Test(expected = UnknownAccountException.class)  </span><br><span class="line">    public void testAllSuccessfulStrategyWithFail() &#123;  </span><br><span class="line">        login(&quot;classpath:shiro-authenticator-all-fail.ini&quot;);  </span><br><span class="line">        Subject subject = SecurityUtils.getSubject();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>shiro-authenticator-all-fail.ini与shiro-authenticator-all-success.ini不同的配置是使用了securityManager.realms=$myRealm1,$myRealm2；即myRealm验证失败。</p>
<p>对于AtLeastOneSuccessfulStrategy和FirstSuccessfulStrategy的区别，请参照testAtLeastOneSuccessfulStrategyWithSuccess和testFirstOneSuccessfulStrategyWithSuccess测试方法。唯一不同点一个是返回所有验证成功的Realm的认证信息；另一个是只返回第一个验证成功的Realm的认证信息。</p>
<p>自定义AuthenticationStrategy实现，首先看其API：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//在所有Realm验证之前调用  </span><br><span class="line">AuthenticationInfo beforeAllAttempts(  </span><br><span class="line">Collection&lt;? extends Realm&gt; realms, AuthenticationToken token)   </span><br><span class="line">throws AuthenticationException;  </span><br><span class="line">//在每个Realm之前调用  </span><br><span class="line">AuthenticationInfo beforeAttempt(  </span><br><span class="line">Realm realm, AuthenticationToken token, AuthenticationInfo aggregate)   </span><br><span class="line">throws AuthenticationException;  </span><br><span class="line">//在每个Realm之后调用  </span><br><span class="line">AuthenticationInfo afterAttempt(  </span><br><span class="line">Realm realm, AuthenticationToken token,   </span><br><span class="line">AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t)  </span><br><span class="line">throws AuthenticationException;  </span><br><span class="line">//在所有Realm之后调用  </span><br><span class="line">AuthenticationInfo afterAllAttempts(  </span><br><span class="line">AuthenticationToken token, AuthenticationInfo aggregate)   </span><br><span class="line">throws AuthenticationException;</span><br></pre></td></tr></table></figure></p>
<p>因为每个AuthenticationStrategy实例都是无状态的，所有每次都通过接口将相应的认证信息传入下一次流程；通过如上接口可以进行如合并/返回第一个验证成功的认证信息。</p>
<p>自定义实现时一般继承org.apache.shiro.authc.pam.AbstractAuthenticationStrategy即可，具体可以参考代码com.github.zhangkaitao.shiro.chapter2.authenticator.strategy包下OnlyOneAuthenticatorStrategy 和AtLeastTwoAuthenticatorStrategy。</p>
]]></content>
      
        
        <tags>
            
            <tag> shiro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shiro简介]]></title>
      <url>/shiro%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apache Shiro是Java的一个安全框架。目前，使用Apache Shiro的人越来越多，因为它相当简单，对比Spring Security，可能没有Spring Security做的功能强大，但是在实际工作时可能并不需要那么复杂的东西，所以使用小而简单的Shiro就足够了。对于它俩到底哪个好，这个不必纠结，能更简单的解决项目问题就好了。</p>
<p> 本教程只介绍基本的Shiro使用，不会过多分析源码等，重在使用。</p>
<p> Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。Shiro可以帮助我们完成：认证、授权、加密、会话管理、与Web集成、缓存等。这不就是我们想要的嘛，而且Shiro的API也是非常简单；其基本功能点如下图所示：</p>
<p><img src="/shiro简介/01.png" alt="Shiro基本功能"></p>
<p><strong>Authentication</strong>：身份认证/登录，验证用户是不是拥有相应的身份；</p>
<p><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p>
<p><strong>Session Manager</strong>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</p>
<p><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</p>
<p><strong>Web Support</strong>：Web支持，可以非常容易的集成到Web环境；</p>
<p><strong>Caching</strong>：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</p>
<p><strong>Concurrency</strong>：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</p>
<p><strong>Testing</strong>：提供测试支持；</p>
<p><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</p>
<p><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。<br><strong>记住一点，Shiro不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给Shiro即可。</strong></p>
<p>接下来我们分别从外部和内部来看看Shiro的架构，对于一个好的框架，从外部来看应该具有非常简单易于使用的API，且API契约明确；从内部来看的话，其应该有一个可扩展的架构，即非常容易插入用户自定义实现，因为任何框架都不能满足所有需求。</p>
<p>首先，我们从外部来看Shiro吧，即从应用程序角度的来观察如何使用Shiro完成工作。如下图：<br><img src="/shiro简介/02.png" alt="Shiro功能"></p>
<p>可以看到：应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject；其每个API的含义：</p>
<p><strong>Subject</strong>：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；</p>
<p><strong>SecurityManager</strong>：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；</p>
<p><strong>Realm</strong>：域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。</p>
<p>也就是说对于我们而言，最简单的一个Shiro应用：</p>
<p>1、应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；</p>
<p>2、我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。</p>
<p><strong>从以上也可以看出，Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。</strong></p>
<p>接下来我们来从Shiro内部来看下Shiro的架构，如下图所示：</p>
<p><img src="/shiro简介/03.png" alt="Shiro架构"><br><strong>Subject</strong>：主体，可以看到主体可以是任何可以与应用交互的“用户”；</p>
<p><strong>SecurityManager</strong>：相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理。</p>
<p><strong>Authenticator</strong>：认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</p>
<p><strong>Authrizer</strong>：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</p>
<p><strong>Realm</strong>：可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm；</p>
<p><strong>SessionManager</strong>：如果写过Servlet就应该知道Session的概念，Session呢需要有人去管理它的生命周期，这个组件就是SessionManager；而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境；所有呢，Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据；这样的话，比如我们在Web环境用，刚开始是一台Web服务器；接着又上了台EJB服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到Memcached服务器）；</p>
<p><strong>SessionDAO</strong>：DAO大家都用过，数据访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把Session放到Memcached中，可以实现自己的Memcached SessionDAO；另外SessionDAO中可以使用Cache进行缓存，以提高性能；</p>
<p><strong>CacheManager</strong>：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</p>
<p><strong>Cryptography</strong>：密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密的。</p>
<p>到此Shiro架构及其组件就认识完了，接下来挨着学习Shiro的组件吧。</p>
]]></content>
      
        
        <tags>
            
            <tag> shiro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自定义ArrayList]]></title>
      <url>/%E8%87%AA%E5%AE%9A%E4%B9%89ArrayList/</url>
      <content type="html"><![CDATA[<h2 id="参考ArrayList的源码可以自己实现一个ArrayList代码如下："><a href="#参考ArrayList的源码可以自己实现一个ArrayList代码如下：" class="headerlink" title="参考ArrayList的源码可以自己实现一个ArrayList代码如下："></a>参考ArrayList的源码可以自己实现一个ArrayList代码如下：</h2><pre><code>public class MyArrayList&lt;E&gt; implements Iterable&lt;E&gt;{
    //集合的大小
    private int size;
    //真正存放元素的数组的大小
    private Object[] values = new Object[2];
    /**
     * 添加方法
     * @param obj 要添加的元素
     */
    public void add(E e) {
        //检查存放数组的数组是否已经放慢，如果放满，就将数组长度增加为原来的2倍
        checkSize();
        //然后放进去
        values[size++] = e;
    }
    private void checkSize() {
        if(size &gt;= values.length-1) {//如果数组的大小等于集合的大小，就放满了，就开辟新的数组
            Object[] newValues = new Object[values.length*2];
            //将旧数组中的元素复制到新数组中
            copyOldToNewArr(values, newValues);
            //把value指向新的数组
            values = newValues;
        }
    }
    private void copyOldToNewArr(Object[] oldArr, Object[] newArr) {
        for(int i = 0; i &lt; oldArr.length; i++) {
            newArr[i] = oldArr[i];
        }
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public E get(int index) {
        if(index &gt;= size) {
            throw new IndexOutOfBoundsException(&quot;索引越界&quot;);
        }
        return (E)values[index];
    }
    public int size() {
        return size;
    }
    public Iterator&lt;E&gt; iterator() {
        return new Itr&lt;E&gt;();
    }
    private class Itr&lt;E&gt; implements Iterator&lt;E&gt; {
        int cursor;//定义光标，从0开始
        @Override
        public boolean hasNext() {
            return cursor!=size;//如果光标不等于集合的大小，还有下一个元素
        }
        @Override
        public E next() {
            int i = cursor;
            cursor++;
            return (E) values[i];
        }
        @Override
        public void remove() {

        }

    }
}
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> ArrayList </tag>
            
            <tag> 自定义 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ActiveMQ常见问题总结]]></title>
      <url>/ActiveMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="先讲严重的：服务挂掉"><a href="#先讲严重的：服务挂掉" class="headerlink" title="先讲严重的：服务挂掉"></a>先讲严重的：服务挂掉</h2><p>这得从ActiveMQ的储存机制说起。在通常的情况下，非持久化消息是存储在内存中的，持久化消息是存储在文件中的，它们的最大限制在配置文件的<systemusage>节点中配置。但是，在非持久化消息堆积到一定程度，内存告急的时候，ActiveMQ会将内存中的非持久化消息写入临时文件中，以腾出内存。虽然都保存到了文件里，但它和持久化消息的区别是，重启后持久化消息会从文件中恢复，非持久化的临时文件会直接删除。</systemusage></p>
<p>那如果文件增大到达了配置中的最大限制的时候会发生什么？我做了以下实验：</p>
<p>设置2G左右的持久化文件限制，大量生产持久化消息直到文件达到最大限制，此时生产者阻塞，但消费者可正常连接并消费消息，等消息消费掉一部分，文件删除又腾出空间之后，生产者又可继续发送消息，服务自动恢复正常。</p>
<p>设置2G左右的临时文件限制，大量生产非持久化消息并写入临时文件，在达到最大限制时，生产者阻塞，消费者可正常连接但不能消费消息，或者原本慢速消费的消费者，消费突然停止。整个系统可连接，但是无法提供服务，就这样挂了。</p>
<p>具体原因不详，解决方案：尽量不要用非持久化消息，非要用的话，将临时文件限制尽可能的调大。</p>
<p>详细配置信息见文档：<a href="http://activemq.apache.org/producer-flow-control.html" target="_blank" rel="external">http://activemq.apache.org/producer-flow-control.html</a></p>
<hr>
<h2 id="丢消息"><a href="#丢消息" class="headerlink" title="丢消息"></a>丢消息</h2><p>这得从java的java.net.SocketException异常说起。简单点说就是当网络发送方发送一堆数据，然后调用close关闭连接之后。这些发送的数据都在接收者的缓存里，接收者如果调用read方法仍旧能从缓存中读取这些数据，尽管对方已经关闭了连接。但是当接收者尝试发送数据时，由于此时连接已关闭，所以会发生异常，这个很好理解。不过需要注意的是，当发生SocketException后，原本缓存区中数据也作废了，此时接收者再次调用read方法去读取缓存中的数据，就会报Software caused connection abort: recv failed错误。</p>
<p>通过抓包得知，ActiveMQ会每隔10秒发送一个心跳包，这个心跳包是服务器发送给客户端的，用来判断客户端死没死。如果你看过上面第一条，就会知道非持久化消息堆积到一定程度会写到文件里，这个写的过程会阻塞所有动作，而且会持续20到30秒，并且随着内存的增大而增大。当客户端发完消息调用connection.close()时，会期待服务器对于关闭连接的回答，如果超过15秒没回答就直接调用socket层的close关闭tcp连接了。这时客户端发出的消息其实还在服务器的缓存里等待处理，不过由于服务器心跳包的设置，导致发生了java.net.SocketException异常，把缓存里的数据作废了，没处理的消息全部丢失。</p>
<p>解决方案：用持久化消息，或者非持久化消息及时处理不要堆积，或者启动事务，启动事务后，commit()方法会负责任的等待服务器的返回，也就不会关闭连接导致消息丢失了。</p>
<p>关于java.net.SocketException请看我的详细研究：<a href="http://blog.163.com/_kid/blog/static/3040547620160231534692/" target="_blank" rel="external">http://blog.163.com/_kid/blog/static/3040547620160231534692/</a></p>
<hr>
<h2 id="持久化消息非常慢"><a href="#持久化消息非常慢" class="headerlink" title="持久化消息非常慢"></a>持久化消息非常慢</h2><p>默认的情况下，非持久化的消息是异步发送的，持久化的消息是同步发送的，遇到慢一点的硬盘，发送消息的速度是无法忍受的。但是在开启事务的情况下，消息都是异步发送的，效率会有2个数量级的提升。所以在发送持久化消息时，请务必开启事务模式。其实发送非持久化消息时也建议开启事务，因为根本不会影响性能。</p>
<h2 id="消息的不均匀消费"><a href="#消息的不均匀消费" class="headerlink" title="消息的不均匀消费"></a>消息的不均匀消费</h2><p>有时在发送一些消息之后，开启2个消费者去处理消息。会发现一个消费者处理了所有的消息，另一个消费者根本没收到消息。原因在于ActiveMQ的prefetch机制。当消费者去获取消息时，不会一条一条去获取，而是一次性获取一批，默认是1000条。这些预获取的消息，在还没确认消费之前，在管理控制台还是可以看见这些消息的，但是不会再分配给其他消费者，此时这些消息的状态应该算作“已分配未消费”，如果消息最后被消费，则会在服务器端被删除，如果消费者崩溃，则这些消息会被重新分配给新的消费者。但是如果消费者既不消费确认，又不崩溃，那这些消息就永远躺在消费者的缓存区里无法处理。更通常的情况是，消费这些消息非常耗时，你开了10个消费者去处理，结果发现只有一台机器吭哧吭哧处理，另外9台啥事不干。</p>
<p>解决方案：将prefetch设为1，每次处理1条消息，处理完再去取，这样也慢不了多少。</p>
<p>详细文档：<a href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html" target="_blank" rel="external">http://activemq.apache.org/what-is-the-prefetch-limit-for.html</a></p>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>如果你想在消息处理失败后，不被服务器删除，还能被其他消费者处理或重试，可以关闭AUTO_ACKNOWLEDGE，将ack交由程序自己处理。那如果使用了AUTO_ACKNOWLEDGE，消息是什么时候被确认的，还有没有阻止消息确认的方法？有！</p>
<p>消费消息有2种方法，一种是调用consumer.receive()方法，该方法将阻塞直到获得并返回一条消息。这种情况下，消息返回给方法调用者之后就自动被确认了。另一种方法是采用listener回调函数，在有消息到达时，会调用listener接口的onMessage方法。在这种情况下，在onMessage方法执行完毕后，消息才会被确认，此时只要在方法中抛出异常，该消息就不会被确认。那么问题来了，如果一条消息不能被处理，会被退回服务器重新分配，如果只有一个消费者，该消息又会重新被获取，重新抛异常。就算有多个消费者，往往在一个服务器上不能处理的消息，在另外的服务器上依然不能被处理。难道就这么退回–获取–报错死循环了吗？</p>
<p>在重试6次后，ActiveMQ认为这条消息是“有毒”的，将会把消息丢到死信队列里。如果你的消息不见了，去ActiveMQ.DLQ里找找，说不定就躺在那里。</p>
<p>详细文档：<a href="http://activemq.apache.org/redelivery-policy.html" target="_blank" rel="external">http://activemq.apache.org/redelivery-policy.html</a></p>
<p><a href="http://activemq.apache.org/message-redelivery-and-dlq-handling.html" target="_blank" rel="external">http://activemq.apache.org/message-redelivery-and-dlq-handling.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> activeMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ActiveMQ应用详解]]></title>
      <url>/ActiveMQ%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="ActiveMQj简介"><a href="#ActiveMQj简介" class="headerlink" title="ActiveMQj简介"></a>ActiveMQj简介</h2><pre><code>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。
</code></pre><h2 id="ActiveMQj安装"><a href="#ActiveMQj安装" class="headerlink" title="ActiveMQj安装"></a>ActiveMQj安装</h2><pre><code>首先去http://activemq.apache.org/download.html 下载最新版本 
目录如下： 
+bin (windows下面的bat和unix/linux下面的sh) 
+conf (activeMQ配置目录，包含最基本的activeMQ配置文件） 
+data （默认是空的） 
+docs (index,replease版本里面没有文档，-.-b不知道为啥不带） 
+example （几个例子） 
+lib (activemMQ使用到的lib) 
-apache-activemq-4.1-incubator.jar (ActiveMQ的binary) 
-LICENSE.txt 
运行信息 
运行信息 
-NOTICE.txt 
-README.txt 
-user-guide.html 


启动bin/win64/activemq.bat
启动成功就可以访问管理员界面：http://localhost:8161/admin 
默认用户名和密码admin/admin。如果你想修改用户名和密码的话，在conf/jetty-realm.properties中修改即可。 
</code></pre><p>linux下安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://archive.apache.org/dist/activemq/5.14.1/apache-activemq-5.14.1-bin.tar.gz</span><br><span class="line">cd apache-activemq-5.14.1/bin/linux-x86-64/</span><br><span class="line">./activemq start</span><br></pre></td></tr></table></figure></p>
<h2 id="ActiveMQj应用"><a href="#ActiveMQj应用" class="headerlink" title="ActiveMQj应用"></a>ActiveMQj应用</h2><p>###(1)、点对点方式（point-to-point Queue）</p>
<pre><code>点对点的消息发送方式主要建立在 Message Queue,Sender,reciever上，Message Queue 存贮消息，Sneder 发送消息，receive接收消息.具体点就是Sender Client发送Message Queue ,而 receiver Cliernt从Queue中接收消息和”发送消息已接受”到Quere,确认消息接收。消息发送客户端与接收客户端没有时间上的依赖，发送客户端可以在任何时刻发送信息到Queue，而不需要知道接收客户端是不是在运行
</code></pre><p>###(2)、发布/订阅 方式（publish/subscriber MessagingTopic）</p>
<pre><code>发布/订阅方式用于多接收客户端的方式.作为发布订阅的方式，可能存在多个接收客户端，并且接收端客户端与发送客户端存在时间上的依赖。一个接收端只能接收他创建以后发送客户端发送的信息。作为subscriber ,在接收消息时有两种方法，destination的receive方法，和实现message listener 接口的onMessage 方法。
</code></pre><p>(生产者)发送消息的基本步骤：</p>
<ul>
<li>(1)、创建连接使用的工厂类JMS ConnectionFactory</li>
<li>(2)、使用管理对象JMSConnectionFactory建立连接Connection，并启动  </li>
<li>(3)、使用连接Connection 建立会话Session</li>
<li>(4)、使用会话Session和管理对象Destination创建消息生产者MessageSender </li>
<li>(5)、使用消息生产者MessageSender发送消息</li>
</ul>
<p>（消费者）消息接收者从JMS接受消息的步骤 </p>
<ul>
<li>(1)、创建连接使用的工厂类JMS ConnectionFactory</li>
<li>(2)、使用管理对象JMSConnectionFactory建立连接Connection，并启动  </li>
<li>(3)、使用连接Connection 建立会话Session</li>
<li>(4)、使用会话Session和管理对象Destination创建消息接收者MessageReceiver </li>
<li>(5)、使用消息接收者MessageReceiver接受消息，需要用setMessageListener将MessageListener接口绑定到MessageReceiver消息收者必须实现了MessageListener接口，需要定义onMessage事件方法。</li>
</ul>
<h2 id="ActiveMQ代码实现"><a href="#ActiveMQ代码实现" class="headerlink" title="ActiveMQ代码实现"></a>ActiveMQ代码实现</h2><h3 id="JMS方式"><a href="#JMS方式" class="headerlink" title="JMS方式"></a>JMS方式</h3><p><strong>消费者</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class MessageReceiver &#123;</span><br><span class="line">    // tcp 地址</span><br><span class="line">    public static final String BROKER_URL = &quot;tcp://localhost:61616&quot;;</span><br><span class="line">    // 目标，在ActiveMQ管理员控制台创建 http://localhost:8161/admin/queues.jsp</span><br><span class="line">    public static final String DESTINATION = &quot;hoo.mq.queue&quot;;</span><br><span class="line">    public static void run() throws Exception &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        Session session = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建链接工厂</span><br><span class="line">            ConnectionFactory factory = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, BROKER_URL);</span><br><span class="line">            // 通过工厂创建一个连接</span><br><span class="line">            connection = factory.createConnection();</span><br><span class="line">            // 启动连接</span><br><span class="line">            connection.start();</span><br><span class="line">            // 创建一个session会话</span><br><span class="line">            session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            // 创建一个消息队列</span><br><span class="line">            Destination destination = session.createQueue(DESTINATION);</span><br><span class="line">            // 创建消息制作者</span><br><span class="line">            MessageConsumer consumer = session.createConsumer(destination);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 接收数据的时间（等待） 100 ms</span><br><span class="line">                Message message = consumer.receive(1000 * 100);</span><br><span class="line"></span><br><span class="line">                TextMessage text = (TextMessage) message;</span><br><span class="line">                if (text != null) &#123;</span><br><span class="line">                    System.out.println(&quot;接收：&quot; + text.getText());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 提交会话</span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 关闭释放资源</span><br><span class="line">            if (session != null) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection != null) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MessageReceiver.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>生产者</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class MessageSender &#123;</span><br><span class="line">    // 发送次数</span><br><span class="line">    public static final int SEND_NUM = 5;</span><br><span class="line">    // tcp 地址</span><br><span class="line">    public static final String BROKER_URL = &quot;tcp://localhost:61616&quot;;</span><br><span class="line">    // 目标，在ActiveMQ管理员控制台创建 http://localhost:8161/admin/queues.jsp</span><br><span class="line">    public static final String DESTINATION = &quot;hoo.mq.queue&quot;;</span><br><span class="line">    @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">    private static void sendMessage(Session session, MessageProducer producer) throws JMSException&#123;</span><br><span class="line">        for (int i = 0; i &lt; SEND_NUM; i++) &#123;</span><br><span class="line">            String message = &quot;发送消息第&quot; + (i + 1) + &quot;条&quot;;</span><br><span class="line">            TextMessage text = session.createTextMessage(message);</span><br><span class="line"></span><br><span class="line">            System.out.println(message);</span><br><span class="line">            producer.send(text);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void run() throws Exception &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        Session session = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建链接工厂</span><br><span class="line">            ConnectionFactory factory = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, BROKER_URL);</span><br><span class="line">            // 通过工厂创建一个连接</span><br><span class="line">            connection = factory.createConnection();</span><br><span class="line">            // 启动连接</span><br><span class="line">            connection.start();</span><br><span class="line">            // 创建一个session会话</span><br><span class="line">            session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            // 创建一个消息队列</span><br><span class="line">            Destination destination = session.createQueue(DESTINATION);</span><br><span class="line">            // 创建消息制作者</span><br><span class="line">            MessageProducer producer = session.createProducer(destination);</span><br><span class="line">            // 设置持久化模式</span><br><span class="line">            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</span><br><span class="line">            sendMessage(session, producer);</span><br><span class="line">            // 提交会话</span><br><span class="line">            session.commit();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 关闭释放资源</span><br><span class="line">            if (session != null) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection != null) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MessageSender.run();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Queue方式"><a href="#Queue方式" class="headerlink" title="Queue方式"></a>Queue方式</h3><p><strong>消费者</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class QueueReceiver &#123;</span><br><span class="line">    // tcp 地址</span><br><span class="line">    public static final String BROKER_URL = &quot;tcp://localhost:61616&quot;;</span><br><span class="line">    // 目标，在ActiveMQ管理员控制台创建 http://localhost:8161/admin/queues.jsp</span><br><span class="line">    public static final String TARGET = &quot;test.queue&quot;;</span><br><span class="line">    public static void run() throws Exception &#123;</span><br><span class="line">        QueueConnection connection = null;</span><br><span class="line">        QueueSession session = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建链接工厂</span><br><span class="line">            QueueConnectionFactory factory = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, BROKER_URL);</span><br><span class="line">            // 通过工厂创建一个连接</span><br><span class="line">            connection = factory.createQueueConnection();</span><br><span class="line">            // 启动连接</span><br><span class="line">            connection.start();</span><br><span class="line">            // 创建一个session会话</span><br><span class="line">            session = connection.createQueueSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            // 创建一个消息队列</span><br><span class="line">            Queue queue = session.createQueue(TARGET);</span><br><span class="line">            // 创建消息制作者</span><br><span class="line">            javax.jms.QueueReceiver receiver = session.createReceiver(queue);</span><br><span class="line"></span><br><span class="line">            receiver.setMessageListener(new MessageListener() &#123; </span><br><span class="line">                public void onMessage(Message msg) &#123; </span><br><span class="line">                    if (msg != null) &#123;</span><br><span class="line">                        MapMessage map = (MapMessage) msg;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(map.getLong(&quot;time&quot;) + &quot;接收#&quot; + map.getString(&quot;text&quot;));</span><br><span class="line">                        &#125; catch (JMSException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;); </span><br><span class="line">            // 休眠100ms再关闭</span><br><span class="line">            Thread.sleep(1000 * 100); </span><br><span class="line">            // 提交会话</span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 关闭释放资源</span><br><span class="line">            if (session != null) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection != null) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        QueueReceiver.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>生产者</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class QueueSender &#123;</span><br><span class="line">    // 发送次数</span><br><span class="line">    public static final int SEND_NUM = 5;</span><br><span class="line">    // tcp 地址</span><br><span class="line">    public static final String BROKER_URL = &quot;tcp://localhost:61616&quot;;</span><br><span class="line">    // 目标，在ActiveMQ管理员控制台创建 http://localhost:8161/admin/queues.jsp</span><br><span class="line">    public static final String DESTINATION = &quot;test.queue&quot;;</span><br><span class="line">    public static void sendMessage(QueueSession session, javax.jms.QueueSender sender) throws Exception &#123;</span><br><span class="line">        for (int i = 0; i &lt; SEND_NUM; i++) &#123;</span><br><span class="line">            String message = &quot;发送消息第&quot; + (i + 1) + &quot;条&quot;;</span><br><span class="line"></span><br><span class="line">            MapMessage map = session.createMapMessage();</span><br><span class="line">            map.setString(&quot;text&quot;, message);</span><br><span class="line">            map.setLong(&quot;time&quot;, System.currentTimeMillis());</span><br><span class="line">            System.out.println(map);</span><br><span class="line"></span><br><span class="line">            sender.send(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void run() throws Exception &#123;</span><br><span class="line">        QueueConnection connection = null;</span><br><span class="line">        QueueSession session = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建链接工厂</span><br><span class="line">            QueueConnectionFactory factory = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, BROKER_URL);</span><br><span class="line">            // 通过工厂创建一个连接</span><br><span class="line">            connection = factory.createQueueConnection();</span><br><span class="line">            // 启动连接</span><br><span class="line">            connection.start();</span><br><span class="line">            // 创建一个session会话</span><br><span class="line">            session = connection.createQueueSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            // 创建一个消息队列</span><br><span class="line">            Queue queue = session.createQueue(DESTINATION);</span><br><span class="line">            // 创建消息发送者</span><br><span class="line">            javax.jms.QueueSender sender = session.createSender(queue);</span><br><span class="line">            // 设置持久化模式</span><br><span class="line">            sender.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</span><br><span class="line">            sendMessage(session, sender);</span><br><span class="line">            // 提交会话</span><br><span class="line">            session.commit();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 关闭释放资源</span><br><span class="line">            if (session != null) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection != null) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        QueueSender.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="topic方式"><a href="#topic方式" class="headerlink" title="topic方式"></a>topic方式</h3><p><strong>消费者</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class TopicReceiver &#123;</span><br><span class="line">    // tcp 地址</span><br><span class="line">    public static final String BROKER_URL = &quot;tcp://localhost:61616&quot;;</span><br><span class="line">    // 目标，在ActiveMQ管理员控制台创建 http://localhost:8161/admin/queues.jsp</span><br><span class="line">    public static final String TARGET = &quot;hoo.mq.topic&quot;;</span><br><span class="line"></span><br><span class="line">    public static void run() throws Exception &#123;</span><br><span class="line">        TopicConnection connection = null;</span><br><span class="line">        TopicSession session = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建链接工厂</span><br><span class="line">            TopicConnectionFactory factory = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, BROKER_URL);</span><br><span class="line">            // 通过工厂创建一个连接</span><br><span class="line">            connection = factory.createTopicConnection();</span><br><span class="line">            // 启动连接</span><br><span class="line">            connection.start();</span><br><span class="line">            // 创建一个session会话</span><br><span class="line">            session = connection.createTopicSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            // 创建一个消息队列</span><br><span class="line">            Topic topic = session.createTopic(TARGET);</span><br><span class="line">            // 创建消息制作者</span><br><span class="line">            TopicSubscriber subscriber = session.createSubscriber(topic);</span><br><span class="line"></span><br><span class="line">            subscriber.setMessageListener(new MessageListener() &#123; </span><br><span class="line">                public void onMessage(Message msg) &#123; </span><br><span class="line">                    if (msg != null) &#123;</span><br><span class="line">                        MapMessage map = (MapMessage) msg;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(map.getLong(&quot;time&quot;) + &quot;接收#&quot; + map.getString(&quot;text&quot;));</span><br><span class="line">                        &#125; catch (JMSException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;); </span><br><span class="line">            // 休眠100ms再关闭</span><br><span class="line">            Thread.sleep(1000 * 100); </span><br><span class="line">            // 提交会话</span><br><span class="line">            session.commit();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 关闭释放资源</span><br><span class="line">            if (session != null) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection != null) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        TopicReceiver.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>生产者</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class TopicSender &#123;</span><br><span class="line">    // 发送次数</span><br><span class="line">    public static final int SEND_NUM = 5;</span><br><span class="line">    // tcp 地址</span><br><span class="line">    public static final String BROKER_URL = &quot;tcp://localhost:61616&quot;;</span><br><span class="line">    // 目标，在ActiveMQ管理员控制台创建 http://localhost:8161/admin/queues.jsp</span><br><span class="line">    public static final String DESTINATION = &quot;hoo.mq.topic&quot;;</span><br><span class="line">    public static void sendMessage(TopicSession session, TopicPublisher publisher) throws Exception &#123;</span><br><span class="line">        for (int i = 0; i &lt; SEND_NUM; i++) &#123;</span><br><span class="line">            String message = &quot;发送消息第&quot; + (i + 1) + &quot;条&quot;;</span><br><span class="line"></span><br><span class="line">            MapMessage map = session.createMapMessage();</span><br><span class="line">            map.setString(&quot;text&quot;, message);</span><br><span class="line">            map.setLong(&quot;time&quot;, System.currentTimeMillis());</span><br><span class="line">            System.out.println(map);</span><br><span class="line"></span><br><span class="line">            publisher.send(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void run() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        TopicConnection connection = null;</span><br><span class="line">        TopicSession session = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建链接工厂</span><br><span class="line">            TopicConnectionFactory factory = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, BROKER_URL);</span><br><span class="line">            // 通过工厂创建一个连接</span><br><span class="line">            connection = factory.createTopicConnection();</span><br><span class="line">            // 启动连接</span><br><span class="line">            connection.start();</span><br><span class="line">            // 创建一个session会话</span><br><span class="line">            session = connection.createTopicSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            // 创建一个消息队列</span><br><span class="line">            Topic topic = session.createTopic(DESTINATION);</span><br><span class="line">            // 创建消息发送者</span><br><span class="line">            TopicPublisher publisher = session.createPublisher(topic);</span><br><span class="line">            // 设置持久化模式</span><br><span class="line">            publisher.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</span><br><span class="line">            sendMessage(session, publisher);</span><br><span class="line">            // 提交会话</span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 关闭释放资源</span><br><span class="line">            if (session != null) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection != null) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        TopicSender.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集成spring"><a href="#集成spring" class="headerlink" title="集成spring"></a>集成spring</h3><p><strong>引入jar包</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.14.1&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt; </span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;   </span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;activemq-spring&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.14.1&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>配置文件spring-context-activemq.xml：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot;  </span><br><span class="line">    xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot;  </span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans     </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd     </span><br><span class="line">        http://www.springframework.org/schema/context     </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context-4.0.xsd  </span><br><span class="line">        http://www.springframework.org/schema/jms  </span><br><span class="line">        http://www.springframework.org/schema/jms/spring-jms-4.0.xsd  </span><br><span class="line">        http://activemq.apache.org/schema/core  </span><br><span class="line">        http://activemq.apache.org/schema/core/activemq-core-5.14.1.xsd&quot;&gt; </span><br><span class="line">        &lt;description&gt;spring-activeMQ&lt;/description&gt;</span><br><span class="line">    &lt;!-- 获取ActiveMQ提供的ConnectionFactory --&gt;</span><br><span class="line">    &lt;amq:connectionFactory id=&quot;amqConnectionFactory&quot; brokerURL=&quot;tcp://127.0.0.1:61616&quot; userName=&quot;admin&quot; password=&quot;admin&quot;&gt;&lt;/amq:connectionFactory&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- spring连接activeMQ的conneciotnFactory --&gt; </span><br><span class="line">    &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;amqConnectionFactory&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;property name=&quot;sessionCacheSize&quot; value=&quot;100&quot; /&gt;  </span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义JmsTemplate的Queue类型 --&gt;</span><br><span class="line">    &lt;bean id=&quot;jmsQueueTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;  </span><br><span class="line">        &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;    </span><br><span class="line">        &lt;constructor-arg ref=&quot;connectionFactory&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;!-- 非pub/sub模型（发布/订阅），即队列模式 --&gt;  </span><br><span class="line">        &lt;property name=&quot;pubSubDomain&quot; value=&quot;false&quot; /&gt;  </span><br><span class="line">    &lt;/bean&gt; </span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义JmsTemplate的Topic类型 --&gt;  </span><br><span class="line">    &lt;bean id=&quot;jmsTopicTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;  </span><br><span class="line">        &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;    </span><br><span class="line">        &lt;constructor-arg ref=&quot;connectionFactory&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;!-- pub/sub模型（发布/订阅） --&gt;  </span><br><span class="line">        &lt;property name=&quot;pubSubDomain&quot; value=&quot;true&quot; /&gt;  </span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;queueReceiver&quot; class=&quot;com.drink.modules.activemq.QueueReceiver&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!-- 定义Queue监听器 --&gt;  </span><br><span class="line">    &lt;jms:listener-container destination-type=&quot;queue&quot; container-type=&quot;default&quot; connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;auto&quot;&gt;  </span><br><span class="line">        &lt;jms:listener destination=&quot;test.queue&quot; ref=&quot;queueReceiver&quot;/&gt;  </span><br><span class="line">    &lt;/jms:listener-container&gt;  </span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;topicReceiver&quot; class=&quot;com.drink.modules.activemq.TopicReceiver&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!-- 定义Topic监听器 --&gt;  </span><br><span class="line">    &lt;jms:listener-container destination-type=&quot;topic&quot; container-type=&quot;default&quot; connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;auto&quot;&gt;  </span><br><span class="line">        &lt;jms:listener destination=&quot;test.topic&quot; ref=&quot;topicReceiver&quot;/&gt;  </span><br><span class="line">    &lt;/jms:listener-container&gt;               </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>Queue消费者</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class QueueReceiver implements MessageListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Message message) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            System.out.println(&quot;QueueReceiver接收到消息：&quot;+((TextMessage)message).getText());</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Topic消费者:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TopicReceiver implements MessageListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Message message) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;TopicReceiver接收到消息：&quot;+((TextMessage)message).getText());</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Queue生产者：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;queueSender&quot;) </span><br><span class="line">public class QueueSender &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;jmsQueueTemplate&quot;)</span><br><span class="line">    private JmsTemplate jmsTemplate; </span><br><span class="line"></span><br><span class="line">    public void send(String queueName, final String message)&#123;</span><br><span class="line">        jmsTemplate.send(queueName,new MessageCreator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Message createMessage(Session session) throws JMSException &#123;</span><br><span class="line">                return session.createTextMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Topic生产者：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;topicSender&quot;)</span><br><span class="line">public class TopicSender &#123;</span><br><span class="line">    @Autowired  </span><br><span class="line">    @Qualifier(&quot;jmsTopicTemplate&quot;)  </span><br><span class="line">    private JmsTemplate jmsTemplate; </span><br><span class="line">    public void send(String queueName, final String message)&#123;</span><br><span class="line">        jmsTemplate.send(queueName,new MessageCreator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Message createMessage(Session session) throws JMSException &#123;</span><br><span class="line">                return session.createTextMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="持久化到数据配置"><a href="#持久化到数据配置" class="headerlink" title="持久化到数据配置"></a>持久化到数据配置</h3><p>在mysql中手动创建一个名称为activemq的数据库，注意编码格式。<br>将mysql驱动的jar包拷贝到apache-activemq-5.14.1\lib目录下<br>修改conf下的activemq.xml文件<br>将默认的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jdbcPersistenceAdapter dataSource=&quot;#mysql-ds&quot; createTablesOnStartup=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--createTablesOnStartup首次启动创建表时设置为true，其余情况改为false--&gt;</span><br><span class="line">&lt;jdbcPersistenceAdapter dataSource=&quot;#mysql-ds&quot; createTablesOnStartup=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>在broker节点后添加数据源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;mysql-ds&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">&lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; </span><br><span class="line">&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/activemq&quot;/&gt; </span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; </span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; </span><br><span class="line">&lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意:这里的版本是5.14.1,dbcp的包是commons-dbcp2-2.1.1.jar，所以这里的class为org.apache.commons.dbcp2.BasicDataSource，<br>低版本的MQ配置为org.apache.commons.dbcp.BasicDataSource</strong><br>首次启动后就会看到数据库的创建的三张表 </p>
<p>编码中发送者需要设置持久化的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建消息发送者</span><br><span class="line">      javax.jms.QueueSender sender = session.createSender(queue);</span><br><span class="line">      // 设置持久化模式</span><br><span class="line">      sender.setDeliveryMode(DeliveryMode.PERSISTENT);</span><br></pre></td></tr></table></figure></p>
<p>spring中在JmsTemplate模板配置中设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;jmsQueueTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;  </span><br><span class="line">    &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;    </span><br><span class="line">    &lt;constructor-arg ref=&quot;connectionFactory&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;!-- 非pub/sub模型（发布/订阅），即队列模式 --&gt;  </span><br><span class="line">    &lt;property name=&quot;pubSubDomain&quot; value=&quot;false&quot; /&gt;  </span><br><span class="line">    &lt;!--1为非持久化，2为持久化--&gt;</span><br><span class="line">    &lt;property name=&quot;deliveryMode&quot; value=&quot;2&quot; /&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> activeMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[注解]]></title>
      <url>/%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#注解的应用结构图">注解的应用结构图</a></li>
<li><a href="#元注解">元注解</a></li>
<li><a href="#自定义注解">自定义注解</a></li>
<li><a href="#示例代码">示例代码</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<hr>
<p>注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p>
<p>API</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/package-summary.html" target="_blank" rel="external">Package java.lang.annotation</a></p>
</blockquote>
<h2 id="注解的应用结构图"><a href="#注解的应用结构图" class="headerlink" title="注解的应用结构图"></a>注解的应用结构图</h2><p>调用/结构关系：<strong>A&lt;–B&lt;–C</strong></p>
<p>A,B,C解释如下：</p>
<p>A:注解类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> A&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B:应用了“注解类”的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@A</span></span><br><span class="line">Class B&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C:对“应用了注解类的类”进行反射操作的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class C&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">     B.class.isAnnotationPresent(A.class);</span><br><span class="line">     A a = B.class.getAnnotion(A.class);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解的作用就是负责注解其他注解。四个元注解分别是：<code>@Target,@Retention,@Documented,@Inherited</code></p>
<ul>
<li><code>@Retention</code></li>
</ul>
<p>表示在什么级别保存该注解信息。可选的参数值在枚举类型 <code>RetentionPolicy</code>中，包括<code>RetentionPolicy.SOURCE</code>,<code>RetentionPolicy.CLASS</code>(默认),<code>RetentionPolicy.RUNTIME</code>分别对应：java源文件–&gt;class文件–&gt;内存中的字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RetentionPolicy.SOURCE 注解将被编译器丢弃 </span><br><span class="line">RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃</span><br><span class="line">RetentionPolicy.RUNTIME VM将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@Target</code></li>
</ul>
<p>表示该注解用于什么地方，可能的值在枚举类<code>ElemenetType</code>中,包括</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ElemenetType.CONSTRUCTOR 构造器声明 </span><br><span class="line">ElemenetType.FIELD 域声明（包括 enum 实例） </span><br><span class="line">ElemenetType.LOCAL_VARIABLE 局部变量声明 </span><br><span class="line">ElemenetType.METHOD 方法声明 </span><br><span class="line">ElemenetType.PACKAGE 包声明 </span><br><span class="line">ElemenetType.PARAMETER 参数声明 </span><br><span class="line">ElemenetType.TYPE 类，接口（包括注解类型）或enum声明</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@Documented</code></li>
</ul>
<p>将此注解包含在javadoc中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当于<code>@see,@param</code>等</p>
<ul>
<li><code>@Inherited</code></li>
</ul>
<p>允许子类继承父类中的注解</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p><strong>使用<code>@interface</code>自定义注解时，自动继承了<code>java.lang.annotation.Annotation</code>接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。<code>@interface</code>用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</strong></p>
<p>定义注解格式：</p>
<p><code>public @interface 注解名 {定义体}</code></p>
<p>注解参数的可支持数据类型：</p>
<p>1.所有基本数据类型(int,float,boolean,byte,double,char,long,short)<br>2.String类型<br>3.Class类型<br>4.enum类型<br>5.Annotation类型<br>6.以上所有类型的数组</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>参考文末的<a href="#参考资料">【参考资料】</a>中<a href="http://blog.csdn.net/tigerdsh/article/details/8848890" target="_blank" rel="external">《java 注解的几大作用及使用方法详解（完）》</a></p>
<p>下面的示例，是上文提到的<strong>A&lt;–B&lt;–C</strong>的扩充版本。自定义了一个注解<code>@A</code>，然后在B类中使用了注解<code>@A</code>,最后在类C中利用反射读取<code>@A</code>中的信息</p>
<ul>
<li><code>A.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD,ElementType.CONSTRUCTOR&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> A &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">Class&lt;Long&gt; <span class="title">gid</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>B.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@A</span>(name=<span class="string">"type"</span>,gid=Long.class)<span class="comment">//类注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@A</span>(name=<span class="string">"param"</span>,id=<span class="number">1</span>,gid=Long.class) <span class="comment">//类成员注解</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@A</span>(name=<span class="string">"construct"</span>,id=<span class="number">2</span>,gid=Long.class) <span class="comment">//构造方法注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@A</span>(name=<span class="string">"public method"</span>,id=<span class="number">3</span>,gid=Long.class) <span class="comment">//类方法注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@A</span>(name=<span class="string">"protected method"</span>,id=<span class="number">4</span>,gid=Long.class) <span class="comment">//类方法注解</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; m = <span class="keyword">new</span> HashMap&lt;String,String&gt;(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@A</span>(name=<span class="string">"private method"</span>,id=<span class="number">5</span>,gid=Long.class) <span class="comment">//类方法注解</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; m = <span class="keyword">new</span> HashMap&lt;String,String&gt;(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(Integer a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>C.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单打印出B类中所使用到的类注解</span></span><br><span class="line"><span class="comment">     * 该方法只打印了 Type 类型的注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseTypeAnnotation</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.iot.annotation.B"</span>);</span><br><span class="line"></span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annotation :annotations)&#123;</span><br><span class="line">            A a = (A)annotation;</span><br><span class="line">            System.out.println(<span class="string">"id = "</span>+a.id()+<span class="string">" ;name = "</span>+a.name()+<span class="string">" ;gid = "</span>+a.gid());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单打印出B类中所使用到的方法注解</span></span><br><span class="line"><span class="comment">     * 该方法只打印了 Method 类型的注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Method[] methods = B.class.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 判断方法中是否有指定注解类型的注解</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">boolean</span> hasAnnotation = method.isAnnotationPresent(A.class);</span><br><span class="line">            <span class="keyword">if</span> (hasAnnotation) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 根据注解类型返回方法的指定类型注解</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                A annotation = method.getAnnotation(A.class);</span><br><span class="line">                System.out.println(<span class="string">"method = "</span> + method.getName()</span><br><span class="line">                        + <span class="string">" ; id = "</span> + annotation.id() + <span class="string">" ; description = "</span></span><br><span class="line">                        + annotation.name() + <span class="string">"; gid= "</span> + annotation.gid());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单打印出B类中所使用到的方法注解</span></span><br><span class="line"><span class="comment">     * 该方法只打印了 Method 类型的注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseConstructAnnotation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Constructor[] constructors = B.class.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">        	<span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 判断构造方法中是否有指定注解类型的注解</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">boolean</span> hasAnnotation = constructor.isAnnotationPresent(A.class);</span><br><span class="line">            <span class="keyword">if</span> (hasAnnotation) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 根据注解类型返回方法的指定类型注解</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                A annotation =(A) constructor.getAnnotation(A.class);</span><br><span class="line">                System.out.println(<span class="string">"constructor = "</span> + constructor.getName()</span><br><span class="line">                        + <span class="string">" ; id = "</span> + annotation.id() + <span class="string">" ; description = "</span></span><br><span class="line">                        + annotation.name() + <span class="string">"; gid= "</span>+annotation.gid());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        parseTypeAnnotation();</span><br><span class="line">        parseMethodAnnotation();</span><br><span class="line">        parseConstructAnnotation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="http://blog.csdn.net/tigerdsh/article/details/8848890" target="_blank" rel="external">java 注解的几大作用及使用方法详解（完）</a></li>
<li><a href="http://strong-life-126-com.iteye.com/blog/806246" target="_blank" rel="external">另类的package-info.java文件探讨</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html" target="_blank" rel="external">深入理解Java：注解（Annotation）自定义注解入门</a></li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaSE 语法]]></title>
      <url>/javaSE%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-Java-有没有-goto-语句？"><a href="#1-Java-有没有-goto-语句？" class="headerlink" title="1. Java 有没有 goto 语句？"></a>1. Java 有没有 goto 语句？</h2><blockquote>
<p>goto 是 Java 中的保留字，在目前版本的Java中没有使用。根据James Gosling（Java<br>之父）编写的《TheJavaProgrammingLanguage》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字</p>
</blockquote>
<hr>
<h2 id="2-amp-和-amp-amp-的区别"><a href="#2-amp-和-amp-amp-的区别" class="headerlink" title="2. &amp; 和 &amp;&amp; 的区别"></a>2. &amp; 和 &amp;&amp; 的区别</h2><blockquote>
<p>&amp;和&amp;&amp;都可以用作逻辑运算符，表示逻辑与。当运算符两边的表达式都为true时，结果才为true；否则，结果为false。<br>另外&amp;&amp;还具有短路功能，也就是说，当&amp;&amp;左边的表达式结果为false时，将不再运算&amp;&amp;右边的表达式，结果肯定为false。例如，对于if(str!=null&amp;&amp;!str.equals(“”)),当str为null时，不会对&amp;&amp;右边的表达式进行运算，否则会出现空指针异常。<br>&amp;还可以用作位运算符，当&amp;两边的表达式不是boolean类型时，&amp;表示按位与。</p>
</blockquote>
<hr>
<h2 id="3-在-Java-中，如何跳出当前的多重嵌套循环"><a href="#3-在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="3.在 Java 中，如何跳出当前的多重嵌套循环"></a>3.在 Java 中，如何跳出当前的多重嵌套循环</h2><p>在java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的的break语句，即可跳出外层循环。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ok:</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">     system.out.println(<span class="string">"i="</span>+i+<span class="string">",j="</span>+j);</span><br><span class="line">     <span class="keyword">if</span>(j==<span class="number">5</span>)<span class="keyword">break</span> ok;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，我个人觉得通常不使用标号这种方式，而是让外层的循环条件表达式的结果可以收到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int arr[][]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>&#125;,&#123;<span class="number">4</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">boolean found =false;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;arr.length&amp;&amp;!found;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;arr[i].length;j++)</span><br><span class="line">&#123;</span><br><span class="line">    system.out.println(<span class="string">"i="</span>+i+<span class="string">",j="</span>+j);</span><br><span class="line">    <span class="keyword">if</span>(arr[i][j]==<span class="number">5</span>)</span><br><span class="line">&#123;     </span><br><span class="line">    found=true;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>break和continue的区别？</strong><br>break是结束整个循环体，continue是结束单次循环（跳出当前循环，到下一步）。<br>例子1：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x++ &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%d\r\n"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">结果是输出  <span class="number">1</span> <span class="number">2</span>   就退出了整个<span class="keyword">while</span>循环</span><br><span class="line">但是如果使用<span class="keyword">continue</span></span><br><span class="line"><span class="keyword">while</span>(x++ &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%d\r\n"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">结果是：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>  可见他仅仅是不输出<span class="number">3</span>，因为他结束了本次循环</span><br></pre></td></tr></table></figure></p>
<p><strong>return和 break区别</strong></p>
<blockquote>
<p>break语句虽然可以独立使用，但通常主要用于switch语句中，控制程序的执行流程转移。<br>在switch语句中，其作用是强制退出switch结构，执行switch结构之后的语句。其本质就是在单层循环结构体系中，其作用是强制退出循环结构。<br>return语句用来明确地从一个方法返回。也就是，return<br>语句使程序控制返回到调用它方法。因此，将它分类为跳转语句.有两个作用，一个是返回方法指定类型的值（这个值总是确定的）；一个是结束方法的执行（仅仅一个return语句）。return语句可以使其从当前方法中退出，返回到调用该方法的语句处，继续程序的执行 。</p>
</blockquote>
<hr>
<h2 id="4-两个对象值相同-x-equals-y-true-，但却可有不同的-hashCode，这句话对不对？"><a href="#4-两个对象值相同-x-equals-y-true-，但却可有不同的-hashCode，这句话对不对？" class="headerlink" title="4. 两个对象值相同 (x.equals(y) == true) ，但却可有不同的 hashCode，这句话对不对？"></a>4. 两个对象值相同 (x.equals(y) == true) ，但却可有不同的 hashCode，这句话对不对？</h2><blockquote>
<p>不对，如果两个对象x和y满足x.equals(y)==true，它们的哈希码（hash<br>code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。<br><strong>补充</strong>：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective<br>Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1.<br>使用==操作符检查”参数是否为这个对象的引用”；2. 使用instanceof操作符检查”参数是否为正确的类型”；3.<br>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5.<br>重写equals时总是要重写hashCode；6.<br>不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。</p>
</blockquote>
<hr>
<h2 id="5-是否可以继承-String"><a href="#5-是否可以继承-String" class="headerlink" title="5. 是否可以继承 String"></a>5. 是否可以继承 String</h2><p>String 类是 final 类，不可以被继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>继承 String<br>本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（UseA）而不是继承关系（Is-A）。</p>
</blockquote>
<hr>
<h2 id="6-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#6-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="6. 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>6. 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h2><blockquote>
<p>答:是值传递。Java编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用一个副本。指向同一个对象,对象的内容可以在被调用的方法中改变，但对象的引用(不是引用的副本)是永远不会改变的。</p>
<p>按值传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的一个副本。因此，如果函数修改了该参数，仅改变副本，而原始值保持不变。按引用传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的内存地址，而不是值的副本。因此，如果函数修改了该参数的值，调用代码中的原始值也随之改变。如果函数修改了该参数的地址,调用代码中的原始值不会改变.<br><strong>在 Java应用程序中，当对象引用是传递给方法的一个参数时，您传递的是该引用的一个副本（按值传递），而不是引用本身。</strong></p>
</blockquote>
<hr>
<h2 id="7-重载（overload）和重写（override）的区别？重载的方法能否根据返回类型进行区分？"><a href="#7-重载（overload）和重写（override）的区别？重载的方法能否根据返回类型进行区分？" class="headerlink" title="7.重载（overload）和重写（override）的区别？重载的方法能否根据返回类型进行区分？"></a>7.重载（overload）和重写（override）的区别？重载的方法能否根据返回类型进行区分？</h2><blockquote>
<p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p>
</blockquote>
<p><strong>方法重载的规则：</strong></p>
<blockquote>
<p>1.方法名一致，参数列表中参数的顺序，类型，个数不同。<br>2.重载与方法的返回值无关，存在于父类和子类，同类中。<br>3.可以抛出不同的异常，可以有不同修饰符。</p>
</blockquote>
<p><strong>方法重写的规则：</strong></p>
<blockquote>
<p>1.参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。<br>2.构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，但是能够被再次声明。<br>3.访问权限不能比父类中被重写的方法的访问权限更低。<br>4.重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以</p>
</blockquote>
<hr>
<h2 id="8-为什么函数不能根据返回类型来区分重载？"><a href="#8-为什么函数不能根据返回类型来区分重载？" class="headerlink" title="8. 为什么函数不能根据返回类型来区分重载？"></a>8. 为什么函数不能根据返回类型来区分重载？</h2><p>该道题来自华为面试题。<br>因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float max(int a, int b);</span><br><span class="line">int max(int a, int b);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当调用 max(1, 2);时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的</p>
</blockquote>
<p>再比如对下面这两个方法来说，虽然它们有同样的名字和自变量，但其实是很容易区分的：</p>
<pre><code>void f() {} 
int f() {} 
</code></pre><blockquote>
<p>若编译器可根据上下文（语境）明确判断出含义，比如在intx=f()中，那么这样做完全没有问题。然而，我们也可能调用一个方法，同时忽略返回值；我们通常把这称为“为它的副作用去调用一个方法”，因为我们关心的不是返回值，而是方法调用的其他效果。所以假如我们像下面这样调用方法：f();Java怎样判断f()的具体调用方式呢？而且别人如何识别并理解代码呢？由于存在这一类的问题，所以不能。<br><strong>函数的返回值只是作为函数运行之后的一个“状态”，他是保持方法的调用者与被调用者进行通信的关键。并不能作为某个方法的“标识”。</strong></p>
</blockquote>
<hr>
<h2 id="9-char-型变量中能不能存储一个中文汉字，为什么？"><a href="#9-char-型变量中能不能存储一个中文汉字，为什么？" class="headerlink" title="9. char 型变量中能不能存储一个中文汉字，为什么？"></a>9. char 型变量中能不能存储一个中文汉字，为什么？</h2><blockquote>
<p>char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。<br><strong>补充：</strong>使用 Unicode意味着字符在JVM内部和外部有不同的表现形式，在 JVM 内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader 和 OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。</p>
</blockquote>
<h2 id="10-抽象类-abstract-class-和接口-interface-有什么异同？"><a href="#10-抽象类-abstract-class-和接口-interface-有什么异同？" class="headerlink" title="10. 抽象类(abstract class)和接口(interface)有什么异同？"></a>10. 抽象类(abstract class)和接口(interface)有什么异同？</h2><p><strong>不同：</strong></p>
<blockquote>
<p><strong>抽象类：</strong><br>1.抽象类中可以定义构造器<br>2.可以有抽象方法和具体方法<br>3.接口中的成员全都是 public 的<br>4.抽象类中可以定义成员变量<br>5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法<br>6.抽象类中可以包含静态方法<br>7.一个类只能继承一个抽象类<br><strong>接口：</strong><br>1.接口中不能定义构造器<br>2.方法全部都是抽象方法<br>3.抽象类中的成员可以是 private、默认、protected、public<br>4.接口中定义的成员变量实际上都是常量<br>5.接口中不能有静态方法<br>6.一个类可以实现多个接口</p>
</blockquote>
<p><strong>相同：</strong></p>
<blockquote>
<p>1.不能够实例化<br>2.可以将抽象类和接口类型作为引用类型<br>3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要 被声明为抽象类</p>
</blockquote>
<hr>
<h2 id="11-抽象的-abstract-方法是否可同时是静态的-static-是否可同时是本地方法-native-，是否可同时被-synchronized"><a href="#11-抽象的-abstract-方法是否可同时是静态的-static-是否可同时是本地方法-native-，是否可同时被-synchronized" class="headerlink" title="11.抽象的(abstract)方法是否可同时是静态的(static),是否可同时是本地方法(native)，是否可同时被 synchronized"></a>11.抽象的(abstract)方法是否可同时是静态的(static),是否可同时是本地方法(native)，是否可同时被 synchronized</h2><blockquote>
<p>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p>
</blockquote>
<hr>
<h2 id="12-阐述静态变量和实例变量的区别？"><a href="#12-阐述静态变量和实例变量的区别？" class="headerlink" title="12. 阐述静态变量和实例变量的区别？"></a>12. 阐述静态变量和实例变量的区别？</h2><blockquote>
<p><strong>静态变量:</strong> 是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；<br><strong>实例变量:</strong> 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p>
</blockquote>
<hr>
<h2 id="13-和-equals-的区别？"><a href="#13-和-equals-的区别？" class="headerlink" title="13. ==和 equals 的区别？"></a>13. ==和 equals 的区别？</h2><blockquote>
<p><strong>equals 和== 最大的区别是一个是方法一个是运算符。</strong><br>==：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等<br><strong>equals()：</strong>用来比较方法两个对象的内容是否相等。</p>
</blockquote>
<p>注意：equals 方法不能用于基本数据类型的变量，如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址。</p>
<hr>
<h2 id="14-break-和-continue-的区别？"><a href="#14-break-和-continue-的区别？" class="headerlink" title="14. break 和 continue 的区别？"></a>14. break 和 continue 的区别？</h2><blockquote>
<p>break 和 continue 都是用来控制循环的语句。 break 用于完全结束一个循环，跳出循环体执行循环后面的语句。<br>continue 用于跳过本次循环，执行下次循环。</p>
</blockquote>
<hr>
<h2 id="15-String-s-”Hello”-s-s-”world-”-这两行代码执行后，原始的-String-对象中的内容到底变了没有？"><a href="#15-String-s-”Hello”-s-s-”world-”-这两行代码执行后，原始的-String-对象中的内容到底变了没有？" class="headerlink" title="15. String s =”Hello”;s=s+”world!”;这两行代码执行后，原始的 String 对象中的内容到底变了没有？"></a>15. String s =”Hello”;s=s+”world!”;这两行代码执行后，原始的 String 对象中的内容到底变了没有？</h2><blockquote>
<p><strong>没有。</strong>因为 String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是”Hello”，然后我们对s进行了“+”操作，那么s所指向的那个对象是否发生了改变呢？<br>答案是没有。这时，s不指向原来那个对象了，而指向了另一个String对象，内容为”Helloworld!”，原来那个对象还存在于内存之中，只是 s 这个引用变量不再指向它了.<br>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。例如我们要在构造器中对一个名叫 s的 String 引用变量进行初始化，把它设置为初始值，应当这样做</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line"> private String s;</span><br><span class="line"> ...</span><br><span class="line"> s = &quot;Initial Value&quot;;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">而非</span><br><span class="line">s = new String(&quot;Initial Value&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的 String类型属性s都指向同一个对象。<br>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java 认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。 至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只String，很多 Java 标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以 Java 标准类库还提供了一个可变版本，即 StringBuffer;</p>
</blockquote>
<hr>
<h2 id="16-StringBuffer和StringBuilder的区别"><a href="#16-StringBuffer和StringBuilder的区别" class="headerlink" title="16.StringBuffer和StringBuilder的区别"></a>16.StringBuffer和StringBuilder的区别</h2><p><strong>区别:</strong></p>
<blockquote>
<p>1、StringBuffer 与 StringBuilder中的方法和功能完全是等价的，<br>2、只是StringBuffer中的方法大都采用了synchronized关键字进行修饰，因此是线程安全的，而StringBuilder没有这个修饰，可以被认为是线程不安全的。<br>3、在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低</p>
</blockquote>
<hr>
<h2 id="17-Object的方法有哪些：比如有wait方法，为什么会有"><a href="#17-Object的方法有哪些：比如有wait方法，为什么会有" class="headerlink" title="17.Object的方法有哪些：比如有wait方法，为什么会有?"></a>17.Object的方法有哪些：比如有wait方法，为什么会有?</h2><blockquote>
<p>1．clone方法<br>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。<br>2．getClass方法<br>final方法，获得运行时类型。<br>3．toString方法<br>该方法用得比较多，一般子类都有覆盖。<br>4．finalize方法<br>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。<br>5．equals方法<br>该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。<br>6．hashCode方法<br>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。<br>一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。<br>7．wait方法<br>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br>调用该方法后当前线程进入睡眠状态，直到以下事件发生。<br>（1）其他线程调用了该对象的notify方法。<br>（2）其他线程调用了该对象的notifyAll方法。<br>（3）其他线程调用了interrupt中断该线程。<br>（4）时间间隔到了。<br>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。<br>8．notify方法<br>该方法唤醒在该对象上等待的某个线程。<br>9．notifyAll方法<br>该方法唤醒在该对象上等待的所有线程<br><strong>注意：wait(),notify(),notifyAll()都必须使用在同步中，因为要对持有监视器(锁)的线程操作。所以要使用在同步中，因为只有同步 才具有锁。</strong></p>
</blockquote>
<p><strong>为什么这些操作线程的方法要定义在object类中呢？</strong></p>
<blockquote>
<p>简单说：因为synchronized中的这把锁可以是任意对象，所以任意对象都可以调用wait()和notify()；所以wait和notify属于Object。</p>
<p>专业说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒，不可以对不同锁中的线程进行唤醒。</p>
<p>也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在object类中。</p>
</blockquote>
<hr>
<h2 id="18-wait和sleep的区别"><a href="#18-wait和sleep的区别" class="headerlink" title="18.wait和sleep的区别?"></a>18.wait和sleep的区别?</h2><p><strong>1、两者的区别</strong></p>
<ul>
<li>这两个方法来自不同的类分别是Thread和Object</li>
<li>最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法(锁代码块和方法锁)。</li>
<li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用(使用范围)</li>
<li>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</li>
<li>sleep方法属于Thread类中方法，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态，因为线程调度机制恢复线程的运行也需要时间，一个线程对象调用了sleep方法之后，并不会释放他所持有的所有对象锁，所以也就不会影响其他进程对象的运行。但在sleep的过程中过程中有可能被其他对象调用它的interrupt(),产生InterruptedException异常，如果你的程序不捕获这个异常，线程就会异常终止，进入TERMINATED状态，如果你的程序捕获了这个异常，那么程序就会继续执行catch语句块(可能还有finally语句块)以及以后的代码。</li>
<li>注意sleep()方法是一个静态方法，也就是说他只对当前对象有效，通过t.sleep()让t对象进入sleep，这样的做法是错误的，它只会是使当前线程被sleep而不是t线程</li>
<li>wait属于Object的成员方法，一旦一个对象调用了wait方法，必须要采用notify()和notifyAll()方法唤醒该进程;如果线程拥有某个或某些对象的同步锁，那么在调用了wait()后，这个线程就会释放它持有的所有同步资源，而不限于这个被调用了wait()方法的对象。wait()方法也同样会在wait的过程中有可能被其他对象调用interrupt()方法而产生</li>
</ul>
<blockquote>
<p>如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep/join，则线程B立刻抛出InterruptedException，在catch(){}中直接return即可安全地结束线程。<br>需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到wait()/sleep()/join()后，就会立刻抛出InterruptedException。</p>
</blockquote>
<p>补充两个重要的方法：<strong>yield()和join()</strong></p>
<blockquote>
<p>yield()方法是停止当前线程，让同等优先权的线程或更高优先级的线程有执行的机会。如果没有的话，那么yield()方法将不会起作用，并且由可执行状态后马上又被执行。<br>—————···········————-<br>join方法是用于在某一个线程的执行过程中调用另一个线程执行，等到被调用的线程执行结束后，再继续执行当前线程。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</p>
</blockquote>
<hr>
<h2 id="19-Java关键字之static、final、transient"><a href="#19-Java关键字之static、final、transient" class="headerlink" title="19.Java关键字之static、final、transient"></a>19.Java关键字之static、final、transient</h2><p>  <strong>static关键字</strong></p>
<pre><code>static关键字，通常用来修饰变量和方法以及静态代码块。被修饰的变量表示为类所有对象所共有的，被修饰的方法表示类的方法。
掌握好static关键字很重要一点就是，static的作用域是类而非某个具体对象。
</code></pre><p><strong>final关键字</strong></p>
<pre><code>final关键字意思就是表示不可变，理解不可变这一点就很容易掌握final关键字的使用了。
</code></pre><p><strong>transient关键字</strong></p>
<pre><code>transient关键字在日常开发中并没有像前面两个关键字用的那么频繁，在很少场合下使用。
transient表示瞬态、临时的，其不能序列化到文件中。
</code></pre><hr>
<h2 id="20-foreach实现原理"><a href="#20-foreach实现原理" class="headerlink" title="20.foreach实现原理"></a>20.foreach实现原理</h2><p>Java.util.List实现了java.lang.Iterable接口.<br>jdk api文档中是这样描述Iterable接口的：<strong>实现这个接口允许对象成为 “foreach”语句的目标</strong>。不过咋一看Iterable接口并没啥特别之处，只是定义了一个迭代器而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * Returns an iterator over a set of elements of type T. </span><br><span class="line">     *  </span><br><span class="line">     * @return an Iterator. </span><br><span class="line">     */  </span><br><span class="line">    Iterator&lt;T&gt; iterator();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>究竟是如何实现foreach的呢，想想可能是编译器做了优化，就看了下最终编译成的字节码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Iterable_eros &#123;  </span><br><span class="line">      </span><br><span class="line">    List&lt;String&gt; strings;  </span><br><span class="line">  </span><br><span class="line">    public void display()&#123;  </span><br><span class="line">        for(String s : strings)&#123;  </span><br><span class="line">            System.out.println(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相应的字节码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void display ()&#123;  </span><br><span class="line">line0    : aload_0    </span><br><span class="line">           getfield  java.util.List my.lang.Iterable_eros.strings  </span><br><span class="line">           invokeinterface  java.util.Iterator java.util.List.iterator() 1  </span><br><span class="line">           astore_2    </span><br><span class="line">           goto  line30  </span><br><span class="line">line13   : aload_2    </span><br><span class="line">           invokeinterface  java.lang.Object java.util.Iterator.next() 1  </span><br><span class="line">           checkcast  java.lang.String  </span><br><span class="line">           astore_1    </span><br><span class="line">line23   : getstatic  java.io.PrintStream java.lang.System.out  </span><br><span class="line">           aload_1    </span><br><span class="line">line27   : invokevirtual  void java.io.PrintStream.println(java.lang.String)  </span><br><span class="line">line30   : aload_2    </span><br><span class="line">           invokeinterface  boolean java.util.Iterator.hasNext() 1  </span><br><span class="line">           ifne  line13  </span><br><span class="line">line39   : return</span><br></pre></td></tr></table></figure></p>
<p>果然没猜错哈！可以看到，foreach语法最终被编译器转为了对<strong>Iterator.next()</strong>的调用。而作为使用者的我们， jdk并没用向我们暴露这些细节，我们甚至不需要知道Iterator的存在，认识到jdk的强大之处了吧。</p>
<p>为了证实自己的想法，用Iterator写了个遍历List的方法查看了字节码，果然跟foreach的形式基本一样，当然这是后话~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void display()&#123;  </span><br><span class="line">        for(String s : strings)&#123;  </span><br><span class="line">            System.out.println(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        Iterator&lt;String&gt; iterator = strings.iterator();  </span><br><span class="line">        while(iterator.hasNext())&#123;  </span><br><span class="line">            String s = iterator.next();  </span><br><span class="line">            System.out.println(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void display ()&#123;  </span><br><span class="line">line0    : aload_0    </span><br><span class="line">           getfield  java.util.List my.lang.Iterable_eros.strings  </span><br><span class="line">           invokeinterface  java.util.Iterator java.util.List.iterator() 1  </span><br><span class="line">           astore_2    </span><br><span class="line">           goto  line30  </span><br><span class="line">line13   : aload_2    </span><br><span class="line">           invokeinterface  java.lang.Object java.util.Iterator.next() 1  </span><br><span class="line">           checkcast  java.lang.String  </span><br><span class="line">           astore_1    </span><br><span class="line">line23   : getstatic  java.io.PrintStream java.lang.System.out  </span><br><span class="line">           aload_1    </span><br><span class="line">line27   : invokevirtual  void java.io.PrintStream.println(java.lang.String)  </span><br><span class="line">line30   : aload_2    </span><br><span class="line">           invokeinterface  boolean java.util.Iterator.hasNext() 1  </span><br><span class="line">           ifne  line13  </span><br><span class="line">           aload_0    </span><br><span class="line">           getfield  java.util.List my.lang.Iterable_eros.strings  </span><br><span class="line">           invokeinterface  java.util.Iterator java.util.List.iterator() 1  </span><br><span class="line">           astore_1    </span><br><span class="line">line49   : goto  line69  </span><br><span class="line">line52   : aload_1    </span><br><span class="line">           invokeinterface  java.lang.Object java.util.Iterator.next() 1  </span><br><span class="line">           checkcast  java.lang.String  </span><br><span class="line">           astore_2    </span><br><span class="line">line62   : getstatic  java.io.PrintStream java.lang.System.out  </span><br><span class="line">           aload_2    </span><br><span class="line">line66   : invokevirtual  void java.io.PrintStream.println(java.lang.String)  </span><br><span class="line">line69   : aload_1    </span><br><span class="line">           invokeinterface  boolean java.util.Iterator.hasNext() 1  </span><br><span class="line">           ifne  line52  </span><br><span class="line">line78   : return</span><br></pre></td></tr></table></figure>
<p>这边还发现一个比较有趣的现象：在取Iterator.next()之后并在把该值load进内容栈之前，编译器调用了checkcast  java.lang.String方法来进行类型安全检查，jdk应该是采用这个来检测并抛出ClassCastException的。</p>
<hr>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多线程之线程并发库]]></title>
      <url>/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%BA%93/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#java基础巩固笔记5-多线程之线程并发库">java基础巩固笔记(5)-多线程之线程并发库</a><ul>
<li><a href="#原子性操作类">原子性操作类</a></li>
<li><a href="#线程池">线程池</a><ul>
<li><a href="#常用线程池">常用线程池</a></li>
<li><a href="#callablefuture">Callable&amp;Future</a></li>
</ul>
</li>
<li><a href="#lockcondition">Lock&amp;Condition</a><ul>
<li><a href="#lock">Lock</a></li>
<li><a href="#condition">Condition</a></li>
</ul>
</li>
<li><a href="#同步工具">同步工具</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
</li>
</ul>
<hr>
<p>本文主要概述<code>java.util.concurrent</code>包下的相关类和使用方法</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/package-summary.html" target="_blank" rel="external">Package java.util.concurrent</a></p>
</blockquote>
<h2 id="原子性操作类"><a href="#原子性操作类" class="headerlink" title="原子性操作类"></a>原子性操作类</h2><p><code>java.util.concurrent.atomic</code>包下的类:</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/atomic/package-summary.html" target="_blank" rel="external">Package java.util.concurrent.atomic</a></p>
</blockquote>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/Executors.html" target="_blank" rel="external">java.util.concurrent:Class Executors</a></p>
</blockquote>
<h3 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h3><p>几种常用的的生成线程池的方法：</p>
<ul>
<li><code>newCachedThreadPool</code></li>
<li><code>newFixedThreadPool</code></li>
<li><code>newScheduledThreadPool</code></li>
<li><code>newSingleThreadExecutor</code></li>
<li><code>newSingleThreadScheduledExecutor</code></li>
</ul>
<p>例子：<code>newFixedThreadPool</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单线程<code>newSingleThreadExecutor</code>可用于重启</p>
<p>用线程池启动定时器</p>
<p>例子：类似Timer的定时执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Executors.newScheduledThreadPool(<span class="number">3</span>).scheduleAtFixedRate(</span><br><span class="line">            <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"ScheduledThreadPool "</span>+Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="number">3</span>,<span class="number">1</span>, TimeUnit.SECONDS</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h3 id="Callable-amp-Future"><a href="#Callable-amp-Future" class="headerlink" title="Callable&amp;Future"></a>Callable&amp;Future</h3><p><code>ExecutorService</code>在<code>Executor</code>的基础上增加了一些方法，其中有两个核心的方法：</p>
<ul>
<li><code>Future&lt;?&gt; submit(Runnable task)</code></li>
<li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></li>
</ul>
<p>这两个方法都是向线程池中提交任务，它们的区别在于<code>Runnable</code>在执行完毕后没有结果，<code>Callable</code>执行完毕后有一个结果。这在多个线程中传递状态和结果是非常有用的。另外他们的相同点在于都返回一个Future对象。<code>Future</code>对象可以阻塞线程直到运行完毕（获取结果，如果有的话），也可以取消任务执行，当然也能够检测任务是否被取消或者是否执行完毕。</p>
<h2 id="Lock-amp-Condition"><a href="#Lock-amp-Condition" class="headerlink" title="Lock&amp;Condition"></a>Lock&amp;Condition</h2><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>Lock功能类似传统多线程技术里的<code>synchronized</code>，实现线程互斥，但更加面向对象。将需要互斥的代码片段放到<code>lock.lock();</code>和<code>lock.unlock();</code>之间。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//功能代码</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读写锁</li>
</ul>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_blank" rel="external">java.util.concurrent.locks:Class ReentrantReadWriteLock</a></p>
</blockquote>
<p>javaDoc文档读写锁例子,缓存:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">   Object data;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">   <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     rwl.readLock().lock();</span><br><span class="line">     <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">       <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">       rwl.readLock().unlock();</span><br><span class="line">       rwl.writeLock().lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">         <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">         <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">           data = ...</span><br><span class="line">           cacheValid = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">         rwl.readLock().lock();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       use(data);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       rwl.readLock().unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>重点注意在释放写锁前加读锁那部分代码，注释为<code>// Downgrade by acquiring read lock before releasing write lock</code>。自己挂了写锁，再挂读锁是可以的，这面涉及的技巧以后再研究。</p>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>Condition类似于传统多线程技术中的<code>Object.wait</code>和<code>Object.notify</code>,实现线程间同步。</p>
<p>javaDoc文档例子，可阻塞队列</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/locks/Condition.html" target="_blank" rel="external">class BoundedBuffer例子</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">   <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == items.length)</span><br><span class="line">         notFull.await();</span><br><span class="line">       items[putptr] = x;</span><br><span class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">       ++count;</span><br><span class="line">       notEmpty.signal();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">         notEmpty.await();</span><br><span class="line">       Object x = items[takeptr];</span><br><span class="line">       <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">       --count;</span><br><span class="line">       notFull.signal();</span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用了两个<code>condition</code></p>
<h2 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h2><ul>
<li><code>Semaphore</code></li>
</ul>
<p>类似占坑</p>
<ul>
<li><code>CyclicBarrier</code></li>
</ul>
<p>阶段性使进度一致</p>
<ul>
<li><code>CountDownLatch</code></li>
</ul>
<p>一人通知多人/多人通知一人</p>
<ul>
<li><code>Exchanger</code></li>
</ul>
<p>线程间数据交换，都到达则自然交换</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="http://www.blogjava.net/xylz/archive/2010/12/21/341281.html" target="_blank" rel="external">深入浅出 Java Concurrency (29): 线程池 part 2 Executor 以及Executors</a></li>
<li><a href="http://www.blogjava.net/xylz/archive/2010/07/08/325587.html" target="_blank" rel="external">《深入浅出 Java Concurrency》目录</a></li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多线程之共享数据]]></title>
      <url>/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#java基础巩固笔记5-多线程之共享数据">java基础巩固笔记(5)-多线程之共享数据</a><ul>
<li><a href="#线程范围内共享数据">线程范围内共享数据</a><ul>
<li><a href="#threadlocal类">ThreadLocal类</a></li>
</ul>
</li>
<li><a href="#多线程访问共享数据">多线程访问共享数据</a><ul>
<li><a href="#几种方式">几种方式</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>本文主要总结线程共享数据的相关知识，主要包括两方面:一是某个线程内如何共享数据，保证各个线程的数据不交叉；一是多个线程间如何共享数据，保证数据的一致性。</p>
<h2 id="线程范围内共享数据"><a href="#线程范围内共享数据" class="headerlink" title="线程范围内共享数据"></a>线程范围内共享数据</h2><p>自己实现的话，是定义一个Map,线程为键，数据为值,表中的每一项即是为每个线程准备的数据,这样在一个线程中数据是一致的。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData</span> </span>&#123;</span><br><span class="line">    <span class="comment">//准备一个哈希表，为每个线程准备数据</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> Map&lt;Thread,Integer&gt; threadData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(</span><br><span class="line">                    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">                    threadData.put(Thread.currentThread(),data);</span><br><span class="line">                    System.out.println(Thread.currentThread()+<span class="string">" put data："</span>+data);</span><br><span class="line">                    <span class="keyword">new</span> A().get();</span><br><span class="line">                    <span class="keyword">new</span> B().get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data = threadData.get(Thread.currentThread());</span><br><span class="line">            System.out.println(<span class="string">"A from "</span>+Thread.currentThread()+<span class="string">" get data "</span>+data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data = threadData.get(Thread.currentThread());</span><br><span class="line">            System.out.println(<span class="string">"B from "</span>+Thread.currentThread()+<span class="string">" get data "</span>+data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码偶尔会报异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.NullPointerException</span><br><span class="line">	at com.iot.thread.ThreadScopeShareData$A.get(ThreadScopeShareData.java:29)</span><br><span class="line">	at com.iot.thread.ThreadScopeShareData$1.run(ThreadScopeShareData.java:21)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>
<p>具体原因还不知道</p>
<h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><p>API:</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/ThreadLocal.html" target="_blank" rel="external"><code>java.lang:Class ThreadLocal&lt;T&gt;</code></a></p>
</blockquote>
<ul>
<li>单变量</li>
</ul>
<p>使用<code>ThreadLocal</code>类型的对象代替上面的<code>Map</code>即可</p>
<ul>
<li>多变量</li>
</ul>
<p>定义一个对象来封装多个变量，然后在ThreadLocal中存储整个对象</p>
<p>多变量时，最好将ThreadLocal类放在数据类的内部，数据类采用单例模式，这样，新建对象和获取对象都会更方便，同时封装性更强。</p>
<p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadInger = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">                    threadInger.set(data);</span><br><span class="line">                    System.out.println(Thread.currentThread()+<span class="string">" put data："</span>+data);</span><br><span class="line">                    MyThreadScopeData.getThreadInstance().setName(Thread.currentThread().toString());</span><br><span class="line">                    MyThreadScopeData.getThreadInstance().setAge(data%<span class="number">10</span>);</span><br><span class="line">                    <span class="keyword">new</span> A().get();</span><br><span class="line">                    <span class="keyword">new</span> B().get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data = threadInger.get();</span><br><span class="line">            System.out.println(<span class="string">"A from "</span>+Thread.currentThread()+<span class="string">" get data "</span>+data);</span><br><span class="line">            MyThreadScopeData myThreadScopeData = MyThreadScopeData.getThreadInstance();</span><br><span class="line">            System.out.println(<span class="string">"A from "</span>+myThreadScopeData);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data = threadInger.get();</span><br><span class="line">            System.out.println(<span class="string">"B from "</span>+Thread.currentThread()+<span class="string">" get data "</span>+data);</span><br><span class="line">            MyThreadScopeData myThreadScopeData = MyThreadScopeData.getThreadInstance();</span><br><span class="line">            System.out.println(<span class="string">"B from "</span>+myThreadScopeData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将多变量封装起来的数据类</span></span><br><span class="line"><span class="comment"> * 单例模式，内置ThreadLocal类型变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadScopeData</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyThreadScopeData</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; data = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  MyThreadScopeData <span class="title">getThreadInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyThreadScopeData instance = data.get();</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> MyThreadScopeData();</span><br><span class="line">            data.set(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String reVal = <span class="keyword">super</span>.toString()+<span class="string">"-&#123;name,age&#125;"</span>+<span class="string">":&#123;"</span>+getName()+<span class="string">","</span>+getAge()+<span class="string">"&#125;"</span>;</span><br><span class="line">        <span class="keyword">return</span> reVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程访问共享数据"><a href="#多线程访问共享数据" class="headerlink" title="多线程访问共享数据"></a>多线程访问共享数据</h2><h3 id="几种方式"><a href="#几种方式" class="headerlink" title="几种方式"></a>几种方式</h3><ul>
<li>线程执行代码相同，使用同一Runnable对象，Runnable对象中有共享数据</li>
<li>线程执行代码不同，将共享数据封装在另一对象中（操作数据的方法也在该对象完成），将这个对象逐一传递给各个Runnable对象。[<strong>本质：共享数据的对象作为参数传入Runnable对象</strong>]</li>
<li>线程执行代码不同，将Runnable对象作为某一个类的内部类，共享数据作为这个外部类的成员变量（操作数据的方法放在外部类）。[<strong>本质:不同内部类共享外部类数据</strong>]</li>
<li>结合上两种方式，将共享数据封装在另一对象中（操作数据的方法也在该对象完成），该对象作为这个外部类的成员变量，将Runnable对象作为内部类</li>
</ul>
<p>最后一种方式的示例:</p>
<p>设计5个线程，其中三个线程每次对j增加1，另外两个线程对j每次减少1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutiThreadShareData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MutiShareData mutiShareData = <span class="keyword">new</span> MutiShareData();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(</span><br><span class="line">                    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread()+<span class="string">":&#123;j from "</span>+ mutiShareData.getJ()+<span class="string">" + to: "</span>+mutiShareData.increment()+<span class="string">"&#125;"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            ).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(</span><br><span class="line">                    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread()+<span class="string">":&#123;j from "</span>+ mutiShareData.getJ()+<span class="string">" - to: "</span>+mutiShareData.decrement()+<span class="string">"&#125;"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            ).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将共享数据封装在另一对象中（操作数据的方法也在该对象完成）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutiShareData</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span>  <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> --j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setJ</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多线程之传统多线程]]></title>
      <url>/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BC%A0%E7%BB%9F%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#java基础巩固笔记5-多线程之传统多线程">java基础巩固笔记(5)-多线程之传统多线程</a></li>
<li><a href="#传统线程技术">传统线程技术</a><ul>
<li><a href="#传统创建线程方式">传统创建线程方式</a></li>
<li><a href="#传统定时器技术">传统定时器技术</a></li>
<li><a href="#互斥">互斥</a></li>
<li><a href="#同步">同步</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="传统线程技术"><a href="#传统线程技术" class="headerlink" title="传统线程技术"></a>传统线程技术</h1><h2 id="传统创建线程方式"><a href="#传统创建线程方式" class="headerlink" title="传统创建线程方式"></a>传统创建线程方式</h2><p>1.继承Thread类，覆盖run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<p>2.实现Runnable接口</p>
<p>Runnable不是线程，是线程要运行的代码的宿主。</p>
<p>1.看看Thread类源码，捋清Runnable，target,run,start关系</p>
<ul>
<li><code>Runnable</code>是一个接口</li>
<li><code>target</code>是<code>Thread</code>类中类型为<code>Runnable</code>，名为<code>target</code>的属性</li>
<li><code>run</code>是<code>Thread</code>类实现了<code>Runnable</code>的接口，重写的方法。</li>
<li><code>start</code>是启动线程的方法</li>
<li><strong>在<code>Thread</code>类中，调用关系为：<code>start</code>-&gt;<code>start0</code>-&gt;<code>run</code>-&gt;<code>target.run</code></strong></li>
</ul>
<p><code>Thread</code>类的<code>run</code>方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Thread</code>类的<code>target</code>属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* What will be run. */</span></span><br><span class="line"><span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></table></figure>
<p><code>target</code>属性由<code>private void init(ThreadGroup g, Runnable target, String name,long stackSize, AccessControlContext acc)</code>方法初始化。<code>init</code>方法在<code>Thread</code>类的构造方法里被调用</p>
<p>2.匿名内部类对象的构造方法如何调用父类的非默认构造方法</p>
<h2 id="传统定时器技术"><a href="#传统定时器技术" class="headerlink" title="传统定时器技术"></a>传统定时器技术</h2><p>API：</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/Timer.html" target="_blank" rel="external">java.util:Class Timer</a></p>
</blockquote>
<p>例子：一个定时器实现交替2秒、3秒打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">" bomb!"</span>);</span><br><span class="line">            <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> MyTimerTask(), <span class="number">2000</span>+<span class="number">1000</span>*(count++%<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3s后开启定时器</span></span><br><span class="line">    <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> MyTimerTask(),<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用<code>quarlz</code>开源工具</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>关键字:<code>synchronized</code>，检查锁对象</p>
<ul>
<li><code>synchronized(this)</code></li>
<li><code>synchronized void function(){}</code></li>
<li><code>synchronized(A.class)</code></li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>经验：</p>
<blockquote>
<ul>
<li>要用到共同数据(包括同步锁)或共同算法的若干个方法应该归在同一个类身上，这种设计体现了高聚类和程序的健壮性。</li>
<li>同步互斥不是在线程上实现，而是在线程访问的资源上实现，线程调用资源。</li>
</ul>
</blockquote>
<p>例子: 子线程循环5次，主线程循环10次，如此交替50次</p>
<p>设计：</p>
<p>使用一个Business类来包含子线程和主线程要运行的代码，从而，该类的对象成为加锁的对象。同步互斥在该类实现，由线程调用该类的方法，即调用了资源。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraditionalThreadCommunication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Business business = <span class="keyword">new</span> Business();</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">                            business.sub(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        ).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">            business.main(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Business</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> bShouldSub = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!bShouldSub)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"sub thread count "</span>+j+<span class="string">","</span>+i+<span class="string">"/50"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bShouldSub = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(bShouldSub)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"main thread count "</span>+j+<span class="string">","</span>+i+<span class="string">"/50"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bShouldSub = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断条件时，while与if的区别:while防止伪唤醒</p>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[volatile关键字的底层实现原理]]></title>
      <url>/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="volatile关键字的底层实现原理"><a href="#volatile关键字的底层实现原理" class="headerlink" title="volatile关键字的底层实现原理"></a>volatile关键字的底层实现原理</h2><h3 id="（一）、Java内存模型"><a href="#（一）、Java内存模型" class="headerlink" title="（一）、Java内存模型"></a>（一）、Java内存模型</h3><blockquote>
<p>想要理解volatile为什么能确保可见性，就要先理解Java中的内存模型是什么样的。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p>
</blockquote>
<p><strong>线程A–&gt;工作内存（共享变量副本）<br>——————————————–&gt;JVM—-&gt;主内存<br>线程b–&gt;工作内存（共享变量副本）</strong></p>
<p>基于此种内存模型，便产生了多线程编程中的数据“脏读”等问题。</p>
<p>举个简单的例子：在java中，执行下面这个语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i  = 10++;</span><br></pre></td></tr></table></figure></p>
<p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？</p>
<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。</p>
<p>最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>那么如何确保共享变量在多线程访问时能够正确输出结果呢？</p>
<p>在解决这个问题之前，我们要先了解并发编程的三大概念：<strong>原子性，有序性，可见性</strong>。</p>
<h3 id="（二）、原子性"><a href="#（二）、原子性" class="headerlink" title="（二）、原子性"></a>（二）、原子性</h3><p>1.定义</p>
<p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>2.实例</p>
<p>一个很经典的例子就是银行账户转账问题：</p>
<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>同样地反映到并发编程中会出现什么结果呢？</p>
<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = 9;</span><br></pre></td></tr></table></figure></p>
<p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值</p>
<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<p>3.Java中的原子性</p>
<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>请分析以下哪些操作是原子性操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 10;         //语句1</span><br><span class="line">y = x;         //语句2</span><br><span class="line">x++;           //语句3</span><br><span class="line">x = x + 1;     //语句4</span><br></pre></td></tr></table></figure></p>
<p>咋一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<p>关于synchronized和Lock的使用，参考：关于synchronized和ReentrantLock之多线程同步详解</p>
<h3 id="（三）、可见性"><a href="#（三）、可见性" class="headerlink" title="（三）、可见性"></a>（三）、可见性</h3><p>1.定义</p>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>2.实例</p>
<p>举个简单的例子，看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//线程1执行的代码</span><br><span class="line">int i = 0;</span><br><span class="line">i = 10;</span><br><span class="line"> </span><br><span class="line">//线程2执行的代码</span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>
<p>由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<p>3.Java中的可见性</p>
<p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h3 id="（四）、有序性"><a href="#（四）、有序性" class="headerlink" title="（四）、有序性"></a>（四）、有序性</h3><p>1.定义</p>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
<p>2.实例</p>
<p>举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;              </span><br><span class="line"> </span><br><span class="line">boolean flag = false;</span><br><span class="line"> </span><br><span class="line">i = 1;                //语句1  </span><br><span class="line">flag = true;          //语句2</span><br></pre></td></tr></table></figure></p>
<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;    //语句1</span><br><span class="line">int r = 2;    //语句2</span><br><span class="line">a = a + 3;    //语句3</span><br><span class="line">r = a*a;     //语句4</span><br></pre></td></tr></table></figure></p>
<p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
<blockquote>
<p> 语句2     语句1     语句3     语句4</p>
</blockquote>
<p>那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3</p>
<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line"> </span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line"> //线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">   sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<p>3.Java中的有序性</p>
<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>下面就来具体介绍下happens-before原则（先行发生原则）：</p>
<p>①程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p>
<p>②锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</p>
<p>③volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p>
<p>④传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>
<p>⑤线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p>
<p>⑥线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p>
<p>⑦线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p>
<p>⑧对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p>
<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>下面我们来解释一下前4条规则：</p>
<p>对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h3 id="（五）、深入理解volatile关键字"><a href="#（五）、深入理解volatile关键字" class="headerlink" title="（五）、深入理解volatile关键字"></a>（五）、深入理解volatile关键字</h3><p>1.volatile保证可见性</p>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>2）禁止进行指令重排序。</p>
<p>先看一段代码，假如线程1先执行，线程2后执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//线程1</span><br><span class="line">boolean stop = false;</span><br><span class="line">while(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//线程2</span><br><span class="line">stop = true;</span><br></pre></td></tr></table></figure></p>
<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>但是用volatile修饰之后就变得不一样了：</p>
<p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>那么线程1读取到的就是最新的正确的值。</p>
<p>2.volatile不能确保原子性</p>
<p>下面看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line"> </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，</p>
<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。</p>
<p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<p>3.volatile保证有序性</p>
<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>volatile关键字禁止指令重排序有两层意思：</p>
<p>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>2）在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>可能上面说的比较绕，举个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"> </span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;         //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>那么我们回到前面举的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<h3 id="（六）、volatile的实现原理"><a href="#（六）、volatile的实现原理" class="headerlink" title="（六）、volatile的实现原理"></a>（六）、volatile的实现原理</h3><p>1.可见性</p>
<p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p>
<p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p>
<p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p>
<p>2.有序性</p>
<p>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p>
<h3 id="（七）、volatile的应用场景"><a href="#（七）、volatile的应用场景" class="headerlink" title="（七）、volatile的应用场景"></a>（七）、volatile的应用场景</h3><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>1）对变量的写操作不依赖于当前值</p>
<p>2）该变量没有包含在具有其他变量的不变式中</p>
<p>下面列举几个Java中使用volatile的几个场景。</p>
<p>①.状态标记量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean flag = false;</span><br><span class="line"> //线程1</span><br><span class="line">while(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">  //线程2</span><br><span class="line">public void setFlag() &#123;</span><br><span class="line">    flag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据状态标记，终止线程。</p>
<p>②.单例模式中的double check</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line"> </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance==null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance==null)</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要使用volatile 修饰instance？</p>
<p>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:</p>
<p>1.给 instance 分配内存</p>
<p>2.调用 Singleton 的构造函数来初始化成员变量</p>
<p>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。</p>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> volatile </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实现AOP功能的封装与配置的小框架]]></title>
      <url>/%E5%AE%9E%E7%8E%B0AOP%E5%8A%9F%E8%83%BD%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%9A%84%E5%B0%8F%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#java基础巩固笔记4-实现aop功能的封装与配置的小框架">java基础巩固笔记(4)-实现AOP功能的封装与配置的小框架</a><ul>
<li><a href="#设计">设计</a></li>
</ul>
</li>
<li><a href="#xxxjavautilarraylist">xxx=java.util.ArrayList</a><ul>
<li><a href="#代码">代码</a><ul>
<li><a href="#advice接口"><code>Advice</code>接口</a></li>
<li><a href="#myadvice类"><code>MyAdvice</code>类</a></li>
<li><a href="#beanfactory类"><code>BeanFactory</code>类</a></li>
<li><a href="#proxyfactorybean类"><code>ProxyFactoryBean</code>类</a></li>
<li><a href="#aopframeworktest类"><code>AopFrameWorkTest</code>类</a></li>
</ul>
</li>
<li><a href="#输出">输出</a></li>
</ul>
</li>
</ul>
<hr>
<p>本文通过是动态代理实现的AOP功能的封装与配置的小框架.加深对动态代理和AOP编程的理解</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>根据配置文件的键<code>xxx</code>对应的值(类全名)创建相应类的对象。</p>
<p>当且仅当<code>xxx</code>对应的值为<code>com.iot.proxy.aopframework.ProxyFactoryBean</code>时，则生成相应的动态代理类对象。代理对象的目标类和通知实现类分别由<code>xxx.target</code>和<code>xxx.advice</code>配置</p>
<p>配置文件</p>
<p><code>config.propertiest</code>位于<code>aopframework</code>包下</p>
<ul>
<li><code>xxx</code>代表要加载的类</li>
<li><code>xxx.advice</code>代表通知接口的某个实现类</li>
<li><code>xxx.target</code>代表委托类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#xxx=java.util.ArrayList</span><br><span class="line">xxx=com.iot.proxy.aopframework.ProxyFactoryBean</span><br><span class="line">xxx.advice=com.iot.proxy.MyAdvice</span><br><span class="line">xxx.target=java.util.ArrayList</span><br></pre></td></tr></table></figure>
<p>包:<code>com.iot.proxy.aopframework</code>,有如下几个类/接口：</p>
<ul>
<li><code>BeanFactory</code>,用于读取配置文件，根据配置创建相应的对象</li>
<li><code>ProxyFactoryBean</code>,用于生成代理对象，含有两个私有属性:目标和通知</li>
<li><code>Advice</code>,通知接口，用于把切面的代码以<strong>对象</strong>的形式传递给InvocationHandler的的invoke方法</li>
<li><code>MyAdvice</code>,<code>Advice</code>接口的一个实现类，打印执行方法前的时间及执行耗时</li>
<li><code>AopFrameWorkTest</code>，测试效果</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Advice接口"><a href="#Advice接口" class="headerlink" title="Advice接口"></a><code>Advice</code>接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.proxy.aopframework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(Method method)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aftereMethod</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MyAdvice类"><a href="#MyAdvice类" class="headerlink" title="MyAdvice类"></a><code>MyAdvice</code>类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.proxy.aopframework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> <span class="keyword">implements</span> <span class="title">Advice</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginTime = <span class="number">0</span> ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        System.out.println(method.getName()+<span class="string">" before at "</span>+beginTime);</span><br><span class="line">        beginTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aftereMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(method.getName()+<span class="string">" cost total "</span>+ (endTime-beginTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BeanFactory类"><a href="#BeanFactory类" class="headerlink" title="BeanFactory类"></a><code>BeanFactory</code>类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.proxy.aopframework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanFactory</span><span class="params">(InputStream inputStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Object <span class="title">getBean</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        String className = properties.getProperty(name);</span><br><span class="line">        Object bean = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(className);</span><br><span class="line">            bean = clazz.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ProxyFactoryBean)&#123;</span><br><span class="line">            ProxyFactoryBean proxyFactoryBean = (ProxyFactoryBean)bean;</span><br><span class="line">            Advice advice = <span class="keyword">null</span>;</span><br><span class="line">            Object target = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                advice = (Advice) Class.forName(properties.getProperty(name+<span class="string">".advice"</span>)).newInstance();</span><br><span class="line">                target = Class.forName(properties.getProperty(name+<span class="string">".target"</span>)).newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            proxyFactoryBean.setAdvice(advice);</span><br><span class="line">            proxyFactoryBean.setTarget(target);</span><br><span class="line">            Object proxy = ((ProxyFactoryBean) bean).getProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ProxyFactoryBean类"><a href="#ProxyFactoryBean类" class="headerlink" title="ProxyFactoryBean类"></a><code>ProxyFactoryBean</code>类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.proxy.aopframework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> Advice advice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object proxy = Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        advice.beforeMethod(method);</span><br><span class="line">                        Object retVal = method.invoke(target,args);</span><br><span class="line">                        advice.aftereMethod(method);</span><br><span class="line">                        <span class="keyword">return</span> retVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AopFrameWorkTest类"><a href="#AopFrameWorkTest类" class="headerlink" title="AopFrameWorkTest类"></a><code>AopFrameWorkTest</code>类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.proxy.aopframework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2016/2/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopFrameWorkTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = AopFrameWorkTest.class.getResourceAsStream(<span class="string">"config.properties"</span>);</span><br><span class="line">        Object bean = <span class="keyword">new</span> BeanFactory(inputStream).getBean(<span class="string">"xxx"</span>);</span><br><span class="line">        System.out.println(bean.getClass().getName());</span><br><span class="line">        ((Collection) bean).clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul>
<li>配置<code>xxx=com.iot.proxy.aopframework.ProxyFactoryBean</code></li>
</ul>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.sun.proxy.$Proxy0</span><br><span class="line">clear before at 0</span><br><span class="line">clear cost total 0</span><br></pre></td></tr></table></figure>
<ul>
<li>配置<code>xxx=java.util.ArrayList</code></li>
</ul>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.ArrayList</span><br></pre></td></tr></table></figure>
<p>可以看出，只改变配置文件，就可改变代码的运行结果，从而达到灵活的效果</p>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代理]]></title>
      <url>/%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#java基础巩固笔记4-代理">java基础巩固笔记(4)-代理</a><ul>
<li><a href="#概念">概念</a></li>
<li><a href="#动态代理">动态代理</a><ul>
<li><a href="#创建动态类">创建动态类</a></li>
<li><a href="#动态代理的工作原理">动态代理的工作原理</a></li>
<li><a href="#面向切面编程">面向切面编程</a></li>
</ul>
</li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
</li>
</ul>
<hr>
<p>代理是实现AOP(Aspect oriented program，面向切面编程)的核心和关键技术。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>代理是一种设计模式，其目的是为其他对象提供一个代理以控制对某个对象的访问，代理类负责为委托类预处理消息，过滤消息并转发消息以及进行消息被委托类执行后的后续处理。为了保持行为的一致性，代理类和委托类通常会实现相同的接口</p>
<ul>
<li>静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译，也就是说在程序运行前代理类的.class文件就已经存在。</li>
<li>动态代理：在程序运行时运用反射机制动态创建生成。</li>
</ul>
<p><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaSE_%E4%BB%A3%E7%90%86%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="代理架构图"></p>
<p><em>紫色箭头代表类的继承关系，红色连线表示调用关系</em></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul>
<li>JVM可以在运行期动态生成类的字节码，该类往往被用作动态代理类。</li>
<li>JVM生成的动态类必须实现一个或多个接口，所以这种只能用作具有相同接口的目标类的代理。</li>
<li>CGLIB库可以动态生成一个类的子类，一个类的子类也可作为该类的代理，这个可用来为没有实现接口的类生成动态代理类。</li>
<li>代理类可在<em>调用目标方法之前、之后、前后、以及处理目标方法异常的catch块中</em>添加系统功能代码。</li>
</ul>
<h3 id="创建动态类"><a href="#创建动态类" class="headerlink" title="创建动态类"></a>创建动态类</h3><p>API:</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/reflect/Proxy.html" target="_blank" rel="external">java.lang.reflect:Class Proxy</a><br><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/reflect/InvocationHandler.html" target="_blank" rel="external">java.lang.reflect:Interface InvocationHandler</a></p>
</blockquote>
<ul>
<li>查看代理类方法列表信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by brian on 2015/12/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazzProxy1 = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);</span><br><span class="line">        System.out.println(clazzProxy1);</span><br><span class="line">        printConstructors(clazzProxy1);</span><br><span class="line">        printMethods(clazzProxy1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印构造方法列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-------------constructors list-------------"</span>);</span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        System.out.print(getExecutableList(constructors));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印成员方法列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-------------methods list-------------"</span>);</span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        System.out.print(getExecutableList(methods));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取要打印的列表数据</span></span><br><span class="line"><span class="comment">     * 每行一个方法,按照func(arg1,arg2)的格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executables</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExecutableList</span><span class="params">(Executable[] executables)</span></span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Executable executable : executables) &#123;</span><br><span class="line">            String name = executable.getName();</span><br><span class="line">            stringBuilder.append(name);</span><br><span class="line">            stringBuilder.append(<span class="string">"("</span>);</span><br><span class="line">            Class[] clazzParams = executable.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class clazzParam : clazzParams) &#123;</span><br><span class="line">                stringBuilder.append(clazzParam.getName()).append(<span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (clazzParams != <span class="keyword">null</span> &amp;&amp; clazzParams.length != <span class="number">0</span>) &#123;</span><br><span class="line">                stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.append(<span class="string">")\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class com.sun.proxy.$Proxy0</span><br><span class="line">-------------constructors list-------------</span><br><span class="line">com.sun.proxy.$Proxy0(java.lang.reflect.InvocationHandler)</span><br><span class="line">-------------methods list-------------</span><br><span class="line">add(java.lang.Object)</span><br><span class="line">remove(java.lang.Object)</span><br><span class="line">equals(java.lang.Object)</span><br><span class="line">toString()</span><br><span class="line">hashCode()</span><br><span class="line">clear()</span><br><span class="line">contains(java.lang.Object)</span><br><span class="line">isEmpty()</span><br><span class="line">iterator()</span><br><span class="line">size()</span><br><span class="line">toArray([Ljava.lang.Object;)</span><br><span class="line">toArray()</span><br><span class="line">spliterator()</span><br><span class="line">addAll(java.util.Collection)</span><br><span class="line">stream()</span><br><span class="line">forEach(java.util.function.Consumer)</span><br><span class="line">containsAll(java.util.Collection)</span><br><span class="line">removeAll(java.util.Collection)</span><br><span class="line">removeIf(java.util.function.Predicate)</span><br><span class="line">retainAll(java.util.Collection)</span><br><span class="line">parallelStream()</span><br><span class="line">isProxyClass(java.lang.Class)</span><br><span class="line">getInvocationHandler(java.lang.Object)</span><br><span class="line">getProxyClass(java.lang.ClassLoader,[Ljava.lang.Class;)</span><br><span class="line">newProxyInstance(java.lang.ClassLoader,[Ljava.lang.Class;,java.lang.reflect.InvocationHandler)</span><br><span class="line">wait()</span><br><span class="line">wait(long,int)</span><br><span class="line">wait(long)</span><br><span class="line">getClass()</span><br><span class="line">notify()</span><br><span class="line">notifyAll()</span><br></pre></td></tr></table></figure>
<ul>
<li>创建实例对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试创建实例对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InstantiationException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createProxyInstance</span><span class="params">( )</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：先创建代理类，再使用反射创建实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class clazzProxy1 = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);</span><br><span class="line">    Constructor constructor = clazzProxy1.getConstructor(InvocationHandler.class);</span><br><span class="line">    Collection proxy1 = (Collection) constructor.newInstance(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：直接使用newProxyInstance方法创建实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Collection proxy2 = (Collection)Proxy.newProxyInstance(</span><br><span class="line">            Collection.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;Collection.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                ArrayList target = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">//ArrayList targetTmp = new ArrayList();</span></span><br><span class="line">            System.out.println(<span class="string">"before invoke method: "</span>+method.getName());</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    proxy2.add(<span class="string">"aaa"</span>);</span><br><span class="line">    proxy2.add(<span class="string">"bbb"</span>);</span><br><span class="line">    System.out.println(proxy2.size());</span><br><span class="line">    System.out.println(proxy2);</span><br><span class="line">    System.out.println(proxy2.getClass().getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">before invoke method: add</span><br><span class="line">before invoke method: add</span><br><span class="line">before invoke method: size</span><br><span class="line">2</span><br><span class="line">before invoke method: toString</span><br><span class="line">[aaa, bbb]</span><br><span class="line">com.sun.proxy.$Proxy0</span><br></pre></td></tr></table></figure>
<p>上述代码相关说明:</p>
<ul>
<li>若将<code>method.invoke(target,args);</code>改为<code>method.invoke(proxy,args);</code>会出现死循环</li>
<li>从输出结果可知，每次调用代理类的方法，实际都是调用<code>invoke</code>方法</li>
<li>若将<code>method.invoke(target,args);</code>改为<code>method.invoke(targetTmp,args);</code>，则<code>proxy2.size()</code>为0。因为每次调用<code>invoke</code>方法时，<code>targetTmp</code>为新的局部变量</li>
<li><code>Object</code>类只有的<code>hashCode</code>, <code>equals</code>, or <code>toString</code>方法会被交到<code>InvocationHandler</code>，其他方法自己有实现，不交给handler,所以最后打印结果为<code>com.sun.proxy.$Proxy0</code>而不是<code>Collection</code></li>
</ul>
<ul>
<li><code>InvocationHandler</code>对象的运行原理**</li>
</ul>
<p><code>InvocationHandler</code>接口只有一个<code>invoke</code>方法，每次调用代理类的方法，即调用了<code>InvocationHandler</code>对象的<code>invoke</code>方法</p>
<p><code>invoke</code>方法涉及三个要素：</p>
<ul>
<li>代理对象</li>
<li>代理对象调用的方法</li>
<li>方法接受的参数</li>
</ul>
<p>注：Object类的<code>hashCode</code>,<code>equals</code>,<code>toString</code>方法交给invoke,其他的Object类的方法，Proxy有自己的实现。</p>
<blockquote>
<p>If a proxy interface contains a method with the same name and parameter signature as the hashCode, equals, or toString methods of java.lang.Object, when such a method is invoked on a proxy instance, the Method object passed to the invocation handler will have java.lang.Object as its declaring class. In other words, the public, non-final methods of java.lang.Object logically precede all of the proxy interfaces for the determination of which Method object to pass to the invocation handler.</p>
</blockquote>
<h3 id="动态代理的工作原理"><a href="#动态代理的工作原理" class="headerlink" title="动态代理的工作原理"></a>动态代理的工作原理</h3><p>代理类创建时需要传入一个InvocationHandler对象，client调用代理类，代理类的相应方法调用InvocationHandler的的invoke方法，InvocationHandler的invoke方法(可在其中加入日志记录、时间统计等附加功能)再找目标类的相应方法。</p>
<p><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaSE_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="动态代理的工作原理图"></p>
<h3 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h3><p>把切面的代码以<strong>对象</strong>的形式传递给InvocationHandler的invoke方法，invoke方法中执行该对象的方法就执行了切面的代码。</p>
<p>所以需要传递两个参数：</p>
<p>1.目标(Object target)<br>2.通知(自定义的adviser类)</p>
<p>定义<code>Advice</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(Method method)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aftereMethod</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个实现<code>Advice</code>接口的类<code>MyAdvice</code>,用于打印执行方法前和执行后的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> <span class="keyword">implements</span> <span class="title">Advice</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginTime = <span class="number">0</span> ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        System.out.println(method.getName()+<span class="string">" before at "</span>+beginTime);</span><br><span class="line">        beginTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aftereMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(method.getName()+<span class="string">" cost total "</span>+ (endTime-beginTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个<code>getProxy</code>方法创建实例对象,接收两个参数:目标和通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(<span class="keyword">final</span> Object target,<span class="keyword">final</span> Advice advice)</span></span>&#123;</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    advice.beforeMethod(method);</span><br><span class="line">                    Object retVal = method.invoke(target,args);</span><br><span class="line">                    advice.aftereMethod(method);</span><br><span class="line">                    <span class="keyword">return</span> retVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection proxy3 = (Collection) getProxy(<span class="keyword">new</span> ArrayList(),<span class="keyword">new</span> MyAdvice());</span><br><span class="line">proxy3.add(<span class="string">"111"</span>);</span><br><span class="line">proxy3.add(<span class="string">"222"</span>);</span><br><span class="line">System.out.println(proxy3.size());</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add before at 0</span><br><span class="line">add cost total 0</span><br><span class="line">add before at 1454433980839</span><br><span class="line">add cost total 0</span><br><span class="line">size before at 1454433980839</span><br><span class="line">size cost total 0</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="http://developer.51cto.com/art/201509/492614.htm" target="_blank" rel="external">Java动态代理的实现机制</a></li>
<li><a href="http://www.cnblogs.com/xdp-gacl/p/3971367.html" target="_blank" rel="external">Java基础加强总结(三)——代理(Proxy)</a></li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POI导入导出工具类]]></title>
      <url>/POI%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;  </span><br><span class="line">import java.io.OutputStream;  </span><br><span class="line">import java.lang.reflect.Field;  </span><br><span class="line">import java.lang.reflect.InvocationTargetException;  </span><br><span class="line">import java.lang.reflect.Method;  </span><br><span class="line">import java.text.SimpleDateFormat;  </span><br><span class="line">import java.util.Collection;  </span><br><span class="line">import java.util.Date;  </span><br><span class="line">import java.util.Iterator;  </span><br><span class="line">import java.util.regex.Matcher;  </span><br><span class="line">import java.util.regex.Pattern;  </span><br><span class="line">  </span><br><span class="line">import org.apache.commons.lang.xwork.StringUtils;  </span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFCell;  </span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFCellStyle;  </span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFFont;  </span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFRichTextString;  </span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFRow;  </span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFSheet;  </span><br><span class="line">import org.apache.poi.hssf.usermodel.HSSFWorkbook;  </span><br><span class="line">import org.apache.poi.hssf.util.HSSFColor;  </span><br><span class="line">import org.apache.poi.xssf.usermodel.XSSFCell;  </span><br><span class="line">import org.apache.poi.xssf.usermodel.XSSFCellStyle;  </span><br><span class="line">import org.apache.poi.xssf.usermodel.XSSFColor;  </span><br><span class="line">import org.apache.poi.xssf.usermodel.XSSFFont;  </span><br><span class="line">import org.apache.poi.xssf.usermodel.XSSFRichTextString;  </span><br><span class="line">import org.apache.poi.xssf.usermodel.XSSFRow;  </span><br><span class="line">import org.apache.poi.xssf.usermodel.XSSFSheet;  </span><br><span class="line">import org.apache.poi.xssf.usermodel.XSSFWorkbook;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * &lt;p&gt; </span><br><span class="line"> * Excel 导出工具类  </span><br><span class="line"> * &lt;/p&gt; </span><br><span class="line"> *  </span><br><span class="line"> * @author panyong Exp </span><br><span class="line"> * @version $FileName: ExportExcelUtil.java $Date: 2013-6-25 </span><br><span class="line"> * @since 1.0 </span><br><span class="line"> *  </span><br><span class="line"> */  </span><br><span class="line">  </span><br><span class="line">public class ExportExcelUtil&lt;T&gt;&#123;  </span><br><span class="line">      </span><br><span class="line">    // 2007 版本以上 最大支持1048576行  </span><br><span class="line">    public  final static String  EXCEl_FILE_2007 = &quot;2007&quot;;  </span><br><span class="line">    // 2003 版本 最大支持65536 行  </span><br><span class="line">    public  final static String  EXCEL_FILE_2003 = &quot;2003&quot;;  </span><br><span class="line">      </span><br><span class="line">    /** </span><br><span class="line">     * &lt;p&gt; </span><br><span class="line">     * 导出无头部标题行Excel &lt;br&gt; </span><br><span class="line">     * 时间格式默认：yyyy-MM-dd hh:mm:ss &lt;br&gt; </span><br><span class="line">     * &lt;/p&gt; </span><br><span class="line">     *  </span><br><span class="line">     * @param title 表格标题 </span><br><span class="line">     * @param dataset 数据集合 </span><br><span class="line">     * @param out 输出流 </span><br><span class="line">     * @param version 2003 或者 2007，不传时默认生成2003版本 </span><br><span class="line">     */  </span><br><span class="line">    public void exportExcel(String title,Collection&lt;T&gt; dataset, OutputStream out,String version) &#123;  </span><br><span class="line">        if(StringUtils.isBlank(version) || EXCEL_FILE_2003.equals(version.trim()))&#123;  </span><br><span class="line">            exportExcel2003(title, null, dataset, out, &quot;yyyy-MM-dd hh:mm:ss&quot;);  </span><br><span class="line">        &#125;else&#123;  </span><br><span class="line">            exportExcel2007(title, null, dataset, out, &quot;yyyy-MM-dd hh:mm:ss&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * &lt;p&gt; </span><br><span class="line">     * 导出带有头部标题行的Excel &lt;br&gt; </span><br><span class="line">     * 时间格式默认：yyyy-MM-dd hh:mm:ss &lt;br&gt; </span><br><span class="line">     * &lt;/p&gt; </span><br><span class="line">     *  </span><br><span class="line">     * @param title 表格标题 </span><br><span class="line">     * @param headers 头部标题集合 </span><br><span class="line">     * @param dataset 数据集合 </span><br><span class="line">     * @param out 输出流 </span><br><span class="line">     * @param version 2003 或者 2007，不传时默认生成2003版本 </span><br><span class="line">     */  </span><br><span class="line">    public void exportExcel(String title,String[] headers, Collection&lt;T&gt; dataset,  </span><br><span class="line">            OutputStream out,String version) &#123;  </span><br><span class="line">        if(StringUtils.isBlank(version) || EXCEL_FILE_2003.equals(version.trim()))&#123;  </span><br><span class="line">            exportExcel2003(title, headers, dataset, out, &quot;yyyy-MM-dd hh:mm:ss&quot;);  </span><br><span class="line">        &#125;else&#123;  </span><br><span class="line">            exportExcel2007(title, headers, dataset, out, &quot;yyyy-MM-dd hh:mm:ss&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * &lt;p&gt; </span><br><span class="line">     * 通用Excel导出方法,利用反射机制遍历对象的所有字段，将数据写入Excel文件中 &lt;br&gt; </span><br><span class="line">     * 此版本生成2007以上版本的文件 (文件后缀：xlsx) </span><br><span class="line">     * &lt;/p&gt; </span><br><span class="line">     *  </span><br><span class="line">     * @param title </span><br><span class="line">     *            表格标题名 </span><br><span class="line">     * @param headers </span><br><span class="line">     *            表格头部标题集合 </span><br><span class="line">     * @param dataset </span><br><span class="line">     *            需要显示的数据集合,集合中一定要放置符合JavaBean风格的类的对象。此方法支持的 </span><br><span class="line">     *            JavaBean属性的数据类型有基本数据类型及String,Date </span><br><span class="line">     * @param out </span><br><span class="line">     *            与输出设备关联的流对象，可以将EXCEL文档导出到本地文件或者网络中 </span><br><span class="line">     * @param pattern </span><br><span class="line">     *            如果有时间数据，设定输出格式。默认为&quot;yyyy-MM-dd hh:mm:ss&quot; </span><br><span class="line">     */  </span><br><span class="line">    @SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)  </span><br><span class="line">    public void exportExcel2007(String title, String[] headers,  </span><br><span class="line">            Collection&lt;T&gt; dataset, OutputStream out, String pattern) &#123;  </span><br><span class="line">        // 声明一个工作薄  </span><br><span class="line">        XSSFWorkbook workbook = new XSSFWorkbook();  </span><br><span class="line">        // 生成一个表格  </span><br><span class="line">        XSSFSheet sheet = workbook.createSheet(title);  </span><br><span class="line">        // 设置表格默认列宽度为15个字节  </span><br><span class="line">        sheet.setDefaultColumnWidth(20);  </span><br><span class="line">        // 生成一个样式  </span><br><span class="line">        XSSFCellStyle style = workbook.createCellStyle();  </span><br><span class="line">        // 设置这些样式  </span><br><span class="line">        style.setFillForegroundColor(new XSSFColor(java.awt.Color.BLUE));  </span><br><span class="line">        style.setFillPattern(XSSFCellStyle.SOLID_FOREGROUND);  </span><br><span class="line">        style.setBorderBottom(XSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style.setBorderLeft(XSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style.setBorderRight(XSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style.setBorderTop(XSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style.setAlignment(XSSFCellStyle.ALIGN_CENTER);  </span><br><span class="line">        // 生成一个字体  </span><br><span class="line">        XSSFFont font = workbook.createFont();  </span><br><span class="line">        font.setBoldweight(XSSFFont.BOLDWEIGHT_BOLD);  </span><br><span class="line">        font.setFontName(&quot;宋体&quot;);   </span><br><span class="line">        font.setColor(new XSSFColor(java.awt.Color.BLACK));  </span><br><span class="line">        font.setFontHeightInPoints((short) 11);  </span><br><span class="line">        // 把字体应用到当前的样式  </span><br><span class="line">        style.setFont(font);  </span><br><span class="line">        // 生成并设置另一个样式  </span><br><span class="line">        XSSFCellStyle style2 = workbook.createCellStyle();  </span><br><span class="line">        style2.setFillForegroundColor(new XSSFColor(java.awt.Color.WHITE));  </span><br><span class="line">        style2.setFillPattern(XSSFCellStyle.SOLID_FOREGROUND);  </span><br><span class="line">        style2.setBorderBottom(XSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style2.setBorderLeft(XSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style2.setBorderRight(XSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style2.setBorderTop(XSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style2.setAlignment(XSSFCellStyle.ALIGN_CENTER);  </span><br><span class="line">        style2.setVerticalAlignment(XSSFCellStyle.VERTICAL_CENTER);  </span><br><span class="line">        // 生成另一个字体  </span><br><span class="line">        XSSFFont font2 = workbook.createFont();  </span><br><span class="line">        font2.setBoldweight(XSSFFont.BOLDWEIGHT_NORMAL);  </span><br><span class="line">        // 把字体应用到当前的样式  </span><br><span class="line">        style2.setFont(font2);  </span><br><span class="line">  </span><br><span class="line">        // 产生表格标题行  </span><br><span class="line">        XSSFRow row = sheet.createRow(0);  </span><br><span class="line">        XSSFCell cellHeader;  </span><br><span class="line">        for (int i = 0; i &lt; headers.length; i++) &#123;  </span><br><span class="line">            cellHeader = row.createCell(i);  </span><br><span class="line">            cellHeader.setCellStyle(style);  </span><br><span class="line">            cellHeader.setCellValue(new XSSFRichTextString(headers[i]));  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // 遍历集合数据，产生数据行  </span><br><span class="line">        Iterator&lt;T&gt; it = dataset.iterator();  </span><br><span class="line">        int index = 0;  </span><br><span class="line">        T t;  </span><br><span class="line">        Field[] fields;  </span><br><span class="line">        Field field;  </span><br><span class="line">        XSSFRichTextString richString;  </span><br><span class="line">        Pattern p = Pattern.compile(&quot;^//d+(//.//d+)?$&quot;);  </span><br><span class="line">        Matcher matcher;  </span><br><span class="line">        String fieldName;  </span><br><span class="line">        String getMethodName;  </span><br><span class="line">        XSSFCell cell;  </span><br><span class="line">        Class tCls;  </span><br><span class="line">        Method getMethod;  </span><br><span class="line">        Object value;  </span><br><span class="line">        String textValue;  </span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(pattern);  </span><br><span class="line">        while (it.hasNext()) &#123;  </span><br><span class="line">            index++;  </span><br><span class="line">            row = sheet.createRow(index);  </span><br><span class="line">            t = (T) it.next();  </span><br><span class="line">            // 利用反射，根据JavaBean属性的先后顺序，动态调用getXxx()方法得到属性值  </span><br><span class="line">            fields = t.getClass().getDeclaredFields();  </span><br><span class="line">            for (int i = 0; i &lt; fields.length; i++) &#123;  </span><br><span class="line">                cell = row.createCell(i);  </span><br><span class="line">                cell.setCellStyle(style2);  </span><br><span class="line">                field = fields[i];  </span><br><span class="line">                fieldName = field.getName();  </span><br><span class="line">                getMethodName = &quot;get&quot; + fieldName.substring(0, 1).toUpperCase()  </span><br><span class="line">                        + fieldName.substring(1);  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    tCls = t.getClass();  </span><br><span class="line">                    getMethod = tCls.getMethod(getMethodName, new Class[] &#123;&#125;);  </span><br><span class="line">                    value = getMethod.invoke(t, new Object[] &#123;&#125;);  </span><br><span class="line">                    // 判断值的类型后进行强制类型转换  </span><br><span class="line">                    textValue = null;  </span><br><span class="line">                    if (value instanceof Integer) &#123;  </span><br><span class="line">                        cell.setCellValue((Integer) value);  </span><br><span class="line">                    &#125; else if (value instanceof Float) &#123;  </span><br><span class="line">                        textValue = String.valueOf((Float) value);  </span><br><span class="line">                        cell.setCellValue(textValue);  </span><br><span class="line">                    &#125; else if (value instanceof Double) &#123;  </span><br><span class="line">                        textValue = String.valueOf((Double) value);  </span><br><span class="line">                        cell.setCellValue(textValue);  </span><br><span class="line">                    &#125; else if (value instanceof Long) &#123;  </span><br><span class="line">                        cell.setCellValue((Long) value);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if (value instanceof Boolean) &#123;  </span><br><span class="line">                        textValue = &quot;是&quot;;  </span><br><span class="line">                        if (!(Boolean) value) &#123;  </span><br><span class="line">                            textValue = &quot;否&quot;;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; else if (value instanceof Date) &#123;  </span><br><span class="line">                        textValue = sdf.format((Date) value);  </span><br><span class="line">                    &#125; else &#123;  </span><br><span class="line">                        // 其它数据类型都当作字符串简单处理  </span><br><span class="line">                        if (value != null) &#123;  </span><br><span class="line">                            textValue = value.toString();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if (textValue != null) &#123;  </span><br><span class="line">                        matcher = p.matcher(textValue);  </span><br><span class="line">                        if (matcher.matches()) &#123;  </span><br><span class="line">                            // 是数字当作double处理  </span><br><span class="line">                            cell.setCellValue(Double.parseDouble(textValue));  </span><br><span class="line">                        &#125; else &#123;  </span><br><span class="line">                            richString = new XSSFRichTextString(textValue);  </span><br><span class="line">                            cell.setCellValue(richString);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; catch (SecurityException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (NoSuchMethodException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (IllegalArgumentException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (InvocationTargetException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    // 清理资源  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            workbook.write(out);  </span><br><span class="line">        &#125; catch (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    /** </span><br><span class="line">     * &lt;p&gt; </span><br><span class="line">     * 通用Excel导出方法,利用反射机制遍历对象的所有字段，将数据写入Excel文件中 &lt;br&gt; </span><br><span class="line">     * 此方法生成2003版本的excel,文件名后缀：xls &lt;br&gt; </span><br><span class="line">     * &lt;/p&gt; </span><br><span class="line">     *  </span><br><span class="line">     * @param title </span><br><span class="line">     *            表格标题名 </span><br><span class="line">     * @param headers </span><br><span class="line">     *            表格头部标题集合 </span><br><span class="line">     * @param dataset </span><br><span class="line">     *            需要显示的数据集合,集合中一定要放置符合JavaBean风格的类的对象。此方法支持的 </span><br><span class="line">     *            JavaBean属性的数据类型有基本数据类型及String,Date </span><br><span class="line">     * @param out </span><br><span class="line">     *            与输出设备关联的流对象，可以将EXCEL文档导出到本地文件或者网络中 </span><br><span class="line">     * @param pattern </span><br><span class="line">     *            如果有时间数据，设定输出格式。默认为&quot;yyyy-MM-dd hh:mm:ss&quot; </span><br><span class="line">     */  </span><br><span class="line">    @SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)  </span><br><span class="line">    public void exportExcel2003(String title, String[] headers,  </span><br><span class="line">            Collection&lt;T&gt; dataset, OutputStream out, String pattern) &#123;  </span><br><span class="line">        // 声明一个工作薄  </span><br><span class="line">        HSSFWorkbook workbook = new HSSFWorkbook();  </span><br><span class="line">        // 生成一个表格  </span><br><span class="line">        HSSFSheet sheet = workbook.createSheet(title);  </span><br><span class="line">        // 设置表格默认列宽度为15个字节  </span><br><span class="line">        sheet.setDefaultColumnWidth(20);  </span><br><span class="line">        // 生成一个样式  </span><br><span class="line">        HSSFCellStyle style = workbook.createCellStyle();  </span><br><span class="line">        // 设置这些样式  </span><br><span class="line">        style.setFillForegroundColor(HSSFColor.BLUE.index);  </span><br><span class="line">        style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);  </span><br><span class="line">        style.setBorderBottom(HSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style.setBorderLeft(HSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style.setBorderRight(HSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style.setBorderTop(HSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style.setAlignment(HSSFCellStyle.ALIGN_CENTER);  </span><br><span class="line">        // 生成一个字体  </span><br><span class="line">        HSSFFont font = workbook.createFont();  </span><br><span class="line">        font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);  </span><br><span class="line">        font.setFontName(&quot;宋体&quot;);   </span><br><span class="line">        font.setColor(HSSFColor.WHITE.index);  </span><br><span class="line">        font.setFontHeightInPoints((short) 11);  </span><br><span class="line">        // 把字体应用到当前的样式  </span><br><span class="line">        style.setFont(font);  </span><br><span class="line">        // 生成并设置另一个样式  </span><br><span class="line">        HSSFCellStyle style2 = workbook.createCellStyle();  </span><br><span class="line">        style2.setFillForegroundColor(HSSFColor.WHITE.index);  </span><br><span class="line">        style2.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);  </span><br><span class="line">        style2.setBorderBottom(HSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style2.setBorderLeft(HSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style2.setBorderRight(HSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style2.setBorderTop(HSSFCellStyle.BORDER_THIN);  </span><br><span class="line">        style2.setAlignment(HSSFCellStyle.ALIGN_CENTER);  </span><br><span class="line">        style2.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);  </span><br><span class="line">        // 生成另一个字体  </span><br><span class="line">        HSSFFont font2 = workbook.createFont();  </span><br><span class="line">        font2.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL);  </span><br><span class="line">        // 把字体应用到当前的样式  </span><br><span class="line">        style2.setFont(font2);  </span><br><span class="line">  </span><br><span class="line">        // 产生表格标题行  </span><br><span class="line">        HSSFRow row = sheet.createRow(0);  </span><br><span class="line">        HSSFCell cellHeader;  </span><br><span class="line">        for (int i = 0; i &lt; headers.length; i++) &#123;  </span><br><span class="line">            cellHeader = row.createCell(i);  </span><br><span class="line">            cellHeader.setCellStyle(style);  </span><br><span class="line">            cellHeader.setCellValue(new HSSFRichTextString(headers[i]));  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // 遍历集合数据，产生数据行  </span><br><span class="line">        Iterator&lt;T&gt; it = dataset.iterator();  </span><br><span class="line">        int index = 0;  </span><br><span class="line">        T t;  </span><br><span class="line">        Field[] fields;  </span><br><span class="line">        Field field;  </span><br><span class="line">        HSSFRichTextString richString;  </span><br><span class="line">        Pattern p = Pattern.compile(&quot;^//d+(//.//d+)?$&quot;);  </span><br><span class="line">        Matcher matcher;  </span><br><span class="line">        String fieldName;  </span><br><span class="line">        String getMethodName;  </span><br><span class="line">        HSSFCell cell;  </span><br><span class="line">        Class tCls;  </span><br><span class="line">        Method getMethod;  </span><br><span class="line">        Object value;  </span><br><span class="line">        String textValue;  </span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(pattern);  </span><br><span class="line">        while (it.hasNext()) &#123;  </span><br><span class="line">            index++;  </span><br><span class="line">            row = sheet.createRow(index);  </span><br><span class="line">            t = (T) it.next();  </span><br><span class="line">            // 利用反射，根据JavaBean属性的先后顺序，动态调用getXxx()方法得到属性值  </span><br><span class="line">            fields = t.getClass().getDeclaredFields();  </span><br><span class="line">            for (int i = 0; i &lt; fields.length; i++) &#123;  </span><br><span class="line">                cell = row.createCell(i);  </span><br><span class="line">                cell.setCellStyle(style2);  </span><br><span class="line">                field = fields[i];  </span><br><span class="line">                fieldName = field.getName();  </span><br><span class="line">                getMethodName = &quot;get&quot; + fieldName.substring(0, 1).toUpperCase()  </span><br><span class="line">                        + fieldName.substring(1);  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    tCls = t.getClass();  </span><br><span class="line">                    getMethod = tCls.getMethod(getMethodName, new Class[] &#123;&#125;);  </span><br><span class="line">                    value = getMethod.invoke(t, new Object[] &#123;&#125;);  </span><br><span class="line">                    // 判断值的类型后进行强制类型转换  </span><br><span class="line">                    textValue = null;  </span><br><span class="line">                    if (value instanceof Integer) &#123;  </span><br><span class="line">                        cell.setCellValue((Integer) value);  </span><br><span class="line">                    &#125; else if (value instanceof Float) &#123;  </span><br><span class="line">                        textValue = String.valueOf((Float) value);  </span><br><span class="line">                        cell.setCellValue(textValue);  </span><br><span class="line">                    &#125; else if (value instanceof Double) &#123;  </span><br><span class="line">                        textValue = String.valueOf((Double) value);  </span><br><span class="line">                        cell.setCellValue(textValue);  </span><br><span class="line">                    &#125; else if (value instanceof Long) &#123;  </span><br><span class="line">                        cell.setCellValue((Long) value);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if (value instanceof Boolean) &#123;  </span><br><span class="line">                        textValue = &quot;是&quot;;  </span><br><span class="line">                        if (!(Boolean) value) &#123;  </span><br><span class="line">                            textValue = &quot;否&quot;;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; else if (value instanceof Date) &#123;  </span><br><span class="line">                        textValue = sdf.format((Date) value);  </span><br><span class="line">                    &#125; else &#123;  </span><br><span class="line">                        // 其它数据类型都当作字符串简单处理  </span><br><span class="line">                        if (value != null) &#123;  </span><br><span class="line">                            textValue = value.toString();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if (textValue != null) &#123;  </span><br><span class="line">                        matcher = p.matcher(textValue);  </span><br><span class="line">                        if (matcher.matches()) &#123;  </span><br><span class="line">                            // 是数字当作double处理  </span><br><span class="line">                            cell.setCellValue(Double.parseDouble(textValue));  </span><br><span class="line">                        &#125; else &#123;  </span><br><span class="line">                            richString = new HSSFRichTextString(textValue);  </span><br><span class="line">                            cell.setCellValue(richString);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; catch (SecurityException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (NoSuchMethodException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (IllegalArgumentException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (InvocationTargetException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    // 清理资源  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            workbook.write(out);  </span><br><span class="line">        &#125; catch (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此工具类使用poi.3.8版本，适用于想采用poi导出Excel的人做参考，附件中上传本次使用的jar包<br> <img src="/POI导入导出工具类/01.png" alt="jar包"></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> poi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POI导入导出]]></title>
      <url>/POI%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="POI使用总结"><a href="#POI使用总结" class="headerlink" title="POI使用总结"></a>POI使用总结</h1><hr>
<h2 id="一、-POI简介"><a href="#一、-POI简介" class="headerlink" title="一、 POI简介"></a>一、 POI简介</h2><pre><code>Apache POI是Apache软件基金会的开放源码函式库，POI提供API给Java程序对Microsoft Office格式档案读和写的功能。
</code></pre><h2 id="二、-HSSF概况"><a href="#二、-HSSF概况" class="headerlink" title="二、 HSSF概况"></a>二、 HSSF概况</h2><pre><code>HSSF 是Horrible SpreadSheet Format的缩写，通过HSSF，你可以用纯Java代码来读取、写入、修改Excel文件。HSSF 为读取操作提供了两类API：usermodel和eventusermodel，即“用户模型”和“事件-用户模型”。
</code></pre><h2 id="三、-POI-EXCEL文档结构类"><a href="#三、-POI-EXCEL文档结构类" class="headerlink" title="三、 POI EXCEL文档结构类"></a>三、 POI EXCEL文档结构类</h2><pre><code>HSSFWorkbook excel文档对象

HSSFSheet excel的sheet HSSFRow excel的行

HSSFCell excel的单元格 HSSFFont excel字体

HSSFName 名称 HSSFDataFormat 日期格式

HSSFHeader sheet头

HSSFFooter sheet尾

HSSFCellStyle cell样式

HSSFDateUtil 日期

HSSFPrintSetup 打印

HSSFErrorConstants 错误信息表
</code></pre><h2 id="四、-EXCEL常用操作方法"><a href="#四、-EXCEL常用操作方法" class="headerlink" title="四、 EXCEL常用操作方法"></a>四、 EXCEL常用操作方法</h2><p>  1、 得到Excel常用对象<br>[c-sharp] view plaincopy</p>
<pre><code>POIFSFileSystem fs=newPOIFSFileSystem(new FileInputStream(&quot;d:/test.xls&quot;));   
//得到Excel工作簿对象   
HSSFWorkbook wb = new HSSFWorkbook(fs);  
//得到Excel工作表对象   
HSSFSheet sheet = wb.getSheetAt(0);   
//得到Excel工作表的行   
HSSFRow row = sheet.getRow(i);  
//得到Excel工作表指定行的单元格   
HSSFCell cell = row.getCell((short) j);  
cellStyle = cell.getCellStyle();//得到单元格样式  
</code></pre><p> 2、建立Excel常用对象<br>[c-sharp] view plaincopy</p>
<pre><code>HSSFWorkbook wb = new HSSFWorkbook();//创建Excel工作簿对象  
HSSFSheet sheet = wb.createSheet(&quot;new sheet&quot;);//创建Excel工作表对象    
HSSFRow row = sheet.createRow((short)0); //创建Excel工作表的行  
cellStyle = wb.createCellStyle();//创建单元格样式  
row.createCell((short)0).setCellStyle(cellStyle); //创建Excel工作表指定行的单元格  
row.createCell((short)0).setCellValue(1); //设置Excel工作表的值  
</code></pre><p>3、设置sheet名称和单元格内容<br>[c-sharp] view plaincopy</p>
<pre><code>wb.setSheetName(1, &quot;第一张工作表&quot;,HSSFCell.ENCODING_UTF_16);          
cell.setEncoding((short) 1);      
cell.setCellValue(&quot;单元格内容&quot;);  
</code></pre><p>4、取得sheet的数目<br>[c-sharp] view plaincopy</p>
<pre><code>wb.getNumberOfSheets()   
</code></pre><p>5、  根据index取得sheet对象<br>[c-sharp] view plaincopy</p>
<pre><code>HSSFSheet sheet = wb.getSheetAt(0);  
</code></pre><p>6、取得有效的行数<br>[c-sharp] view plaincopy</p>
<pre><code>int rowcount = sheet.getLastRowNum();  
</code></pre><p>7、取得一行的有效单元格个数<br>[c-sharp] view plaincopy</p>
<pre><code>row.getLastCellNum();    
</code></pre><p>8、单元格值类型读写</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>cell.setCellType(HSSFCell.CELL_TYPE_STRING); //设置单元格为STRING类型  
cell.getNumericCellValue();//读取为数值类型的单元格内容  
</code></pre><p>9、设置列宽、行高</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>sheet.setColumnWidth((short)column,(short)width);      
row.setHeight((short)height);    
</code></pre><p>10、添加区域，合并单元格</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>Region region = new Region((short)rowFrom,(short)columnFrom,(short)rowTo  
,(short)columnTo);//合并从第rowFrom行columnFrom列  
sheet.addMergedRegion(region);// 到rowTo行columnTo的区域     
//得到所有区域      
sheet.getNumMergedRegions()   
</code></pre><p>11、保存Excel文件</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>FileOutputStream fileOut = new FileOutputStream(path);   
wb.write(fileOut);   
</code></pre><p>12、根据单元格不同属性返回字符串数值</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>public String getCellStringValue(HSSFCell cell) {      
        String cellValue = &quot;&quot;;      
        switch (cell.getCellType()) {      
        case HSSFCell.CELL_TYPE_STRING://字符串类型  
            cellValue = cell.getStringCellValue();      
            if(cellValue.trim().equals(&quot;&quot;)||cellValue.trim().length()&lt;=0)      
                cellValue=&quot; &quot;;      
            break;      
        case HSSFCell.CELL_TYPE_NUMERIC: //数值类型  
            cellValue = String.valueOf(cell.getNumericCellValue());      
            break;      
        case HSSFCell.CELL_TYPE_FORMULA: //公式  
            cell.setCellType(HSSFCell.CELL_TYPE_NUMERIC);      
            cellValue = String.valueOf(cell.getNumericCellValue());      
            break;      
        case HSSFCell.CELL_TYPE_BLANK:      
            cellValue=&quot; &quot;;      
            break;      
        case HSSFCell.CELL_TYPE_BOOLEAN:      
            break;      
        case HSSFCell.CELL_TYPE_ERROR:      
            break;      
        default:      
            break;      
        }      
        return cellValue;      
    }     
</code></pre><p>13、常用单元格边框格式</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFCellStyle style = wb.createCellStyle();      
style.setBorderBottom(HSSFCellStyle.BORDER_DOTTED);//下边框       
style.setBorderLeft(HSSFCellStyle.BORDER_DOTTED);//左边框       
style.setBorderRight(HSSFCellStyle.BORDER_THIN);//右边框       
style.setBorderTop(HSSFCellStyle.BORDER_THIN);//上边框    
</code></pre><p>14、设置字体和内容位置</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFFont f  = wb.createFont();      
f.setFontHeightInPoints((short) 11);//字号      
f.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL);//加粗      
style.setFont(f);      
style.setAlignment(HSSFCellStyle.ALIGN_CENTER);//左右居中      
style.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);//上下居中      
style.setRotation(short rotation);//单元格内容的旋转的角度      
HSSFDataFormat df = wb.createDataFormat();      
style1.setDataFormat(df.getFormat(&quot;0.00%&quot;));//设置单元格数据格式      
cell.setCellFormula(string);//给单元格设公式      
style.setRotation(short rotation);//单元格内容的旋转的角度   
</code></pre><p>15、插入图片</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>//先把读进来的图片放到一个ByteArrayOutputStream中，以便产生ByteArray      
      ByteArrayOutputStream byteArrayOut = new ByteArrayOutputStream();      
      BufferedImage bufferImg = ImageIO.read(new File(&quot;ok.jpg&quot;));      
      ImageIO.write(bufferImg,&quot;jpg&quot;,byteArrayOut);      
//读进一个excel模版      
FileInputStream fos = new FileInputStream(filePathName+&quot;/stencil.xlt&quot;);       
fs = new POIFSFileSystem(fos);      
//创建一个工作薄      
HSSFWorkbook wb = new HSSFWorkbook(fs);      
HSSFSheet sheet = wb.getSheetAt(0);      
HSSFPatriarch patriarch = sheet.createDrawingPatriarch();      
HSSFClientAnchor anchor = new HSSFClientAnchor(0,0,1023,255,(short) 0,0,(short)10,10);           
patriarch.createPicture(anchor , wb.addPicture(byteArrayOut.toByteArray(),HSSFWorkbook.PICTURE_TYPE_JPEG));    
</code></pre><p>16、调整工作表位置</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFWorkbook wb = new HSSFWorkbook();     
HSSFSheet sheet = wb.createSheet(&quot;format sheet&quot;);     
HSSFPrintSetup ps = sheet.getPrintSetup();     
sheet.setAutobreaks(true);     
ps.setFitHeight((short)1);     
ps.setFitWidth((short)1);   
</code></pre><p>17、设置打印区域</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFSheet sheet = wb.createSheet(&quot;Sheet1&quot;);     
wb.setPrintArea(0, &quot;$A$1:$C$2&quot;);    
</code></pre><p>18、标注脚注</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFSheet sheet = wb.createSheet(&quot;format sheet&quot;);     
HSSFFooter footer = sheet.getFooter()     
footer.setRight( &quot;Page &quot; + HSSFFooter.page() + &quot; of &quot; + HSSFFooter.numPages() );   
</code></pre><p>19、在工作单中清空行数据，调整行位置</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFWorkbook wb = new HSSFWorkbook();     
HSSFSheet sheet = wb.createSheet(&quot;row sheet&quot;);     
// Create various cells and rows for spreadsheet.     
// Shift rows 6 - 11 on the spreadsheet to the top (rows 0 - 5)     
sheet.shiftRows(5, 10, -5);    
</code></pre><p>20、选中指定的工作表</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFSheet sheet = wb.createSheet(&quot;row sheet&quot;);     
heet.setSelected(true);     
</code></pre><p>21、工作表的放大缩小</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFSheet sheet1 = wb.createSheet(&quot;new sheet&quot;);     
sheet1.setZoom(1,2);   // 50 percent magnification    
</code></pre><p>22、头注和脚注</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFSheet sheet = wb.createSheet(&quot;new sheet&quot;);     
HSSFHeader header = sheet.getHeader();     
header.setCenter(&quot;Center Header&quot;);     
header.setLeft(&quot;Left Header&quot;);     
header.setRight(HSSFHeader.font(&quot;Stencil-Normal&quot;, &quot;Italic&quot;) +     
HSSFHeader.fontSize((short) 16) + &quot;Right w/ Stencil-Normal Italic font and size 16&quot;);  
</code></pre><p>23、自定义颜色</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFCellStyle style = wb.createCellStyle();     
style.setFillForegroundColor(HSSFColor.LIME.index);     
style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);     
HSSFFont font = wb.createFont();     
font.setColor(HSSFColor.RED.index);     
style.setFont(font);     
cell.setCellStyle(style);     
</code></pre><p>24、填充和颜色设置</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFCellStyle style = wb.createCellStyle();     
style.setFillBackgroundColor(HSSFColor.AQUA.index);     
style.setFillPattern(HSSFCellStyle.BIG_SPOTS);     
HSSFCell cell = row.createCell((short) 1);     
cell.setCellValue(&quot;X&quot;);     
style = wb.createCellStyle();     
style.setFillForegroundColor(HSSFColor.ORANGE.index);     
style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);     
cell.setCellStyle(style);   
</code></pre><p>25、强行刷新单元格公式</p>
<p>[c-sharp] view plaincopy</p>
<pre><code>HSSFFormulaEvaluator eval=new HSSFFormulaEvaluator((HSSFWorkbook) wb);    
private static void updateFormula(Workbook wb,Sheet s,int row){     
        Row r=s.getRow(row);     
        Cell c=null;     
        FormulaEcaluator eval=null;     
        if(wb instanceof HSSFWorkbook)     
            eval=new HSSFFormulaEvaluator((HSSFWorkbook) wb);     
        else if(wb instanceof XSSFWorkbook)     
            eval=new XSSFFormulaEvaluator((XSSFWorkbook) wb);     
        for(int i=r.getFirstCellNum();i&lt;r.getLastCellNum();i++){     
            c=r.getCell(i);     
            if(c.getCellType()==Cell.CELL_TYPE_FORMULA)     
                eval.evaluateFormulaCell(c);     
        }     
    }    
</code></pre><p>说明：FormulaEvaluator提供了evaluateFormulaCell(Cell cell)方法，计算公式保存结果，但不改变公式。而evaluateInCell(Cell cell) 方法是计算公式，并将原公式替换为计算结果，也就是说该单元格的类型不在是Cell.CELL_TYPE_FORMULA而是Cell.CELL_TYPE_NUMBERIC。HSSFFormulaEvaluator提供了静态方法evaluateAllFormu</p>
<p>laCells(HSSFWorkbook wb) ，计算一个Excel文件的所有公式，用起来很方便。</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> poi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[泛型]]></title>
      <url>/%E6%B3%9B%E5%9E%8B/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#java基础巩固笔记2-泛型">java基础巩固笔记(2)-泛型</a><ul>
<li><a href="#术语">术语</a></li>
<li><a href="#通配符">“?”通配符</a><ul>
<li><a href="#通配符的扩展">通配符的扩展</a></li>
</ul>
</li>
<li><a href="#自定义泛型方法">自定义泛型方法</a><ul>
<li><a href="#擦除实例">“擦除”实例</a></li>
<li><a href="#类型参数的类型推断">类型参数的类型推断</a></li>
</ul>
</li>
<li><a href="#自定义泛型类">自定义泛型类</a><ul>
<li><a href="#泛型方法和泛型类的比较">泛型方法和泛型类的比较</a></li>
</ul>
</li>
<li><a href="#泛型和反射">泛型和反射</a><ul>
<li><a href="#通过反射获得泛型的实际类型参数">通过反射获得泛型的实际类型参数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>本文对泛型的基本知识进行较为全面的总结，并附上简短的代码实例，加深记忆。</p>
<p>泛型：将集合中的元素限定为一个特定的类型。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li><code>ArrayList&lt;E&gt;</code> – 泛型类型</li>
<li><code>ArrayList</code> – 原始类型</li>
<li><code>E</code> – 类型参数</li>
<li><code>&lt;&gt;</code> – 读作”typeof”</li>
<li><code>ArrayList&lt;Integer&gt;</code> – 参数化的类型</li>
<li><code>Integer</code> – 实际类型参数</li>
</ul>
<p>几点注意：</p>
<ul>
<li>参数化类型和原始类型相互兼容</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList  collection1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//通过,无warning</span></span><br><span class="line">ArrayList&lt;Integer&gt; collection2 = <span class="keyword">new</span> ArrayList();<span class="comment">//通过,有warning</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数化类型不考虑类型参数的继承关系</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; collection3 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();<span class="comment">//编译不通过</span></span><br><span class="line">ArrayList&lt;Object&gt; collection4 = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>
<p>但是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList collection5 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; collection6 = collection5;<span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="“-”通配符"><a href="#“-”通配符" class="headerlink" title="“?”通配符"></a>“?”通配符</h2><p>“?”表示任意类型，使用”?”通配符可以引用各种参数化的类型，可以调用与参数化无关的方法(如size()方法)，不能调用与参数化有关的方法(如add()方法)</p>
<h3 id="通配符的扩展"><a href="#通配符的扩展" class="headerlink" title="通配符的扩展"></a>通配符的扩展</h3><ul>
<li>限定通配符的上边界</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? extends Number &gt; collection1= <span class="keyword">new</span> ArrayList&lt;Integer &gt;();<span class="comment">//编译通过</span></span><br><span class="line">ArrayList&lt;? extends Number &gt; collection2= <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>
<ul>
<li>限定通配符的下边界</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? <span class="keyword">super</span> Integer &gt; collection3= <span class="keyword">new</span> ArrayList&lt;Number &gt;();<span class="comment">//编译通过</span></span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Integer &gt; collection4= <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h2><p>C++模板函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">add</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> (T)(x+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而java的泛型基本上完全在编译器中实现，用于编译器执行类型检查和类型判断，然后生成普通的<strong>非泛型</strong>的字节码，这种实现技术为“擦除”(erasure)。</p>
<h3 id="“擦除”实例"><a href="#“擦除”实例" class="headerlink" title="“擦除”实例"></a>“擦除”实例</h3><p>泛型是提供给javac编译器使用的，限定集合的输入类型，编译器编译带类型说明的集合时会去掉“类型”信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GenericTest().testType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; collection1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; collection2= <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        System.out.println(collection1.getClass()==collection2.getClass());</span><br><span class="line">        <span class="comment">//两者class类型一样,即字节码一致</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(collection2.getClass().getName());</span><br><span class="line">        <span class="comment">//class均为java.util.ArrayList,并无实际类型参数信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">java.util.ArrayList</span><br></pre></td></tr></table></figure>
<p><em>使用反射可跳过编译器，往某个泛型集合加入其它类型数据。</em></p>
<p>只有引用类型才能作为泛型方法的实际参数<br>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        swap(<span class="keyword">new</span> String[]&#123;<span class="string">"111"</span>,<span class="string">"222"</span>&#125;,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//编译通过</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//swap(new int[]&#123;1,2&#125;,0,1);</span></span><br><span class="line">        <span class="comment">//编译不通过,因为int不是引用类型</span></span><br><span class="line">        </span><br><span class="line">        swap(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//编译通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*交换数组a 的第i个和第j个元素*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T[]a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        T temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但注意基本类型<strong>有时</strong>可以作为实参，因为有<strong>自动装箱</strong>和<strong>拆箱</strong>。<br>例子(编译通过了)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GenericTest().testType();</span><br><span class="line">        <span class="keyword">int</span> a = biggerOne(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//int 和 double,取交为Number</span></span><br><span class="line">        Number b = biggerOne(<span class="number">3</span>,<span class="number">5.5</span>);</span><br><span class="line">        <span class="comment">//String和int 取交为Object</span></span><br><span class="line">        Object c = biggerOne(<span class="string">"1"</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从x,y中返回y</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">biggerOne</span><span class="params">(T x,T y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，该例还表明，<strong>当实参不一致时，T取交集，即第一个共同的父类。</strong><br>另外，如果用<code>Number b = biggerOne(3,5.5);</code>改为<code>String c = biggerOne(3,5.5);</code>则编译报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error:(17, 29) java: 不兼容的类型: 推断类型不符合上限</span><br><span class="line">    推断: java.lang.Number&amp;java.lang.Comparable&lt;? extends java.lang.Number&amp;java.lang.Comparable&lt;?&gt;&gt;</span><br><span class="line">    上限: java.lang.String,java.lang.Object</span><br></pre></td></tr></table></figure>
<p>但是有一点没搞清楚，我在IDEA里面单步调试，发现结果如下图：<br><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaSE_%E6%B3%9B%E5%9E%8B%E8%B0%83%E8%AF%95%E6%88%AA%E5%9B%BE-1.png" alt="泛型调试截图-1"><br>不知道b为什么是Double类型的（但直接<code>Double b</code>接收返回值会编译报错）。不知道跟IDE有没有关系，是不是IDE在debug时会显示这个对象最精确的类型？</p>
<h3 id="类型参数的类型推断"><a href="#类型参数的类型推断" class="headerlink" title="类型参数的类型推断"></a>类型参数的类型推断</h3><p>编译器判断泛型方法的实际类型参数的过程称为类型推断。</p>
<ul>
<li>当某个类型变量只在整个参数列表的所有参数和返回值中的<strong>一处被应用</strong>了，那么根据调用方法时该处的实际应用类型来确定。即直接根据调用方法时传递的参数类型或返回值来决定泛型参数的类型。<br>例如：</li>
</ul>
<p><code>swap(new String[3],1,2)</code> -&gt; <code>static &lt;E&gt; void swap(E[]a,int i,int j)</code></p>
<ul>
<li>当某个类型变量在整个参数列表的所有参数和返回值中的<strong>多处被应用</strong>了，如果调用方法时这么多处的实际应用类型都 <em>对应同一种类型</em>，则泛型参数的类型就是该类型。<br>例如：</li>
</ul>
<p><code>add(3,5)</code> -&gt; <code>static &lt;T&gt; T add(T a,T b)</code></p>
<ul>
<li>当某个类型变量在整个参数列表的所有参数和返回值中的<strong>*多处被应用</strong>了，如果调用方法时这么多处的实际应用类型 <em>对应不同的类型,且没有返回值</em>，则取多个参数中的最大交集类型，即第一个公共父类。<br>例如：</li>
</ul>
<p><code>fill(new Integer[3],3.5)</code> -&gt; <code>static &lt;T&gt; void fill(T a[],T v)</code></p>
<p>该例子实际对应的类型就是Number,编译通过，运行出问题。</p>
<ul>
<li>当某个类型变量在整个参数列表的所有参数和返回值中的<strong>多处被应用</strong>了，如果调用方法时这么多处的实际应用类型<em>对应不同的类型,且使用有返回值</em>，则<strong>优先考虑返回值的类型</strong></li>
</ul>
<p>例如：</p>
<p><code>int x = add(3,3.5)</code> -&gt; <code>static &lt;T&gt; T add(T a,T b)</code></p>
<p>上例编译报错,x类型改为float也报错，改为Number成功。</p>
<ul>
<li>参数类型的类型推断具有传递性</li>
</ul>
<p>例子：</p>
<p><code>copy(new Integer[5],new String[5])</code> -&gt; <code>static &lt;T&gt; void copy(T []a,T []b)</code></p>
<p>该例推断实际参数类型为Object,编译通过.</p>
<p> <code>copy(new ArrayList&lt;String&gt;,new Integer[5])</code> -&gt; <code>static &lt;T&gt; void copy(Collection&lt;T&gt;a,T[]b)</code></p>
<p>该例则根据参数化的ArrayList类实例将类型变量直接确定为String类型，编译报错。</p>
<hr>
<h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDao</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">findByUserName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">findByConditions</span><span class="params">(String where)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：当一个变量被声明为泛型时，只能被实例变量和方法调用(还有内嵌类型)，而不能被静态变量和静态方法调用。<em>因为静态成员是被所参数化的类所共享的，所以静态成员不应该有类级别的类型参数</em>。</p>
<h3 id="泛型方法和泛型类的比较"><a href="#泛型方法和泛型类的比较" class="headerlink" title="泛型方法和泛型类的比较"></a>泛型方法和泛型类的比较</h3><p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;()</span>&#123;</span><br><span class="line">    <span class="comment">//泛型类的成员方法，该T受A后面的T的限制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">memberFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//泛型方法，这里的T和和类A的T是不同的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">genericFunc</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="comment">//Integer i = A&lt;String&gt;().findByUserName("s");</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        Set&lt;Integer&gt; set=  A&lt;String&gt;().findByConditions(<span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>Integer i = A&lt;String&gt;().findByUserName(&quot;s&quot;);</code>会编译报错：</p>
<p><code>Error:(35, 61) java: 不兼容的类型: java.lang.String无法转换为java.lang.Integer</code></p>
<p>由这个例子可知，泛型方法的T和和类A的T是不同的。</p>
<hr>
<h2 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h2><h3 id="通过反射获得泛型的实际类型参数"><a href="#通过反射获得泛型的实际类型参数" class="headerlink" title="通过反射获得泛型的实际类型参数"></a>通过反射获得泛型的实际类型参数</h3><p>把泛型变量当成方法的参数，利用Method类的getGenericParameterTypes方法来获取泛型的实际类型参数<br>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        getParamType();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/*利用反射获取方法参数的实际参数类型*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getParamType</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException</span>&#123;</span><br><span class="line">        Method method = GenericTest.class.getMethod(<span class="string">"applyMap"</span>,Map.class);</span><br><span class="line">        <span class="comment">//获取方法的泛型参数的类型</span></span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        System.out.println(types[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//参数化的类型</span></span><br><span class="line">        ParameterizedType pType  = (ParameterizedType)types[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//原始类型</span></span><br><span class="line">        System.out.println(pType.getRawType());</span><br><span class="line">        <span class="comment">//实际类型参数</span></span><br><span class="line">        System.out.println(pType.getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(pType.getActualTypeArguments()[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*供测试参数类型的方法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyMap</span><span class="params">(Map&lt;Integer,String&gt; map)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.Map&lt;java.lang.Integer, java.lang.String&gt;</span><br><span class="line">interface java.util.Map</span><br><span class="line">class java.lang.Integer</span><br><span class="line">class java.lang.String</span><br></pre></td></tr></table></figure>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[类加载器]]></title>
      <url>/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#java基础巩固笔记3-类加载器">java基础巩固笔记(3)-类加载器</a><ul>
<li><a href="#默认类加载器">默认类加载器</a></li>
<li><a href="#类加载器的委托机制">类加载器的委托机制</a></li>
<li><a href="#自定义类加载器的编写原理">自定义类加载器的编写原理</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
</li>
</ul>
<hr>
<p>java类加载器就是在运行时在JVM中动态地加载所需的类，java类加载器基于三个机制：委托，可见，单一。</p>
<p>把 classpath 下的那些 <code>.class</code> 文件加载进内存，处理后形成可以被虚拟机直接使用的 Java 类型，这些工作是类加载器做的。</p>
<ul>
<li><strong>委托机制</strong>指的是将加载类的请求传递给父加载器，如果父加载器找不到或者不能加载这个类，那么再加载他。</li>
<li><strong>可见性机制</strong>指的是父加载器加载的类都能被子加载器看见，但是子加载器加载的类父加载器是看不见的。</li>
<li><strong>单一性机制</strong>指的是一个类只能被同一种加载器加载一次。</li>
</ul>
<h2 id="默认类加载器"><a href="#默认类加载器" class="headerlink" title="默认类加载器"></a>默认类加载器</h2><p>系统默认三个类加载器:</p>
<ul>
<li><code>BootStrap</code></li>
<li><code>ExtClassLoader</code></li>
<li><code>AppClassLoader</code></li>
</ul>
<p><em>类加载器也是java类，而BootStrap不是。</em><br>验证代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<code>null</code></p>
<p>如果使用<code>System.out.println(System.class.getClassLoader().toString);</code>，则报空指针异常:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">	at com.iot.classloader.ClassLoaderTest.main(ClassLoaderTest.java:10)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:483)</span><br><span class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</span><br></pre></td></tr></table></figure>
<p>可见，System类是由BootStrap类加载器加载。</p>
<h2 id="类加载器的委托机制"><a href="#类加载器的委托机制" class="headerlink" title="类加载器的委托机制"></a>类加载器的委托机制</h2><p>类加载器的树状图</p>
<p><img src="http://7xph6d.com1.z0.glb.clouddn.com/javaSE_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="类加载器"></p>
<p>一般加载类的顺序：</p>
<ul>
<li>首先当前线程的类加载器去加载线程中的第一个类</li>
<li>如果类A应用了类B，java虚拟机将使用加载类A的类加载器来加载类B</li>
<li>还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类</li>
</ul>
<hr>
<h2 id="自定义类加载器的编写原理"><a href="#自定义类加载器的编写原理" class="headerlink" title="自定义类加载器的编写原理"></a>自定义类加载器的编写原理</h2><p>API:</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/ClassLoader.html" target="_blank" rel="external">Class ClassLoader</a></p>
</blockquote>
<p>模板方法设计模式</p>
<p>父类:</p>
<ul>
<li><code>loadClass</code>(类加载的流程，模板)</li>
<li><code>findClass</code>供子类覆盖的、被<code>loadClass</code>方法调用的类加载逻辑</li>
<li><code>defineClass</code>得到class文件转换成字节码</li>
</ul>
<p>子类:覆盖<code>findClass</code>方法</p>
<p>例子：</p>
<p><code>loadClass</code>方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>API文档中的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">     String host;</span><br><span class="line">     <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">         <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">         <span class="comment">// load the class data from the connection</span></span><br><span class="line">          . . .</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="http://ju.outofmemory.cn/entry/142486" target="_blank" rel="external">java类加载机制工作原理</a></li>
<li><a href="http://blog.csdn.net/gjanyanlig/article/details/6818655" target="_blank" rel="external">Java类加载器总结 - 寂静大海 - 博客频道 - CSDN.NET</a></li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>作者<a href="http://brianway.github.io/" target="_blank" rel="external">@brianway</a>更多文章：<a href="http://brianway.github.io/" target="_blank" rel="external">个人网站</a> | <a href="http://blog.csdn.net/h3243212/" target="_blank" rel="external">CSDN</a> | <a href="http://my.oschina.net/brianway" target="_blank" rel="external">oschina</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[反射]]></title>
      <url>/%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>Contents</strong></p>
<ul>
<li><a href="#java基础巩固笔记1-反射">java基础巩固笔记(1)-反射</a><ul>
<li><a href="#反射基本使用">反射基本使用</a></li>
<li><a href="#数组的反射">数组的反射</a></li>
<li><a href="#配置文件加载">配置文件加载</a></li>
<li><a href="#内省instropector--javabean">内省(Instropector) &amp; JavaBean</a></li>
</ul>
</li>
</ul>
<hr>
<p><strong>反射：将类的属性和方法映射成相应的类。</strong></p>
<h2 id="反射基本使用"><a href="#反射基本使用" class="headerlink" title="反射基本使用"></a>反射基本使用</h2><p>获取Class类的三种方法:</p>
<ul>
<li>类名.class</li>
<li>对象名.getClass()</li>
<li>Class.forName(“要加载的类名”)</li>
</ul>
<p>根据API写就行了，大致流程就是:</p>
<ul>
<li>用上述三种方式之一获取特定类的<code>Class</code>类，即该类对应的字节码</li>
<li>调用<code>Class</code>对象的<code>getConstructor(Class&lt;?&gt;... parameterTypes)</code>获取构造方法对象</li>
<li>调用是构造方法类<code>Constructor</code>的<code>newInstance(Object... initargs)</code>方法新建对象</li>
<li>调用<code>Class</code>对象的<code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>获取方法对象</li>
<li>调用方法对象类<code>Method</code>的<code>invoke(Object obj, Object... args)</code>方法，调用对象上相应方法</li>
</ul>
<p><em>用方法的参数类型唯一标识一个方法,依据：方法的重载</em></p>
<h2 id="数组的反射"><a href="#数组的反射" class="headerlink" title="数组的反射"></a>数组的反射</h2><p>下面这个例子主要说明几点：</p>
<ul>
<li>对于元素同类型的数组，同维数组，class一样</li>
<li>不同维，class不同</li>
<li>不同维的，父类都是Object,一样</li>
<li>基本类型一维数组不能直接转换为Object[]</li>
<li><code>java.util.Arrays</code>的<code>asList</code>方法API看看</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> [] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> [][] a3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        System.out.println(a1.getClass() == a2.getClass());<span class="comment">//true</span></span><br><span class="line">        System.out.println(a1.getClass());<span class="comment">//class [I</span></span><br><span class="line">        System.out.println(a3.getClass());<span class="comment">//class [[I</span></span><br><span class="line">        System.out.println(a1.getClass().getSuperclass() == a3.getClass().getSuperclass());<span class="comment">//true</span></span><br><span class="line">        System.out.println(a2.getClass().getSuperclass());<span class="comment">//class java.lang.Object</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下句编译不通过：Error:(15, 42) java: 不可比较的类型: java.lang.Class&lt;capture#1, 共 ? extends int[]&gt;和java.lang.Class&lt;capture#2, 共 ? extends int[][]&gt;</span></span><br><span class="line">        <span class="comment">//System.out.println(a1.getClass() == a3.getClass());</span></span><br><span class="line"></span><br><span class="line">        Object []b3 = a3;<span class="comment">//通过</span></span><br><span class="line">        <span class="comment">//下句编译不通过   Error:(17, 24) java: 不兼容的类型: int[]无法转换为java.lang.Object[]</span></span><br><span class="line">        <span class="comment">//Object [] b1 = a1;</span></span><br><span class="line"></span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(Arrays.asList(a1));<span class="comment">//[[I@1540e19d]</span></span><br><span class="line">        System.out.println(Arrays.asList(s1));<span class="comment">//[abc]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">class [I</span><br><span class="line">class [[I</span><br><span class="line">true</span><br><span class="line">class java.lang.Object</span><br><span class="line">[[I@1540e19d]</span><br><span class="line">[abc]</span><br></pre></td></tr></table></figure>
<p>乱入：<br>hashcode与内存泄露问题<br>参考java api：</p>
<blockquote>
<ul>
<li>hashcode一旦生成，不要变</li>
<li>对象equals方法返回true,则hashcode要一致</li>
<li>反之，equals方法返回false,hashcode不一定互异</li>
</ul>
</blockquote>
<p>如果参与hashcode计算的成员变量中途发生变化，则后面remove时失败，造成内存泄露</p>
<hr>
<h2 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h2><ul>
<li>类加载器加载只读配置文件</li>
</ul>
<p><code>类名.class.getClassLoader().getResourceAsStream(str);</code></p>
<ul>
<li>类名.class.getResourceAsStream(str),实质还是调用类加载器。<br>源码截取(java.lang包下的Class.java)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> InputStream <span class="title">getResourceAsStream</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    name = resolveName(name);</span><br><span class="line">    ClassLoader cl = getClassLoader0();</span><br><span class="line">    <span class="keyword">if</span> (cl==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A system class.</span></span><br><span class="line">        <span class="keyword">return</span> ClassLoader.getSystemResourceAsStream(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl.getResourceAsStream(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于路径str，写法有点讲究。</p>
<ul>
<li>不加斜杠，相对路径:<br><code>str = &quot;config.properties&quot;;</code></li>
<li>加斜杠，从classpath的根路径找:<br><code>str = &quot;/org/iot/ui/config.properties&quot;;</code></li>
</ul>
<p><em>以前编译java代码时，有些<code>conf/</code>文件夹还要添加进依赖或者标记成source文件夹，里面明明都是xml文件，没Java源码。从这里，我现在知道了，是使用反射加载配置文件的缘故</em></p>
<hr>
<h2 id="内省-Introspector-amp-JavaBean"><a href="#内省-Introspector-amp-JavaBean" class="headerlink" title="内省(Introspector) &amp; JavaBean"></a>内省(Introspector) &amp; JavaBean</h2><p>JavaBean读取属性x的值的流程：变大写、补前缀、获取方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;x&quot;--&gt;&quot;X&quot;--&gt;&quot;getX&quot;--&gt;&quot;MethodGetX&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>自己用内省操作</li>
</ul>
<p>我目前没用上，所以不贴代码了，只附上核心类</p>
<p>简单实现：<br>使用<code>java.beans.PropertyDescriptor</code>类</p>
<p>麻烦实现:<br>使用<code>java.beans.Introspector</code>类,遍历<code>getBeanInfo</code>方法的返回值</p>
<p><strong>JavaBean必须有一个不带参数的构造函数</strong></p>
<ul>
<li><p>使用BeanUtils工具包</p>
<ul>
<li>字符串和整数转换(对比(PropertyUtils)</li>
<li>属性级联操作</li>
<li>操作map</li>
</ul>
</li>
</ul>
<p><a href="http://brianway.github.io/" target="_blank" rel="external">作者更多文章：@brianway</a></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo生成博文插入图片]]></title>
      <url>/hexo%E7%94%9F%E6%88%90%E5%8D%9A%E6%96%87%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder</code>:这个选项设置为<code>true</code></p>
<p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git</p>
<p>3 等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p>
<h2 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h2><p>4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p>
<p><code>![你想输入的替代文字](xxxx/图片名.jpg)</code></p>
<p>注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p>
<p>5 最后检查一下，hexo g生成页面后，进入<code>public\2017\02\26\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;imgsrc=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;imgsrc=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+Github,搭建属于自己的博客]]></title>
      <url>/hexo-Github-%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h1 id="HEXO-Github-搭建属于自己的博客"><a href="#HEXO-Github-搭建属于自己的博客" class="headerlink" title="HEXO+Github,搭建属于自己的博客"></a>HEXO+Github,搭建属于自己的博客</h1><p>过各种找资料，踩过各种坑，终于搭建好了hexo，域名是在万维网上买的，我的hexo是3.1.1版本，hexo不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。</p>
<h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>hexo是一款基于Node.js的静态博客框架, hexo github链接 ,这篇教程是针对与Mac的，参考链接，由于原文讲到的hexo是以前的老版本，所以现在的版本配置的时候会有些改动。</p>
<p>之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我，不是太喜欢，简书还算好点得。最近看到一些大神们的博客,貌似都是用hexo写得,我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。</p>
<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><h4 id="安装Node（必须）"><a href="#安装Node（必须）" class="headerlink" title="安装Node（必须）"></a>安装Node（必须）</h4><p>作用：用来生成静态页面的</p>
<p>到Node.js官网下载相应平台的最新版本，一路安装即可。</p>
<h4 id="安装Git（必须）"><a href="#安装Git（必须）" class="headerlink" title="安装Git（必须）"></a>安装Git（必须）</h4><p>作用：把本地的hexo内容提交到github上去.</p>
<p>安装Xcode就自带有Git，我就不多说了。</p>
<h4 id="申请GitHub（必须）"><a href="#申请GitHub（必须）" class="headerlink" title="申请GitHub（必须）"></a>申请GitHub（必须）</h4><p>作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。</p>
<p>github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。</p>
<h3 id="正式安装Hexo"><a href="#正式安装Hexo" class="headerlink" title="正式安装Hexo"></a>正式安装Hexo</h3><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p>
<p>执行如下命令安装Hexo：</p>
<p>sudo npm install -g hexo</p>
<p>初始化然后，执行init命令初始化hexo,命令：</p>
<p>hexo init</p>
<p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。</p>
<p><strong>生成静态页面</strong></p>
<p>hexo generate（hexo g也可以）</p>
<p><strong>本地启动</strong></p>
<p>启动本地服务，进行文章预览调试，命令：</p>
<p>hexo server</p>
<p>浏览器输入<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p>
<p>我不知道你们能不能，反正我不能，因为我还有环境没配置好</p>
<h3 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h3><p>建立Repository</p>
<p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法</p>
<p>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p>
<pre><code>_config.yml    node_modules    public      source

db.json        package.json    scaffolds  themes
</code></pre><p>现在我们需要_config.yml文件，来建立关联，命令：</p>
<p>vim _config.yml</p>
<p>翻到最下面，改成我这样子的</p>
<p>deploy:</p>
<pre><code>type: git

repo: https://github.com/leopardpan/leopardpan.github.io.git

branch: master
</code></pre><p>然后执行命令：</p>
<p>npm install hexo-deployer-git –save</p>
<p>网上会有很多说法，有的type是github, 还有repository最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。</p>
<p>忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。</p>
<p>然后，执行配置命令：</p>
<p>hexo deploy</p>
<p>然后再浏览器中输入<a href="http://leopardpan.github.io/就行了，我的github的账户叫leopardpan,把这个改成你github的账户名就行了" target="_blank" rel="external">http://leopardpan.github.io/就行了，我的github的账户叫leopardpan,把这个改成你github的账户名就行了</a></p>
<p>部署步骤</p>
<p>每次部署的步骤，可按以下三步来进行。</p>
<pre><code>hexo clean

hexo generate

hexo deploy
</code></pre><p>一些常用命令：</p>
<p>hexo new”postName” #新建文章</p>
<p>hexo new page”pageName” #新建页面</p>
<p>hexo generate #生成静态页面至public目录</p>
<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>
<p>hexo deploy #将.deploy目录部署到GitHub</p>
<p>hexo help # 查看帮助</p>
<p>hexo version #查看Hexo的版本</p>
<p>报错总结</p>
<p>ERROR Deployer not found: git 或者 ERROR Deployer not found: github</p>
<p>解决方法： npm install hexo-deployer-git –save</p>
<p>如发生报错： ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令：</p>
<p>rm-rf.DS_Store</p>
<p>ERROR Plugin load failed: hexo-server</p>
<p>原因：</p>
<p>Besides,utilities are separated into a standalone module.hexo.util is not reachable anymore.</p>
<p>解决方法，执行命令：</p>
<p>sudo npm install hexo-server</p>
<p>执行命令hexo server，提示：Usage: hexo ….</p>
<p>原因：</p>
<p>我认为是没有生成本地服务</p>
<p>解决方法，执行命令：</p>
<p>npm install hexo-server –save</p>
<p>提示：hexo-server@0.1.2 node_modules/hexo-server</p>
<p>….</p>
<p>表示成功了参考</p>
<p>这个时候再执行：</p>
<p>hexo-server</p>
<p>得到:</p>
<p>INFOHexois running at <a href="http://0.0.0.0:4000/.PressCtrl+C" target="_blank" rel="external">http://0.0.0.0:4000/.PressCtrl+C</a> to stop.</p>
<p>这个时候再点击<a href="http://0.0.0.0:4000，正常情况下应该是最原始的画面，但是我看到的是：" target="_blank" rel="external">http://0.0.0.0:4000，正常情况下应该是最原始的画面，但是我看到的是：</a></p>
<p>白板和Cannot GET / 几个字</p>
<p>原因：</p>
<p>由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：</p>
<p>npm install hexo-renderer-ejs –save</p>
<p>npm install hexo-renderer-stylus –save</p>
<p>npm install hexo-renderer-marked –save</p>
<p>这个时候再重新生成静态文件，命令：</p>
<p>hexo generate（或hexo g）</p>
<p>启动本地服务器：</p>
<p>hexo server（或hexo s）</p>
<p>再，点击网址<a href="http://0.0.0.0:4000OK终于可以看到属于你自己的blog啦，😄，虽然很简陋，但好歹有了一个属于自己的小窝了。参考链接，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。" target="_blank" rel="external">http://0.0.0.0:4000OK终于可以看到属于你自己的blog啦，😄，虽然很简陋，但好歹有了一个属于自己的小窝了。参考链接，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。</a></p>
<p>主题推荐</p>
<p>这里有大量的主题列表使用方法里面</p>
<p>都有详细的介绍，我就不多说了。</p>
<p>我这里有几款个人认为不错的主题，免去你们，一个一个的选了，欢迎吐槽我的审美，😄</p>
<p>Cover- A chic theme with facebook-like cover photo</p>
<p>Oishi- A white theme based on Landscape plus and Writing.</p>
<p>Sidebar- Another theme based on Light with a simple sidebar</p>
<p>TKL- A responsive design theme for Hexo. 一个设计优雅的响应式主题</p>
<p>Tinnypp- A clean, simple theme based on Tinny</p>
<p>Writing- A small and simple hexo theme based on Light</p>
<p>Yilia- Responsive and simple style 优雅简洁响应式主题，我用得就是这个。</p>
<p>Pacman voidy- A theme with dynamic tagcloud and dynamic snow</p>
<p>一些基本路径</p>
<p>文章在source/_posts, 文章支持Markdown语法，可以使用一些MarkDown渲染工具。如果想修改头像可以直接在主题的_config.yml文件里面修改，友情链接，之类的都在这里。开始打理你的博客吧，有什么问题或者建议，都可以提出来，我会继续完善的。</p>
<p>修改头像</p>
<p>我当前的路径/Users/leopard/blog/themes/yilia，ls 你可以看到</p>
<p>Gruntfile.js    _config.yml package.json</p>
<p>README.md  layout      source</p>
<p>vim _config.yml 进去，找到 #你的头像url avatar: 后接一个URL就行了，头像就修改成功了</p>
<p>修改主题和作者名字</p>
<p>我当前的路径/Users/leopard/blog，ls 你可以看到</p>
<p>_config.yml  node_modules    public      source      themes</p>
<p>db.json        package.json     scaffolds   ssh-keygen</p>
<p>vim _config.yml 进去，找到 author: 潘柏信，修改成你自己的名字就行了</p>
<p>修改主题，然后继续往下找到</p>
<p>Extensions</p>
<p>Plugins: <a href="http://hexo.io/plugins/" target="_blank" rel="external">http://hexo.io/plugins/</a></p>
<p>Themes: <a href="http://hexo.io/themes/" target="_blank" rel="external">http://hexo.io/themes/</a></p>
<p>theme:yilia</p>
<p>改成theme: yilia，theme:后面接你自己的主题名字就行了,然后分别执行</p>
<p>部署 hexo g</p>
<p>提交 hexo d</p>
<p>你的主题，和名字就修改成功了</p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> GitHub </tag>
            
            <tag> Blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见框架面试题]]></title>
      <url>/%E5%B8%B8%E8%A7%81%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="流行的框架与新技术"><a href="#流行的框架与新技术" class="headerlink" title="流行的框架与新技术"></a>流行的框架与新技术</h1><h2 id="1、谈谈你对Struts的理解。"><a href="#1、谈谈你对Struts的理解。" class="headerlink" title="1、谈谈你对Struts的理解。"></a>1、谈谈你对Struts的理解。</h2><pre><code>答: 1. struts是一个按MVC模式设计的Web层框架，其实它就是一个大大的servlet，这个Servlet名为ActionServlet，或是ActionServlet的子类。我们可以在web.xml文件中将符合某种特征的所有请求交给这个Servlet处理，这个Servlet再参照一个配置文件（通常为/WEB-INF/struts-config.xml）将各个请求分别分配给不同的action去处理。

一个扩展知识点：struts的配置文件可以有多个，可以按模块配置各自的配置文件，这样可以防止配置文件的过度膨胀；

2. ActionServlet把请求交给action去处理之前，会将请求参数封装成一个formbean对象（就是一个java类，这个类中的每个属性对应一个请求参数），封装成一个什么样的formbean对象呢？看配置文件。

3.要说明的是， ActionServlet把formbean对象传递给action的execute方法之前，可能会调用formbean的validate方法进行校验，只有校验通过后才将这个formbean对象传递给action的execute方法，否则，它将返回一个错误页面，这个错误页面由input属性指定，（看配置文件）作者为什么将这里命名为input属性，而不是error属性，我们后面结合实际的运行效果进行分析。

4.action执行完后要返回显示的结果视图，这个结果视图是用一个ActionForward对象来表示的，actionforward对象通过struts-config.xml配置文件中的配置关联到某个jsp页面，因为程序中使用的是在struts-config.xml配置文件为jsp页面设置的逻辑名，这样可以实现action程序代码与返回的jsp页面名称的解耦。

你对struts可能还有自己的应用方面的经验，那也要一并说出来。
</code></pre><h2 id="2、谈谈你对Hibernate的理解。"><a href="#2、谈谈你对Hibernate的理解。" class="headerlink" title="2、谈谈你对Hibernate的理解。"></a>2、谈谈你对Hibernate的理解。</h2><pre><code>答:1. 面向对象设计的软件内部运行过程可以理解成就是在不断创建各种新对象、建立对象之间的关系，调用对象的方法来改变各个对象的状态和对象消亡的过程，不管程序运行的过程和操作怎么样，本质上都是要得到一个结果，程序上一个时刻和下一个时刻的运行结果的差异就表现在内存中的对象状态发生了变化。

2.为了在关机和内存空间不够的状况下，保持程序的运行状态，需要将内存中的对象状态保存到持久化设备和从持久化设备中恢复出对象的状态，通常都是保存到关系数据库来保存大量对象信息。从Java程序的运行功能上来讲，保存对象状态的功能相比系统运行的其他功能来说，应该是一个很不起眼的附属功能，java采用jdbc来实现这个功能，这个不起眼的功能却要编写大量的代码，而做的事情仅仅是保存对象和恢复对象，并且那些大量的jdbc代码并没有什么技术含量，基本上是采用一套例行公事的标准代码模板来编写，是一种苦活和重复性的工作。

3.通过数据库保存java程序运行时产生的对象和恢复对象，其实就是实现了java对象与关系数据库记录的映射关系，称为ORM（即Object Relation Mapping），人们可以通过封装JDBC代码来实现了这种功能，封装出来的产品称之为ORM框架，Hibernate就是其中的一种流行ORM框架。使用Hibernate框架，不用写JDBC代码，仅仅是调用一个save方法，就可以将对象保存到关系数据库中，仅仅是调用一个get方法，就可以从数据库中加载出一个对象。

4.使用Hibernate的基本流程是：配置Configuration对象、产生SessionFactory、创建session对象，启动事务，完成CRUD操作，提交事务，关闭session。

5.使用Hibernate时，先要配置hibernate.cfg.xml文件，其中配置数据库连接信息和方言等，还要为每个实体配置相应的hbm.xml文件，hibernate.cfg.xml文件中需要登记每个hbm.xml文件。

6.在应用Hibernate时，重点要了解Session的缓存原理，级联，延迟加载和hql查询。
</code></pre><p>3、AOP的作用。</p>
<h2 id="4、你对Spring的理解。"><a href="#4、你对Spring的理解。" class="headerlink" title="4、你对Spring的理解。"></a>4、你对Spring的理解。</h2><pre><code>1.Spring实现了工厂模式的工厂类（在这里有必要解释清楚什么是工厂模式），这个类名为BeanFactory（实际上是一个接口），在程序中通常BeanFactory的子类ApplicationContext。Spring相当于一个大的工厂类，在其配置文件中通过&lt;bean&gt;元素配置用于创建实例对象的类名和实例对象的属性。

2. Spring提供了对IOC良好支持，IOC是一种编程思想，是一种架构艺术，利用这种思想可以很好地实现模块之间的解耦。IOC也称为DI（Depency Injection），什么叫依赖注入呢？
</code></pre><p>譬如，Class Programmer</p>
<p>{</p>
<p>Computer computer = null;</p>
<p>public void code()</p>
<p>{</p>
<p>//Computer computer = new IBMComputer();</p>
<p>//Computer computer = beanfacotry.getComputer();</p>
<p>computer.write();</p>
<p>}</p>
<p>public void setComputer(Computer computer)</p>
<p>{</p>
<p>this.computer = computer;</p>
<p>}</p>
<p>}<br> 另外两种方式都由依赖，第一个直接依赖于目标类，第二个把依赖转移到工厂上，第三个彻底与目标和工厂解耦了。在spring的配置文件中配置片段如下：</p>
<bean id="”computer”" class="”cn.itcast.interview.Computer”"><br><br></bean>

<bean id="”programmer”" class="”cn.itcast.interview.Programmer”"><br><br><property name="”computer”" ref="”computer”"></property><br><br></bean>

<pre><code>3. Spring提供了对AOP技术的良好封装， AOP称为面向切面编程，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码，例如，加入日志，加入权限判断，加入异常处理，这种应用称为AOP。实现AOP功能采用的是代理技术，客户端程序不再调用目标，而调用代理类，代理类与目标类对外具有相同的方法声明，有两种方式可以实现相同的方法声明，一是实现相同的接口，二是作为目标的子类在，JDK中采用Proxy类产生动态代理的方式为某个接口生成实现类，如果要为某个类生成子类，则可以用CGLI B。在生成的代理类的方法中加入系统功能和调用目标类的相应方法，系统功能的代理以Advice对象进行提供，显然要创建出代理对象，至少需要目标类和Advice类。spring提供了这种支持，只需要在spring配置文件中配置这两个元素即可实现代理和aop功能，例如，
</code></pre><bean id="”proxy”" type="”org.spring.framework.aop.ProxyBeanFactory”"><br><br><property name="”target”" ref="””"></property><br><br><property name="”advisor”" ref="””"></property><br><br></bean>

<h2 id="5、谈谈Struts中的Action-servlet。"><a href="#5、谈谈Struts中的Action-servlet。" class="headerlink" title="5、谈谈Struts中的Action servlet。"></a>5、谈谈Struts中的Action servlet。</h2><h2 id="6、Struts优缺点"><a href="#6、Struts优缺点" class="headerlink" title="6、Struts优缺点"></a>6、Struts优缺点</h2><p>优点： </p>
<pre><code> 1. 实现MVC模式，结构清晰,使开发者只关注业务逻辑的实现.

2．有丰富的tag可以用 ,Struts的标记库(Taglib)，如能灵活动用，则能大大提高开发效率

3. 页面导航
</code></pre><p>使系统的脉络更加清晰。通过一个配置文件，即可把握整个系统各部分之间的联系，这对于后期的维护有着莫大的好处。尤其是当另一批开发者接手这个项目时，这种优势体现得更加明显。</p>
<pre><code>4. 提供Exception处理机制 .

5. 数据库链接池管理

6. 支持I18N
</code></pre><p>缺点</p>
<p>一、 转到展示层时，需要配置forward，如果有十个展示层的jsp，需要配置十次struts，而且还不包括有时候目录、文件变更，需要重新修改forward，注意，每次修改配置之后，要求重新部署整个项目，而tomcate这样的服务器，还必须重新启动服务器</p>
<p>二、 Struts 的Action必需是thread－safe方式，它仅仅允许一个实例去处理所有的请求。所以action用到的所有的资源都必需统一同步，这个就引起了线程安全的问题。</p>
<p>三、  测试不方便. Struts的每个Action都同Web层耦合在一起，这样它的测试依赖于Web容器，单元测试也很难实现。不过有一个Junit的扩展工具Struts TestCase可以实现它的单元测试。</p>
<p>四、  类型的转换. Struts的FormBean把所有的数据都作为String类型，它可以使用工具Commons-Beanutils进行类型转化。但它的转化都是在Class级别，而且转化的类型是不可配置的。类型转化时的错误信息返回给用户也是非常困难的。</p>
<p>五、 对Servlet的依赖性过强. Struts处理Action时必需要依赖ServletRequest 和ServletResponse，所有它摆脱不了Servlet容器。</p>
<p>六、  前端表达式语言方面.Struts集成了JSTL，所以它主要使用JSTL的表达式语言来获取数据。可是JSTL的表达式语言在Collection和索引属性方面处理显得很弱。</p>
<p>七、  对Action执行的控制困难. Struts创建一个Action，如果想控制它的执行顺序将会非常困难。甚至你要重新去写Servlet来实现你的这个功能需求。</p>
<p>八、  对Action 执行前和后的处理. Struts处理Action的时候是基于class的hierarchies，很难在action处理前和后进行操作。</p>
<p>九、  对事件支持不够. 在struts中，实际是一个表单Form对应一个Action类(或DispatchAction)，换一句话说：在Struts中实际是一个表单只能 对应一个事件，struts这种事件方式称为application event，application event和component event相比是一种粗粒度的事件</p>
<h2 id="7、STRUTS的应用-如STRUTS架构"><a href="#7、STRUTS的应用-如STRUTS架构" class="headerlink" title="7、STRUTS的应用(如STRUTS架构)"></a>7、STRUTS的应用(如STRUTS架构)</h2><pre><code>Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。 采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架。 Struts有如下的主要功能： 一.包含一个controller servlet，能将用户的请求发送到相应的Action对象。 二.JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。 三.提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。
</code></pre><h2 id="8、说说struts1与struts2的区别。"><a href="#8、说说struts1与struts2的区别。" class="headerlink" title="8、说说struts1与struts2的区别。"></a>8、说说struts1与struts2的区别。</h2><pre><code>1.都是MVC的WEB框架,

2 struts1的老牌框架，应用很广泛，有很好的群众基础，使用它开发风险很小，成本更低！struts2虽然基于这个框架，但是应用群众并多，相对不成熟，未知的风险和变化很多，开发人员相对不好招，使用它开发项目的风险系数更大，用人成本更高！

3.struts2毕竟是站在前辈的基础设计出来，它会改善和完善struts1中的一些缺陷，struts1中一些悬而未决问题在struts2得到了解决。

4.struts1的前端控制器是一个Servlet，名称为ActionServlet，struts2的前端控制器是一个filter，在struts2.0中叫FilterDispatcher，在struts2.1中叫StrutsPrepareAndExecuteFilter。

5.struts1的action需要继承Action类，struts2的action可以不继承任何类；struts1对同一个路径的所有请求共享一个Action实例，struts2对同一个路径的每个请求分别使用一个独立Action实例对象，所有对于struts2的Action不用考虑线程安全问题。

6.在struts1中使用formbean封装请求参数，在struts2中直接使用action的属性来封装请求参数。

7.struts1中的多个业务方法放在一个Action中时（即继承DispatchAction时），要么都校验，要么都不校验；对于struts2，可以指定只对某个方法进行校验，当一个Action继承了ActionSupport且在这个类中只编写了validateXxx()方法，那么则只对Xxx()方法进行校验。
</code></pre><p>（一个请求来了的执行流程进行分析，struts2是自动支持分模块开发，并可以不同模块设置不同的url前缀，这是通过package的namespace来实现的；struts2是支持多种类型的视图；struts2的视图地址可以是动态的，即视图的名称是支持变量方式的，举例，论坛发帖失败后回来还要传递boardid。视图内容显示方面：它的标签用ognl，要el强大很多，在国际化方面支持分模块管理，两个模块用到同样的key，对应不同的消息；）</p>
<p>与Struts1不同，Struts2对用户的每一次请求都会创建一个Action，所以Struts2中的Action是线程安全的。</p>
<p>给我印象最深刻的是：struts配置文件中的redirect视图的url不能接受参数，而struts2配置文件中的redirect视图可以接受参数。</p>
<h2 id="9、hibernate中的update-和saveOrUpdate-的区别，session的load-和get-的区别。"><a href="#9、hibernate中的update-和saveOrUpdate-的区别，session的load-和get-的区别。" class="headerlink" title="9、hibernate中的update()和saveOrUpdate()的区别，session的load()和get()的区别。"></a>9、hibernate中的update()和saveOrUpdate()的区别，session的load()和get()的区别。</h2><h2 id="10、简述-Hibernate-和-JDBC-的优缺点-如何书写一个-one-to-many-配置文件"><a href="#10、简述-Hibernate-和-JDBC-的优缺点-如何书写一个-one-to-many-配置文件" class="headerlink" title="10、简述 Hibernate 和 JDBC 的优缺点? 如何书写一个 one to many 配置文件."></a>10、简述 Hibernate 和 JDBC 的优缺点? 如何书写一个 one to many 配置文件.</h2><h2 id="11、iBatis与Hibernate有什么不同"><a href="#11、iBatis与Hibernate有什么不同" class="headerlink" title="11、iBatis与Hibernate有什么不同?"></a>11、iBatis与Hibernate有什么不同?</h2><p>相同点：屏蔽jdbc api的底层访问细节，使用我们不用与jdbc api打交道，就可以访问数据。</p>
<p>jdbc api编程流程固定，还将sql语句与java代码混杂在了一起，经常需要拼凑sql语句，细节很繁琐。</p>
<p>ibatis的好处：屏蔽jdbc api的底层访问细节；将sql语句与java代码进行分离;提供了将结果集自动封装称为实体对象和对象的集合的功能，queryForList返回对象集合，用queryForObject返回单个对象；提供了自动将实体对象的属性传递给sql语句的参数。</p>
<p>Hibernate是一个全自动的orm映射工具，它可以自动生成sql语句,ibatis需要我们自己在xml配置文件中写sql语句，hibernate要比ibatis功能负责和强大很多。因为hibernate自动生成sql语句，我们无法控制该语句，我们就无法去写特定的高效率的sql。对于一些不太复杂的sql查询，hibernate可以很好帮我们完成，但是，对于特别复杂的查询，hibernate就很难适应了，这时候用ibatis就是不错的选择，因为ibatis还是由我们自己写sql语句。</p>
<h2 id="12、写Hibernate的一对多和多对一双向关联的orm配置"><a href="#12、写Hibernate的一对多和多对一双向关联的orm配置" class="headerlink" title="12、写Hibernate的一对多和多对一双向关联的orm配置?"></a>12、写Hibernate的一对多和多对一双向关联的orm配置?</h2><h2 id="13、hibernate的inverse属性的作用"><a href="#13、hibernate的inverse属性的作用" class="headerlink" title="13、hibernate的inverse属性的作用?"></a>13、hibernate的inverse属性的作用?</h2><p>解决方案一，按照Object[]数据取出数据，然后自己组bean</p>
<p>解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2</p>
<p>field2) ，然后在hql里面就可以直接生成这个bean了。</p>
<h2 id="14、在DAO中如何体现DAO设计模式"><a href="#14、在DAO中如何体现DAO设计模式" class="headerlink" title="14、在DAO中如何体现DAO设计模式?"></a>14、在DAO中如何体现DAO设计模式?</h2><p>解决方案一，按照Object[]数据取出数据，然后自己组bean</p>
<p>解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2</p>
<p>field2) ，然后在hql里面就可以直接生成这个bean了。</p>
<h2 id="15、spring-Hibernate中委托方案怎么配置"><a href="#15、spring-Hibernate中委托方案怎么配置" class="headerlink" title="15、spring+Hibernate中委托方案怎么配置?"></a>15、spring+Hibernate中委托方案怎么配置?</h2><p>解决方案一，按照Object[]数据取出数据，然后自己组bean</p>
<p>解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2</p>
<p>field2) ，然后在hql里面就可以直接生成这个bean了。</p>
<h2 id="16、spring-Hibernate中委托方案怎么配置"><a href="#16、spring-Hibernate中委托方案怎么配置" class="headerlink" title="16、spring+Hibernate中委托方案怎么配置?"></a>16、spring+Hibernate中委托方案怎么配置?</h2><p>解决方案一，按照Object[]数据取出数据，然后自己组bean</p>
<p>解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2</p>
<p>field2) ，然后在hql里面就可以直接生成这个bean了。</p>
<h2 id="17-hibernate进行多表查询每个表中各取几个字段，也就是说查询出来的结果集没有一个实体类与之对应如何解决；"><a href="#17-hibernate进行多表查询每个表中各取几个字段，也就是说查询出来的结果集没有一个实体类与之对应如何解决；" class="headerlink" title="17. hibernate进行多表查询每个表中各取几个字段，也就是说查询出来的结果集没有一个实体类与之对应如何解决；"></a>17. hibernate进行多表查询每个表中各取几个字段，也就是说查询出来的结果集没有一个实体类与之对应如何解决；</h2><p>解决方案一，按照Object[]数据取出数据，然后自己组bean</p>
<p>解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2</p>
<p>field2) ，然后在hql里面就可以直接生成这个bean了。</p>
<h2 id="18-介绍一下Hibernate的二级缓存"><a href="#18-介绍一下Hibernate的二级缓存" class="headerlink" title="18.介绍一下Hibernate的二级缓存"></a>18.介绍一下Hibernate的二级缓存</h2><p>按照以下思路来回答：（1）首先说清楚什么是缓存，（2）再说有了hibernate的Session就是一级缓存，即有了一级缓存，为什么还要有二级缓存，（3）最后再说如何配置Hibernate的二级缓存。 </p>
<p>（1）缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中（一个数据结构中），这个数据结构通常是或类似Hashmap，当以后要使用某个对象时，先查询缓存中是否有这个对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在缓存中，以便下次使用。下面是缓存的伪代码：</p>
<p>引出hibernate的第二级缓存，用下面的伪代码分析了Cache的实现原理</p>
<p>Dao</p>
<p>{</p>
<p>hashmap map = new map();</p>
<p>User getUser(integer id)</p>
<p>{</p>
<p>User user = map.get(id)</p>
<p>if(user == null)</p>
<p>{</p>
<p>user = session.get(id);</p>
<p>map.put(id,user);</p>
<p>}</p>
<p>return user;</p>
<p>}</p>
<p>}</p>
<p>Dao</p>
<p>{</p>
<p>Cache cache = null</p>
<p>setCache(Cache cache)</p>
<p>{</p>
<p>this.cache = cache</p>
<p>}</p>
<p>User getUser(int id)</p>
<p>{</p>
<p>if(cache!=null)</p>
<p>{</p>
<p>User user = cache.get(id);</p>
<p>if(user ==null)</p>
<p>{</p>
<p>user = session.get(id);</p>
<p>cache.put(id,user);</p>
<p>}</p>
<p>return user;</p>
<p>}</p>
<p>return session.get(id);</p>
<p>}</p>
<p>}</p>
<p>（2）Hibernate的Session就是一种缓存，我们通常将之称为Hibernate的一级缓存，当想使用session从数据库中查询出一个对象时，Session也是先从自己内部查看是否存在这个对象，存在则直接返回，不存在才去访问数据库，并将查询的结果保存在自己内部。由于Session代表一次会话过程，一个Session与一个数据库连接相关连，所以Session最好不要长时间保持打开，通常仅用于一个事务当中，在事务结束时就应关闭。并且Session是线程不安全的，被多个线程共享时容易出现问题。通常只有那种全局意义上的缓存才是真正的缓存应用，才有较大的缓存价值，因此，Hibernate的Session这一级缓存的缓存作用并不明显，应用价值不大。Hibernate的二级缓存就是要为Hibernate配置一种全局缓存，让多个线程和多个事务都可以共享这个缓存。我们希望的是一个人使用过，其他人也可以使用，session没有这种效果。</p>
<p>（3）二级缓存是独立于Hibernate的软件部件，属于第三方的产品，多个厂商和组织都提供有缓存产品，例如，EHCache和OSCache等等。在Hibernate中使用二级缓存，首先就要在hibernate.cfg.xml配置文件中配置使用哪个厂家的缓存产品，接着需要配置该缓存产品自己的配置文件，最后要配置Hibernate中的哪些实体对象要纳入到二级缓存的管理中。明白了二级缓存原理和有了这个思路后，很容易配置起Hibernate的二级缓存。扩展知识：一个SessionFactory可以关联一个二级缓存，也即一个二级缓存只能负责缓存一个数据库中的数据，当使用Hibernate 的二级缓存后，注意不要有其他的应用或SessionFactory来更改当前数据库中的数据，这样缓存的数据就会与数据库中的实际数据不一致。</p>
<h2 id="19、Spring-的依赖注入是什么意思-给一个-Bean-的-message-属性-字符串类型-注入值为-“Hello”-的-XML-配置文件该怎么写"><a href="#19、Spring-的依赖注入是什么意思-给一个-Bean-的-message-属性-字符串类型-注入值为-“Hello”-的-XML-配置文件该怎么写" class="headerlink" title="19、Spring 的依赖注入是什么意思? 给一个 Bean 的 message 属性, 字符串类型, 注入值为 “Hello” 的 XML 配置文件该怎么写?"></a>19、Spring 的依赖注入是什么意思? 给一个 Bean 的 message 属性, 字符串类型, 注入值为 “Hello” 的 XML 配置文件该怎么写?</h2><h2 id="20、Jdo是什么"><a href="#20、Jdo是什么" class="headerlink" title="20、Jdo是什么?"></a>20、Jdo是什么?</h2><p>JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。</p>
<h2 id="21-什么是spring的IOC-AOP"><a href="#21-什么是spring的IOC-AOP" class="headerlink" title="21.什么是spring的IOC  AOP"></a>21.什么是spring的IOC  AOP</h2><h2 id="22-STRUTS的工作流程！"><a href="#22-STRUTS的工作流程！" class="headerlink" title="22.STRUTS的工作流程！"></a>22.STRUTS的工作流程！</h2><h2 id="23-spring-与EJB的区别！！"><a href="#23-spring-与EJB的区别！！" class="headerlink" title="23.spring 与EJB的区别！！"></a>23.spring 与EJB的区别！！</h2>]]></content>
      
        
        <tags>
            
            <tag> Struts </tag>
            
            <tag> Hibernate </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
